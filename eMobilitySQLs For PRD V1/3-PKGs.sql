create or replace PACKAGE "PKG_IFACE_RFID" as

  procedure RFIDToolCheckOut(n_Batch number, s_issueto varchar2, s_location varchar2, s_bin varchar2);
  procedure RFIDToolCheckIn(n_Batch number, s_location varchar2, s_bin varchar2);

  procedure ToolCheckOut (n_Batch_in number, n_Qty_in number, n_WO_in IN OUT number,
      s_Task_Card_in IN OUT varchar2, s_Issue_To_in varchar2, s_Issue_to_Employee_in varchar2,
      s_Location_in varchar2, s_Bin_in varchar2, n_Notes_in number, s_User_in varchar2,n_transaction_no number, s_ac_in VARCHAR2);

  procedure ToolCheckIn(n_Batch number, s_location varchar2, s_bin varchar2,
                      n_notes number, dt_sos_date date, n_sos_hour number,
                      n_sos_minute number, n_gr_batch number, s_pn varchar2,
                      s_sn varchar2, s_ac varchar2, s_condition varchar2,
                      n_wo number, s_us varchar2, s_ri varchar2, N_QTY NUMBER,
                      S_USER_IN VARCHAR2);

  procedure decode_rfid_memory(s_user_memory varchar2, s_manufacturer out nocopy varchar2, s_sn out nocopy varchar2, s_pn out nocopy varchar2, s_batch out nocopy varchar2);

  procedure save_bin_transfer(p_batch in PN_INVENTORY_DETAIL.BATCH%type,
                              p_bin in PN_INVENTORY_DETAIL.BIN%type,
                              p_transaction in number,
                              p_quantity in pn_inventory_history.qty%type);

  function get_batch_status(n_batch number) return xmltype;

end pkg_iface_rfid;

/


create or replace PACKAGE BODY "PKG_IFACE_RFID" AS

  CURSOR CUR_INVENTORY_TRANS(P_BATCH IN VARCHAR2) IS
    SELECT "PN_INVENTORY_DETAIL"."BATCH",
           "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH",
           "PN_INVENTORY_DETAIL"."VENDOR_LOT",
           "PN_INVENTORY_DETAIL"."PN",
           "PN_INVENTORY_DETAIL"."SN",
           "PN_INVENTORY_DETAIL"."NHA_PN",
           "PN_INVENTORY_DETAIL"."NHA_SN",
           "PN_INVENTORY_DETAIL"."CONDITION",
           "PN_INVENTORY_DETAIL"."OWNER",
           "PN_INVENTORY_DETAIL"."UNIT_COST",
           "PN_INVENTORY_DETAIL"."CURRENCY",
           "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE",
           "PN_INVENTORY_DETAIL"."RI_BY",
           "PN_INVENTORY_DETAIL"."RI_DATE",
           "PN_INVENTORY_DETAIL"."INSTALLED_AC",
           "PN_INVENTORY_DETAIL"."INSTALLED_POSITION",
           "PN_INVENTORY_DETAIL"."INSTALLED_DATE",
           "PN_INVENTORY_DETAIL"."INSTALLED_HOUR",
           "PN_INVENTORY_DETAIL"."INSTALLED_MINUTE",
           "PN_INVENTORY_DETAIL"."LOCATION",
           "PN_INVENTORY_DETAIL"."BIN",
           "PN_INVENTORY_DETAIL"."QTY_AVAILABLE",
           "PN_INVENTORY_DETAIL"."QTY_RESERVED",
           "PN_INVENTORY_DETAIL"."QTY_IN_TRANSFER",
           "PN_INVENTORY_DETAIL"."QTY_PENDING_RI",
           "PN_INVENTORY_DETAIL"."QTY_US",
           "PN_INVENTORY_DETAIL"."QTY_IN_REPAIR",
           "PN_INVENTORY_DETAIL"."RI_CONTROL",
           "PN_INVENTORY_DETAIL"."US_CODE",
           "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION",
           "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION",
           "PN_INVENTORY_DETAIL"."LOAN_CATEGORY",
           "PN_INVENTORY_DETAIL"."CUTOM_DUTY_CODE",
           "PN_INVENTORY_DETAIL"."GL_COMPANY",
           "PN_INVENTORY_DETAIL"."GL_EXPENDITURE",
           "PN_INVENTORY_DETAIL"."GL",
           "PN_INVENTORY_DETAIL"."GL_COST_CENTER",
           "PN_INVENTORY_DETAIL"."NOTES",
           "PN_INVENTORY_DETAIL"."CREATED_BY",
           "PN_INVENTORY_DETAIL"."CREATED_DATE",
           "PN_INVENTORY_DETAIL"."MODIFIED_BY",
           "PN_INVENTORY_DETAIL"."MODIFIED_DATE",
           "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_DATE",
           "PN_INVENTORY_DETAIL"."KIT_NO",
           "PN_INVENTORY_DETAIL"."CURRENCY_EXCHANGE_RATE",
           "PN_INVENTORY_DETAIL"."QTY_IN_RENTAL",
           "PN_INVENTORY_DETAIL"."SECONDARY_COST",
           "PN_INVENTORY_DETAIL"."SECONDARY_CURRENCY_EXCHANGE",
           "PN_INVENTORY_DETAIL"."BLOB_NO",
           "PN_INVENTORY_DETAIL"."ORIGINAL_AC",
           "PN_INVENTORY_DETAIL"."MOD_STATUS",
           "PN_INVENTORY_DETAIL"."CUSTOM_DUTY_DOCUMENT",
           "PN_INVENTORY_DETAIL"."PENDING",
           "PN_INVENTORY_DETAIL"."PENDING_DATE",
           "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE_ORIGINAL",
           "PN_INVENTORY_DETAIL"."SOS_DATE",
           "PN_INVENTORY_DETAIL"."SOS_HOUR",
           "PN_INVENTORY_DETAIL"."SOS_MINUTE",
           "PN_INVENTORY_DETAIL"."TAG_BY",
           "PN_INVENTORY_DETAIL"."TAG_DATE",
           "PN_INVENTORY_DETAIL"."TAG_NO",
           "PN_INVENTORY_DETAIL"."ORIGINAL_RECORDS_BY",
           "PN_INVENTORY_DETAIL"."ORGINAL_RECORDS_DATE",
           "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT",
           "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT_DATE",
           "PN_INVENTORY_DETAIL"."PN_MODEL",
           "PN_INVENTORY_DETAIL"."PN_SOFTWARE",
           "PN_INVENTORY_DETAIL"."FILING_SEQUENCE",
           "PN_INVENTORY_DETAIL"."NO_OF_TAG_PRINT",
           "PN_INVENTORY_DETAIL"."OWNER_ORIGIN",
           "PN_INVENTORY_DETAIL"."INVENTORY_TYPE",
           "PN_INVENTORY_DETAIL"."ADJUSTMENT_CODE",
           "PN_INVENTORY_DETAIL"."EXTERNAL_REFERENCE",
           "PN_INVENTORY_DETAIL"."EXTERNAL_POSITION"
      FROM "PN_INVENTORY_DETAIL",
           "PN_INTERCHANGEABLE",
           "PN_MASTER"
     WHERE ( "PN_MASTER"."PN" = "PN_INTERCHANGEABLE"."PN" ) AND
           ( "PN_INVENTORY_DETAIL"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) AND
           ( ( "PN_INVENTORY_DETAIL"."BATCH" = P_BATCH ) );

  PROCEDURE RFIDTOOLCHECKOUT(N_BATCH NUMBER, S_ISSUETO VARCHAR2, S_LOCATION VARCHAR2, S_BIN VARCHAR2)
  AS
    R_PN_INV_DET PN_INVENTORY_DETAIL%ROWTYPE;
    R_PN_INV_HIS PN_INVENTORY_HISTORY%ROWTYPE;
    DT_CURRENTDATE DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
  BEGIN
    


    SELECT *
      INTO R_PN_INV_DET
      FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;
    


    R_PN_INV_HIS.TRANSACTION_NO := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('PNINVHIS');
    R_PN_INV_HIS.TRANSACTION_TYPE := 'TOOL-OUT';
    R_PN_INV_HIS.BATCH := N_BATCH;
    R_PN_INV_HIS.GOODS_RCVD_BATCH := R_PN_INV_DET.GOODS_RCVD_BATCH;
    R_PN_INV_HIS.PN := R_PN_INV_DET.PN;
    R_PN_INV_HIS.SN := R_PN_INV_DET.SN;
    R_PN_INV_HIS.QTY := 1;
    R_PN_INV_HIS.CREATED_DATE := DT_CURRENTDATE;
    R_PN_INV_HIS.MODIFIED_DATE := DT_CURRENTDATE;
    R_PN_INV_HIS.CREATED_BY := 'TRAXIFACE';
    R_PN_INV_HIS.MODIFIED_BY := 'TRAXIFACE';
    R_PN_INV_HIS.LOCATION := S_LOCATION;
    R_PN_INV_HIS.BIN := S_BIN;
    R_PN_INV_HIS.CONDITION := R_PN_INV_DET.CONDITION;
    R_PN_INV_HIS.GL_COMPANY := R_PN_INV_DET.GL_COMPANY;
    R_PN_INV_HIS.GL_EXPENDITURE := R_PN_INV_DET.GL_EXPENDITURE;
    R_PN_INV_HIS.GL := R_PN_INV_DET.GL;
    R_PN_INV_HIS.GL_COST_CENTER := R_PN_INV_DET.GL_COST_CENTER;
    R_PN_INV_HIS.UNIT_COST := 0;
    R_PN_INV_HIS.ISSUED_TO := S_ISSUETO;
    R_PN_INV_HIS.CUSTOM_DUTY_CODE := R_PN_INV_DET.CUTOM_DUTY_CODE;
    R_PN_INV_HIS.QTY_RETURN_STOCK := 0;
    R_PN_INV_HIS.STATUS := 'OPEN';
    R_PN_INV_HIS.CURRENCY_EXCHANGE_RATE := 1;
    R_PN_INV_HIS.SECONDARY_COST := 0;

    R_PN_INV_HIS.CUSTOM_DUTY_DOCUMENT := R_PN_INV_DET.CUSTOM_DUTY_DOCUMENT;
    R_PN_INV_HIS.OWNER := R_PN_INV_DET.OWNER;

    


    INSERT INTO PN_INVENTORY_HISTORY VALUES R_PN_INV_HIS;

    UPDATE PN_INVENTORY_DETAIL
    SET    QTY_AVAILABLE = (R_PN_INV_DET.QTY_AVAILABLE - 1),
           LOCATION = NULL,
           BIN = NULL,
           PENDING = 'TOOL-OUT',
           PENDING_DATE = DT_CURRENTDATE,
           MODIFIED_BY = 'TRAXIFACE',
           MODIFIED_DATE = DT_CURRENTDATE
    WHERE BATCH = N_BATCH
    AND LOCATION = S_LOCATION
    AND BIN = S_BIN;

  END RFIDTOOLCHECKOUT;
  
  PROCEDURE TOOLCHECKOUT (N_BATCH_IN NUMBER, N_QTY_IN NUMBER, N_WO_IN IN OUT NUMBER,
        S_TASK_CARD_IN IN OUT VARCHAR2, S_ISSUE_TO_IN VARCHAR2, S_ISSUE_TO_EMPLOYEE_IN VARCHAR2,
        S_LOCATION_IN VARCHAR2, S_BIN_IN VARCHAR2, N_NOTES_IN NUMBER, S_USER_IN VARCHAR2, N_TRANSACTION_NO NUMBER, S_AC_IN VARCHAR2) 
  AS
    R_PN_INV_DET PN_INVENTORY_DETAIL%ROWTYPE;
    R_PN_INV_HIS PN_INVENTORY_HISTORY%ROWTYPE;
    DT_TODAY DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    GL_COMPANY "SYSTEM_TRAN_CODE"."SYSTEM_TRAN_CODE_SUB"%TYPE;
    
    
    N_ROW_COUNT NUMBER;
    WO_LINE WO.WO%TYPE;
    
    TYPE ST_EUD IS RECORD(
       N_BATCH                PN_INVENTORY_DETAIL."BATCH"%TYPE,
       N_GRB                  PN_INVENTORY_DETAIL."GOODS_RCVD_BATCH"%TYPE,
       S_PN                   PN_INVENTORY_DETAIL."PN"%TYPE,
       S_SN                   PN_INVENTORY_DETAIL."SN"%TYPE,
       S_CONDITION            PN_INVENTORY_DETAIL."CONDITION"%TYPE,
       S_OWNER                PN_INVENTORY_DETAIL."OWNER"%TYPE,
       N_UNIT_COST            PN_INVENTORY_DETAIL."UNIT_COST"%TYPE,
       S_LOCATION             PN_INVENTORY_DETAIL."LOCATION"%TYPE,
       S_BIN                  PN_INVENTORY_DETAIL."BIN"%TYPE,
       N_QTY_AVAIL            PN_INVENTORY_DETAIL."QTY_AVAILABLE"%TYPE,
       S_LOAN_CATEGORY        PN_INVENTORY_DETAIL."LOAN_CATEGORY"%TYPE,
       S_CUSTOM_DUTY_CODE     PN_INVENTORY_DETAIL."CUTOM_DUTY_CODE"%TYPE,
       S_GL_COMPANY           PN_INVENTORY_DETAIL."GL_COMPANY"%TYPE,
       S_GL_EXPENDITURE       PN_INVENTORY_DETAIL."GL_EXPENDITURE"%TYPE,
       S_GL                   PN_INVENTORY_DETAIL."GL"%TYPE,
       S_GL_COST_CENTER       PN_INVENTORY_DETAIL."GL_COST_CENTER"%TYPE,
       S_CUSTOM_DUTY_DOCUMENT PN_INVENTORY_DETAIL."CUSTOM_DUTY_DOCUMENT"%TYPE,
       S_PENDING              PN_INVENTORY_DETAIL.PENDING%TYPE,
       DT_PENDING_DATE        PN_INVENTORY_DETAIL.PENDING_DATE%TYPE,
       DT_MODIFIED_DATE       PN_INVENTORY_DETAIL.MODIFIED_DATE%TYPE,
       S_MODIFIED_BY          PN_INVENTORY_DETAIL.MODIFIED_BY%TYPE
    );
    
       
    DW_EUD          ST_EUD;
    MS_PN           PKG_TYPE_STRUCTURES.ST_PN;
    MS_WO           PKG_TYPE_STRUCTURES.ST_WO;
    S_EXPENDITURE   WO.EXPENDITURE%TYPE;
    S_TPW           WO.THIRD_PARTY_WO%TYPE;
    S_AC           VARCHAR2 (10 char) ;
    S_BIN_HIS       PN_INVENTORY_DETAIL.BIN%TYPE;
    S_LOCATION_HIS       PN_INVENTORY_DETAIL."LOCATION"%TYPE; 
    
    
    S_PN_TRANSACTION              SYSTEM_TRAN_CODE.PN_TRANSACTION%TYPE;
    S_PN_COSTING_METHOD           SYSTEM_TRAN_CODE.PN_COSTING_METHOD%TYPE;
    N_AVERAGE_COST                PN_MASTER.AVERAGE_COST%TYPE;
    N_SECONDARY_COST              SYSTEM_TRAN_CODE.CURRENCY_EXCHANGE%TYPE;
    S_SECONDARY_CURRENCY          SYSTEM_TRAN_CODE.SYSTEM_CODE%TYPE;
    N_SECONDARY_CURRENCY_EXCHANGE SYSTEM_TRAN_CODE.CURRENCY_EXCHANGE%TYPE;
  BEGIN
  
  plog.debug (s_ac_in) ; 
      IF N_WO_IN = 0 THEN
        SELECT WL."WO"
        INTO WO_LINE
        FROM WO WL
        WHERE WL."AC" = S_AC_IN
        AND WL."STATUS" = 'LINE';
      END IF ;
      
      IF NOT NVL(WO_LINE,0) = 0 AND N_WO_IN = 0 THEN
        N_WO_IN := WO_LINE;
        S_AC := S_AC_IN;
      BEGIN
        
        SELECT TC."TASK_CARD"
        INTO S_TASK_CARD_IN
        FROM WO_TASK_CARD TC
        WHERE TC."WO"=N_WO_IN;
      
        EXCEPTION
        WHEN NO_DATA_FOUND THEN NULL;
      END;
        
      END IF;    
      
      IF S_AC_IN IS NULL THEN
      BEGIN
        SELECT WL."AC"
        INTO S_AC
        FROM WO WL
        WHERE WL."WO" = N_WO_IN;
       EXCEPTION                             ---Log 246814
        WHEN NO_DATA_FOUND THEN NULL;
       END; 
      END IF;
     
      SELECT COUNT(*)
      INTO N_ROW_COUNT
      FROM PN_INVENTORY_DETAIL PNID, PN_INTERCHANGEABLE PNI, PN_MASTER PNM
      WHERE ( PNM."PN" = PNI."PN" ) AND
            ( PNID."PN" = PNI."PN_INTERCHANGEABLE" ) AND
            ( PNID."BATCH" = N_BATCH_IN );
           
      IF (N_ROW_COUNT = 0) THEN
        DBMS_OUTPUT.PUT_LINE('Batch: ' || N_BATCH_IN || ' not found.');
        RETURN;
      END IF;
      
      SELECT PNID.BATCH, PNID.GOODS_RCVD_BATCH,
               PNID.PN, PNID.SN, PNID.CONDITION,
               PNID.OWNER, PNID.UNIT_COST,
               PNID.LOCATION, PNID.BIN,
               PNID.QTY_AVAILABLE, PNID.LOAN_CATEGORY,
               PNID.CUTOM_DUTY_CODE, PNID.GL_COMPANY,
               PNID.GL_EXPENDITURE, PNID.GL,
               PNID.GL_COST_CENTER, PNID.CUSTOM_DUTY_DOCUMENT
        INTO DW_EUD.N_BATCH, DW_EUD.N_GRB, DW_EUD.S_PN,
             DW_EUD.S_SN, DW_EUD.S_CONDITION, DW_EUD.S_OWNER,
             DW_EUD.N_UNIT_COST, DW_EUD.S_LOCATION,
             DW_EUD.S_BIN, DW_EUD.N_QTY_AVAIL,
             DW_EUD.S_LOAN_CATEGORY, DW_EUD.S_CUSTOM_DUTY_CODE,
             DW_EUD.S_GL_COMPANY, DW_EUD.S_GL_EXPENDITURE,
             DW_EUD.S_GL, DW_EUD.S_GL_COST_CENTER,
             DW_EUD.S_CUSTOM_DUTY_DOCUMENT
        FROM PN_INVENTORY_DETAIL PNID, PN_INTERCHANGEABLE PNI, PN_MASTER PNM
        WHERE ( PNM."PN" = PNI."PN" ) AND
              ( PNID."PN" = PNI."PN_INTERCHANGEABLE" ) AND
              ( PNID."BATCH" = N_BATCH_IN );
            
      MS_PN.S_LOAN_CATEGORY := DW_EUD.S_LOAN_CATEGORY;
      
      
      IF (DW_EUD.S_OWNER IS NOT NULL) AND (DW_EUD.S_OWNER > '0') THEN
        MS_PN.S_PN := DW_EUD.S_PN;
        MS_PN.S_LOCATION := DW_EUD.S_LOCATION;
        MS_PN.N_QTY := N_QTY_IN;
        MS_PN.N_BATCH := DW_EUD.N_BATCH;
        MS_PN.N_WO := N_WO_IN;
        
        IF PKG_FUNCTION_INVENTORY.CONSIGNMENT(MS_PN) = 0 THEN
          DW_EUD.S_OWNER := NULL;
        END IF;
        
        
        SELECT PNID.BATCH, PNID.GOODS_RCVD_BATCH,
               PNID.PN, PNID.SN, PNID.CONDITION,
               PNID.OWNER, PNID.UNIT_COST,
               PNID.LOCATION, PNID.BIN,
               PNID.QTY_AVAILABLE, PNID.LOAN_CATEGORY,
               PNID.CUTOM_DUTY_CODE, PNID.GL_COMPANY,
               PNID.GL_EXPENDITURE, PNID.GL,
               PNID.GL_COST_CENTER, PNID.CUSTOM_DUTY_DOCUMENT
        INTO DW_EUD.N_BATCH, DW_EUD.N_GRB, DW_EUD.S_PN,
             DW_EUD.S_SN, DW_EUD.S_CONDITION, DW_EUD.S_OWNER,
             DW_EUD.N_UNIT_COST, DW_EUD.S_LOCATION,
             DW_EUD.S_BIN, DW_EUD.N_QTY_AVAIL,
             DW_EUD.S_LOAN_CATEGORY, DW_EUD.S_CUSTOM_DUTY_CODE,
             DW_EUD.S_GL_COMPANY, DW_EUD.S_GL_EXPENDITURE,
             DW_EUD.S_GL, DW_EUD.S_GL_COST_CENTER,
             DW_EUD.S_CUSTOM_DUTY_DOCUMENT
        FROM PN_INVENTORY_DETAIL PNID, PN_INTERCHANGEABLE PNI, PN_MASTER PNM
        WHERE ( PNM."PN" = PNI."PN" ) AND
              ( PNID."PN" = PNI."PN_INTERCHANGEABLE" ) AND
              ( PNID."BATCH" = N_BATCH_IN );
        
      END IF;
      
      IF (DW_EUD.S_OWNER IS NOT NULL) AND (DW_EUD.S_OWNER > '0') THEN
        DW_EUD.N_UNIT_COST := 0;
      END IF;
      
      
      MS_WO.L_WO := N_WO_IN;
      MS_WO.S_TASK_CARD := S_TASK_CARD_IN;
      
      BEGIN
      PKG_FUNCTION_WO.WO_EXPENDITURE_LOAD(
          MS_WO.L_WO, 
          MS_WO.S_TASK_CARD,
          MS_WO.S_AC,
          MS_WO.S_PN,
          MS_WO.S_SN,
          MS_WO.S_EXPENDITURE,
          MS_WO.S_TPW,
          MS_WO.S_EO);
      EXCEPTION
        WHEN NO_DATA_FOUND THEN NULL;
      END;
      
      S_EXPENDITURE := MS_WO.S_EXPENDITURE;
      S_TPW := MS_WO.S_TPW;
      S_AC := MS_WO.S_AC;
      S_BIN_HIS := DW_EUD.S_BIN;
      S_LOCATION_HIS := DW_EUD.S_LOCATION; 
      
      IF (N_QTY_IN = DW_EUD.N_QTY_AVAIL) THEN
        DW_EUD.S_LOCATION := NULL;
        DW_EUD.S_BIN := NULL;
        DW_EUD.N_QTY_AVAIL := 0;
        DW_EUD.S_PENDING := 'TOOL-OUT';
        DW_EUD.DT_PENDING_DATE := DT_TODAY;
      ELSE
        DW_EUD.N_QTY_AVAIL := DW_EUD.N_QTY_AVAIL - N_QTY_IN;
        
        IF (DW_EUD.N_QTY_AVAIL < 0) THEN 
          DW_EUD.N_QTY_AVAIL := 0;
        END IF;
      END IF;
      
      MS_PN.S_TRANSACTION_TYPE := 'TOOL-OUT';
      MS_PN.S_PN := DW_EUD.S_PN;
      MS_PN.S_SN := DW_EUD.S_SN;
      MS_PN.N_QTY := 0;
      MS_PN.N_QTY_RESERVED := 0;
      
      IF (N_QTY_IN = DW_EUD.N_QTY_AVAIL) THEN
        MS_PN.N_QTY_AVAILABLE := 0;
      ELSE
        MS_PN.N_QTY_AVAILABLE := DW_EUD.N_QTY_AVAIL - N_QTY_IN;
        IF (DW_EUD.N_QTY_AVAIL < 0) THEN
          MS_PN.N_QTY_AVAILABLE := 0;
        END IF;
      END IF;
      
      PKG_FUNCTION_INVENTORY.NLA_INVENTORY_TRAN(MS_PN);
      
      IF (DW_EUD.S_SN > '0') THEN
        DW_EUD.S_LOCATION := NULL;
        DW_EUD.S_BIN := NULL;
      END IF;
      
      DW_EUD.DT_MODIFIED_DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
      DW_EUD.S_MODIFIED_BY := S_USER_IN;
      
      
      SELECT STC.PN_TRANSACTION,
             STC.PN_COSTING_METHOD,
             PNM.AVERAGE_COST,
             STC.SYSTEM_TRAN_CODE_SUB
      INTO S_PN_TRANSACTION,
           S_PN_COSTING_METHOD,
           N_AVERAGE_COST,
           GL_COMPANY
      FROM PN_INTERCHANGEABLE PNI,
           PN_MASTER PNM,
           SYSTEM_TRAN_CODE STC
      WHERE (PNM.PN = PNI.PN) AND
            (PNM.CATEGORY = STC.SYSTEM_CODE) AND
            ( (PNI.PN_INTERCHANGEABLE = DW_EUD.S_PN) AND
              (STC.SYSTEM_TRANSACTION = 'PNCATEGORY') );
      
      DW_EUD.N_UNIT_COST := 0;
      N_SECONDARY_COST := 0;
      
      
      PKG_FUNCTION_GL.GET_SECONDARY_CURRENCY(S_SECONDARY_CURRENCY, N_SECONDARY_CURRENCY_EXCHANGE , GL_COMPANY ) ;
      IF N_SECONDARY_CURRENCY_EXCHANGE = 0 THEN 
          N_SECONDARY_CURRENCY_EXCHANGE:=1;  
      END IF;

     N_SECONDARY_COST := DW_EUD.N_UNIT_COST / N_SECONDARY_CURRENCY_EXCHANGE;
      
      IF (DW_EUD.S_OWNER < '0') THEN
        DW_EUD.S_OWNER := NULL;
      END IF;
      
      
      INSERT INTO PN_INVENTORY_HISTORY
            ( TRANSACTION_NO,
              TRANSACTION_TYPE,
              BATCH,
              GOODS_RCVD_BATCH,
              PN,
              SN,
              QTY,
              NOTES,
              CREATED_BY,
              CREATED_DATE,
              MODIFIED_BY,
              MODIFIED_DATE,
              LOCATION,
              BIN,
              CONDITION,
              WO,
              TASK_CARD,
              GL_COMPANY,
              GL_EXPENDITURE,
              GL,
              GL_COST_CENTER,
              UNIT_COST,
              ISSUED_TO,
              CUSTOM_DUTY_CODE,
              QTY_RETURN_STOCK,
              STATUS,
              CURRENCY_EXCHANGE_RATE,
              SECONDARY_COST,
              SECONDARY_CURRENCY_EXCHANGE,
              AC,
              CUSTOM_DUTY_DOCUMENT,
              OWNER,
              ISSUE_TO_EMPLOYEE)
      VALUES ( N_TRANSACTION_NO,
              'TOOL-OUT',
              N_BATCH_IN,
              DW_EUD.N_GRB,
              DW_EUD.S_PN,
              DW_EUD.S_SN,
              N_QTY_IN,
              N_NOTES_IN,
              S_USER_IN,
              DT_TODAY,
              S_USER_IN,
              DT_TODAY,
              S_LOCATION_HIS, 
              S_BIN_HIS,
              DW_EUD.S_CONDITION,
              N_WO_IN,
              S_TASK_CARD_IN,
              DW_EUD.S_GL_COMPANY,
              DW_EUD.S_GL_EXPENDITURE,
              DW_EUD.S_GL,
              DW_EUD.S_GL_COST_CENTER,
              0,
              S_ISSUE_TO_IN,
              DW_EUD.S_CUSTOM_DUTY_CODE,
              0,
              'OPEN',
              1,
              0,
              N_SECONDARY_CURRENCY_EXCHANGE,
              S_AC,
              DW_EUD.S_CUSTOM_DUTY_DOCUMENT,
              DW_EUD.S_OWNER,
              S_ISSUE_TO_EMPLOYEE_IN);
              
      UPDATE PN_INVENTORY_DETAIL
      SET LOCATION = DW_EUD.S_LOCATION,
          QTY_AVAILABLE = DW_EUD.N_QTY_AVAIL, 
          BIN = DW_EUD.S_BIN, 
          MODIFIED_BY = S_USER_IN,
          MODIFIED_DATE = DT_TODAY,
          CONDITION = DW_EUD.S_CONDITION,
          NOTES = N_NOTES_IN,
          CUTOM_DUTY_CODE = DW_EUD.S_CUSTOM_DUTY_CODE,
          PENDING = DW_EUD.S_PENDING,
          PENDING_DATE = DW_EUD.DT_PENDING_DATE
      WHERE BATCH = N_BATCH_IN;   
      
      COMMIT;
              
      
      --PKG_FUNCTION_INVENTORY.PENDING_STATUS('TOOL-OUT', DW_EUD.S_PN, DW_EUD.S_SN);
    
      
      PKG_FUNCTION_INVENTORY.PN_INVENTORY_HISTORY_NLA_LOAD(N_TRANSACTION_NO, S_USER_IN);
      
      
      IF (PKG_FUNCTION_INVENTORY.INVENTORY_LEVEL_CHECK_REORDER('CHECK-OUT', DW_EUD.S_PN) = 'YES') THEN
         PKG_FUNCTION_INVENTORY.INVENTORY_LEVEL_CHECK(NVL(TRIM(DW_EUD.S_LOCATION), S_LOCATION_IN), DW_EUD.S_PN); 
      END IF;
      
      
      PKG_FUNCTION_INVENTORY.LOAD_PN_INVENTORY_DETAIL_AUDIT(N_BATCH_IN, 'YES', 'YES', 'YES');
  END TOOLCHECKOUT;

  PROCEDURE RFIDTOOLCHECKIN(N_BATCH NUMBER, S_LOCATION VARCHAR2, S_BIN VARCHAR2)
  AS
    R_PN_INV_DET PN_INVENTORY_DETAIL%ROWTYPE;
    R_PN_INV_HIS PN_INVENTORY_HISTORY%ROWTYPE;
    DT_CURRENTDATE DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
  BEGIN

    


    SELECT *
    INTO R_PN_INV_DET
    FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;

    


    R_PN_INV_HIS.TRANSACTION_NO := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('PNINVHIS');
    R_PN_INV_HIS.TRANSACTION_TYPE := 'TOOL-IN';
    R_PN_INV_HIS.BATCH := N_BATCH;
    R_PN_INV_HIS.GOODS_RCVD_BATCH := R_PN_INV_DET.GOODS_RCVD_BATCH;
    R_PN_INV_HIS.PN := R_PN_INV_DET.PN;
    R_PN_INV_HIS.SN := R_PN_INV_DET.SN;
    R_PN_INV_HIS.QTY := 1;
    R_PN_INV_HIS.CREATED_DATE := DT_CURRENTDATE;
    R_PN_INV_HIS.MODIFIED_DATE := DT_CURRENTDATE;
    R_PN_INV_HIS.CREATED_BY := 'TRAXIFACE';
    R_PN_INV_HIS.MODIFIED_BY := 'TRAXIFACE';
    R_PN_INV_HIS.LOCATION := S_LOCATION;
    R_PN_INV_HIS.BIN := S_BIN;
    R_PN_INV_HIS.CONDITION := R_PN_INV_DET.CONDITION;
    R_PN_INV_HIS.GL_COMPANY := R_PN_INV_DET.GL_COMPANY;
    R_PN_INV_HIS.GL_EXPENDITURE := R_PN_INV_DET.GL_EXPENDITURE;
    R_PN_INV_HIS.GL := R_PN_INV_DET.GL;
    R_PN_INV_HIS.GL_COST_CENTER := R_PN_INV_DET.GL_COST_CENTER;
    R_PN_INV_HIS.UNIT_COST := 0;
    R_PN_INV_HIS.CUSTOM_DUTY_CODE := R_PN_INV_DET.CUTOM_DUTY_CODE;
    R_PN_INV_HIS.QTY_RETURN_STOCK := 0;
    R_PN_INV_HIS.STATUS := 'OPEN';
    R_PN_INV_HIS.CURRENCY_EXCHANGE_RATE := 1;
    R_PN_INV_HIS.SECONDARY_COST := 0;

    R_PN_INV_HIS.CUSTOM_DUTY_DOCUMENT := R_PN_INV_DET.CUSTOM_DUTY_DOCUMENT;
    R_PN_INV_HIS.OWNER := R_PN_INV_DET.OWNER;

    IF (TRIM(R_PN_INV_DET.SN) IS NOT NULL) THEN
      R_PN_INV_HIS.QTY_RETURN_STOCK := 1;
    END IF;



    


    INSERT INTO PN_INVENTORY_HISTORY VALUES R_PN_INV_HIS;

    UPDATE PN_INVENTORY_DETAIL
    SET QTY_AVAILABLE = (R_PN_INV_DET.QTY_AVAILABLE + 1),
        LOCATION = S_LOCATION,
        BIN = S_BIN,
        PENDING = NULL,
        PENDING_DATE = NULL,
        MODIFIED_BY = 'TRAXIFACE',
        MODIFIED_DATE = DT_CURRENTDATE
    WHERE BATCH = N_BATCH;

  END RFIDTOOLCHECKIN;
  
  PROCEDURE TOOLCHECKIN(N_BATCH NUMBER, S_LOCATION VARCHAR2, S_BIN VARCHAR2,
                        N_NOTES NUMBER, DT_SOS_DATE DATE, N_SOS_HOUR NUMBER,
                        N_SOS_MINUTE NUMBER, N_GR_BATCH NUMBER, S_PN VARCHAR2,
                        S_SN VARCHAR2, S_AC VARCHAR2, S_CONDITION VARCHAR2,
                        N_WO NUMBER, S_US VARCHAR2, S_RI VARCHAR2, N_QTY NUMBER, S_USER_IN VARCHAR2) 
  AS  
    MS_SECONDARY_CURRENCY PKG_TYPE_STRUCTURES.ST_SECONDARY_CURRENCY;
    MS_PN                 PKG_TYPE_STRUCTURES.ST_PN;
    
    R_PN_INV_DET PN_INVENTORY_DETAIL%ROWTYPE;
    R_PN_INV_HIS PN_INVENTORY_HISTORY%ROWTYPE;
    DT_TODAY DATE;
    
    GL_COMPANY "SYSTEM_TRAN_CODE"."SYSTEM_TRAN_CODE_SUB"%TYPE;
    S_QUARANTINE LOCATION_MASTER.INVENTORY_QUARANTINE%TYPE;
    N_QTY_AVAIL PN_INVENTORY_DETAIL.QTY_AVAILABLE%TYPE;
    N_QTY_RI PN_INVENTORY_DETAIL.QTY_PENDING_RI%TYPE;
    N_QTY_US PN_INVENTORY_DETAIL.QTY_US%TYPE;
    
  BEGIN
    DT_TODAY := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    
    SELECT INVENTORY_QUARANTINE
    INTO S_QUARANTINE
    FROM LOCATION_MASTER
    WHERE ( LOCATION = S_LOCATION) AND ( INVENTORY = 'Y' );  
    
    SELECT QTY_AVAILABLE,QTY_PENDING_RI,QTY_US
    INTO N_QTY_AVAIL, N_QTY_RI, N_QTY_US
    FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;
    
    IF 
      NVL(N_QTY_AVAIL,0) <= 0 THEN N_QTY_AVAIL := 0;
    END IF;
    IF 
      NVL(N_QTY_RI,0) <= 0 THEN N_QTY_RI := 0;
    END IF;  
    IF 
      NVL(N_QTY_US,0) <= 0 THEN N_QTY_US := 0;
    END IF;
           
    SELECT STC.SYSTEM_TRAN_CODE_SUB
      INTO GL_COMPANY
      FROM PN_INTERCHANGEABLE PNI,
           PN_MASTER PNM,
           SYSTEM_TRAN_CODE STC
      WHERE (PNM.PN = PNI.PN) AND
            (PNM.CATEGORY = STC.SYSTEM_CODE) AND
            ( (PNI.PN_INTERCHANGEABLE = S_PN) AND
              (STC.SYSTEM_TRANSACTION = 'PNCATEGORY') );       
         
           
    
    PKG_FUNCTION_GL.GET_SECONDARY_CURRENCY(MS_SECONDARY_CURRENCY.S_SECONDARY_CURRENCY, MS_SECONDARY_CURRENCY.N_SECONDARY_CURRENCY_EXCHANGE , gl_company);
    
    R_PN_INV_HIS.TRANSACTION_NO := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('PNINVHIS');
    R_PN_INV_HIS.TRANSACTION_TYPE := 'TOOL-IN';
    R_PN_INV_HIS.BATCH := N_BATCH;
    R_PN_INV_HIS.GOODS_RCVD_BATCH := N_GR_BATCH;
    R_PN_INV_HIS.PN := S_PN;
    R_PN_INV_HIS.SN := S_SN;
    R_PN_INV_HIS.QTY := N_QTY;
    R_PN_INV_HIS.NOTES := N_NOTES;
    R_PN_INV_HIS.CREATED_BY := S_USER_IN;
    R_PN_INV_HIS.CREATED_DATE := DT_TODAY;
    R_PN_INV_HIS.MODIFIED_BY := S_USER_IN;
    R_PN_INV_HIS.MODIFIED_DATE := DT_TODAY;
    R_PN_INV_HIS.LOCATION := S_LOCATION;
    R_PN_INV_HIS.BIN := S_BIN;
    R_PN_INV_HIS.CONDITION := S_CONDITION;
    R_PN_INV_HIS.WO := N_WO;
    R_PN_INV_HIS.UNIT_COST := 0;
    R_PN_INV_HIS.AC := S_AC;
    R_PN_INV_HIS.CURRENCY_EXCHANGE_RATE := 1;
    R_PN_INV_HIS.SECONDARY_COST := 0;
    R_PN_INV_HIS.SECONDARY_CURRENCY_EXCHANGE := MS_SECONDARY_CURRENCY.N_SECONDARY_CURRENCY_EXCHANGE;
  
    INSERT INTO PN_INVENTORY_HISTORY VALUES R_PN_INV_HIS;
    
    IF (TRIM(R_PN_INV_HIS.SN) IS NOT NULL) AND (S_SN > '0') THEN
      UPDATE PN_INVENTORY_HISTORY
      SET QTY_RETURN_STOCK = 1
      WHERE (PN = S_PN) AND
            (SN = S_SN) AND
            (TRANSACTION_TYPE = 'TOOL-OUT');
    END IF;
    
    IF (S_QUARANTINE = 'Y') THEN
      UPDATE PN_INVENTORY_DETAIL
      SET LOCATION = S_LOCATION,
          BIN = S_BIN,
          QTY_AVAILABLE = 0,
          QTY_US = N_QTY_US + R_PN_INV_HIS.QTY,
          US_CODE = S_US,
          RI_BY = NULL,
          MODIFIED_BY = S_USER_IN,
          MODIFIED_DATE = DT_TODAY,
          CONDITION = S_CONDITION,
          SOS_DATE = DT_SOS_DATE,
          SOS_HOUR = N_SOS_HOUR,
          SOS_MINUTE = N_SOS_MINUTE,
          NOTES = N_NOTES
      WHERE BATCH = N_BATCH;
      
      
      
      MS_PN.S_PN := S_PN;
      MS_PN.S_SN := S_SN;
      MS_PN.N_QTY_AVAILABLE := 0;
      MS_PN.N_QTY_US := N_QTY_US + R_PN_INV_HIS.QTY;
      MS_PN.N_QTY_PENDING_RI := 0;
      MS_PN.S_US_CODE := S_US;
      MS_PN.S_MODIFIED_BY := PKG_TRAX_SESSION.F_GETUSER;
      MS_PN.S_CONDITION := S_CONDITION;
      MS_PN.N_NOTES := N_NOTES;
      PKG_FUNCTION_INVENTORY.NLA_RETURN_TO_INVENTORY(MS_PN);
      
    ELSIF (S_RI = 'YES') THEN
      UPDATE PN_INVENTORY_DETAIL
      SET LOCATION = S_LOCATION,
          BIN = S_BIN,
          QTY_AVAILABLE = 0,
          QTY_US = 0,
          QTY_PENDING_RI = N_QTY_RI + R_PN_INV_HIS.QTY,
          RI_BY = NULL,
          MODIFIED_BY = S_USER_IN,
          MODIFIED_DATE = DT_TODAY,
          CONDITION = S_CONDITION,
          SOS_DATE = DT_SOS_DATE,
          SOS_HOUR = N_SOS_HOUR,
          SOS_MINUTE = N_SOS_MINUTE,
          NOTES = N_NOTES
      WHERE BATCH = N_BATCH;
      
      
      
      MS_PN.S_PN := S_PN;
      MS_PN.S_SN := S_SN;
      MS_PN.N_QTY_AVAILABLE := 0;
      MS_PN.N_QTY_US := 0;
      MS_PN.N_QTY_PENDING_RI :=  N_QTY_RI + R_PN_INV_HIS.QTY;
      MS_PN.S_MODIFIED_BY := PKG_TRAX_SESSION.F_GETUSER;
      MS_PN.S_CONDITION := S_CONDITION;
      MS_PN.N_NOTES := N_NOTES;
      PKG_FUNCTION_INVENTORY.NLA_RETURN_TO_INVENTORY(MS_PN);
    ELSE
      UPDATE PN_INVENTORY_DETAIL
      SET LOCATION = S_LOCATION,
          BIN = S_BIN,
          QTY_AVAILABLE = N_QTY_AVAIL + R_PN_INV_HIS.QTY,
          QTY_US = 0,
          RI_BY = NULL,
          MODIFIED_BY = S_USER_IN,
          MODIFIED_DATE = DT_TODAY,
          CONDITION = S_CONDITION,
          SOS_DATE = DT_SOS_DATE,
          SOS_HOUR = N_SOS_HOUR,
          SOS_MINUTE = N_SOS_MINUTE,
          NOTES = N_NOTES,
          PENDING = NULL
      WHERE BATCH = N_BATCH;
      
      
      
      MS_PN.S_PN := S_PN;
      MS_PN.S_SN := S_SN;
      MS_PN.N_QTY_AVAILABLE := N_QTY_AVAIL + R_PN_INV_HIS.QTY;
      MS_PN.N_QTY_US := 0;
      MS_PN.N_QTY_PENDING_RI := 0;
      MS_PN.S_MODIFIED_BY := PKG_TRAX_SESSION.F_GETUSER;
      MS_PN.S_CONDITION := S_CONDITION;
      MS_PN.N_NOTES := N_NOTES;
      PKG_FUNCTION_INVENTORY.NLA_RETURN_TO_INVENTORY(MS_PN);
    END IF;
    
    COMMIT;
    
    
    --PKG_FUNCTION_INVENTORY.PENDING_STATUS('TOOL-IN', S_PN, S_SN);
    
    
    PKG_FUNCTION_INVENTORY.PN_INVENTORY_HISTORY_NLA_LOAD
            (R_PN_INV_HIS.TRANSACTION_NO, PKG_TRAX_SESSION.F_GETUSER);
  
    
    
  END TOOLCHECKIN;

  FUNCTION EXTRACT_STRING(S_INPUT_STRING IN OUT NOCOPY VARCHAR, S_PATERN VARCHAR2)
  RETURN VARCHAR2
  AS
    S_OUPUT_STRING VARCHAR2(100);
  BEGIN
    IF INSTR(S_INPUT_STRING, S_PATERN) > 0 THEN
      SELECT REPLACE(SUBSTR(S_INPUT_STRING, INSTR(S_INPUT_STRING, S_PATERN), DECODE(INSTR(S_INPUT_STRING, '*'), 0, LENGTH(S_INPUT_STRING) + 1, INSTR(S_INPUT_STRING, '*')) - 1), S_PATERN, '')
      INTO   S_OUPUT_STRING
      FROM DUAL;

      SELECT REPLACE(S_INPUT_STRING, S_PATERN || S_OUPUT_STRING)
      INTO   S_INPUT_STRING
      FROM   DUAL;

      IF INSTR(S_INPUT_STRING, '*') = 1 THEN
        SELECT SUBSTR(S_INPUT_STRING, 2, LENGTH(S_INPUT_STRING))
        INTO   S_INPUT_STRING
        FROM DUAL;
      END IF;
    END IF;

    RETURN S_OUPUT_STRING;
  END EXTRACT_STRING;

  PROCEDURE DECODE_RFID_MEMORY(S_USER_MEMORY VARCHAR2, S_MANUFACTURER OUT NOCOPY VARCHAR2, S_SN OUT NOCOPY VARCHAR2, S_PN OUT NOCOPY VARCHAR2, S_BATCH OUT NOCOPY VARCHAR2)
  AS
    S_TEMP VARCHAR2(100) := S_USER_MEMORY;
  BEGIN
    S_MANUFACTURER := EXTRACT_STRING(S_TEMP, 'MFR ');
    S_SN := EXTRACT_STRING(S_TEMP, 'SER ');
    S_PN := EXTRACT_STRING(S_TEMP, 'PNR ');
    S_BATCH := EXTRACT_STRING(S_TEMP, 'BATCH ');
  END DECODE_RFID_MEMORY;

  PROCEDURE GET_PN_INVENTORY_DETAILS(P_BATCH IN PN_INVENTORY_DETAIL.BATCH%TYPE,
                                     R_INVENTORY_DET OUT PN_INVENTORY_DETAIL%ROWTYPE)
  AS
  BEGIN
    OPEN CUR_INVENTORY_TRANS(P_BATCH);
    FETCH CUR_INVENTORY_TRANS
      INTO R_INVENTORY_DET."BATCH",
           R_INVENTORY_DET."GOODS_RCVD_BATCH",
           R_INVENTORY_DET."VENDOR_LOT",
           R_INVENTORY_DET."PN",
           R_INVENTORY_DET."SN",
           R_INVENTORY_DET."NHA_PN",
           R_INVENTORY_DET."NHA_SN",
           R_INVENTORY_DET."CONDITION",
           R_INVENTORY_DET."OWNER",
           R_INVENTORY_DET."UNIT_COST",
           R_INVENTORY_DET."CURRENCY",
           R_INVENTORY_DET."APPROVED_CERTIFICATE",
           R_INVENTORY_DET."RI_BY",
           R_INVENTORY_DET."RI_DATE",
           R_INVENTORY_DET."INSTALLED_AC",
           R_INVENTORY_DET."INSTALLED_POSITION",
           R_INVENTORY_DET."INSTALLED_DATE",
           R_INVENTORY_DET."INSTALLED_HOUR",
           R_INVENTORY_DET."INSTALLED_MINUTE",
           R_INVENTORY_DET."LOCATION",
           R_INVENTORY_DET."BIN",
           R_INVENTORY_DET."QTY_AVAILABLE",
           R_INVENTORY_DET."QTY_RESERVED",
           R_INVENTORY_DET."QTY_IN_TRANSFER",
           R_INVENTORY_DET."QTY_PENDING_RI",
           R_INVENTORY_DET."QTY_US",
           R_INVENTORY_DET."QTY_IN_REPAIR",
           R_INVENTORY_DET."RI_CONTROL",
           R_INVENTORY_DET."US_CODE",
           R_INVENTORY_DET."SHELF_LIFE_EXPIRATION",
           R_INVENTORY_DET."TOOL_LIFE_EXPIRATION",
           R_INVENTORY_DET."LOAN_CATEGORY",
           R_INVENTORY_DET."CUTOM_DUTY_CODE",
           R_INVENTORY_DET."GL_COMPANY",
           R_INVENTORY_DET."GL_EXPENDITURE",
           R_INVENTORY_DET."GL",
           R_INVENTORY_DET."GL_COST_CENTER",
           R_INVENTORY_DET."NOTES",
           R_INVENTORY_DET."CREATED_BY",
           R_INVENTORY_DET."CREATED_DATE",
           R_INVENTORY_DET."MODIFIED_BY",
           R_INVENTORY_DET."MODIFIED_DATE",
           R_INVENTORY_DET."PHYSICAL_COUNT_DATE",
           R_INVENTORY_DET."KIT_NO",
           R_INVENTORY_DET."CURRENCY_EXCHANGE_RATE",
           R_INVENTORY_DET."QTY_IN_RENTAL",
           R_INVENTORY_DET."SECONDARY_COST",
           R_INVENTORY_DET."SECONDARY_CURRENCY_EXCHANGE",
           R_INVENTORY_DET."BLOB_NO",
           R_INVENTORY_DET."ORIGINAL_AC",
           R_INVENTORY_DET."MOD_STATUS",
           R_INVENTORY_DET."CUSTOM_DUTY_DOCUMENT",
           R_INVENTORY_DET."PENDING",
           R_INVENTORY_DET."PENDING_DATE",
           R_INVENTORY_DET."APPROVED_CERTIFICATE_ORIGINAL",
           R_INVENTORY_DET."SOS_DATE",
           R_INVENTORY_DET."SOS_HOUR",
           R_INVENTORY_DET."SOS_MINUTE",
           R_INVENTORY_DET."TAG_BY",
           R_INVENTORY_DET."TAG_DATE",
           R_INVENTORY_DET."TAG_NO",
           R_INVENTORY_DET."ORIGINAL_RECORDS_BY",
           R_INVENTORY_DET."ORGINAL_RECORDS_DATE",
           R_INVENTORY_DET."ACCOUNTING_DOCUMENT",
           R_INVENTORY_DET."ACCOUNTING_DOCUMENT_DATE",
           R_INVENTORY_DET."PN_MODEL",
           R_INVENTORY_DET."PN_SOFTWARE",
           R_INVENTORY_DET."FILING_SEQUENCE",
           R_INVENTORY_DET."NO_OF_TAG_PRINT",
           R_INVENTORY_DET."OWNER_ORIGIN",
           R_INVENTORY_DET."INVENTORY_TYPE",
           R_INVENTORY_DET."ADJUSTMENT_CODE",
           R_INVENTORY_DET."EXTERNAL_REFERENCE",
           R_INVENTORY_DET."EXTERNAL_POSITION";
    IF CUR_INVENTORY_TRANS%NOTFOUND THEN
      CLOSE CUR_INVENTORY_TRANS;
      RAISE_APPLICATION_ERROR(-20111, 'Invalid batch number: ' || P_BATCH, TRUE);
    END IF;
    CLOSE CUR_INVENTORY_TRANS;
  END GET_PN_INVENTORY_DETAILS;

  PROCEDURE SAVE_BIN_TRANSFER(P_BATCH IN PN_INVENTORY_DETAIL.BATCH%TYPE,
                              P_BIN IN PN_INVENTORY_DETAIL.BIN%TYPE,
                              P_TRANSACTION IN NUMBER,
                              P_QUANTITY IN PN_INVENTORY_HISTORY.QTY%TYPE)
  AS
    S_USER SECURITY_HEADER.USER%TYPE := 'TRAXIFACE';
    N_QUANTITY_TOTAL NUMBER;
    N_BATCH PN_INVENTORY_DETAIL.BATCH%TYPE;
    R_INVENTORY_DET PN_INVENTORY_DETAIL%ROWTYPE;
    R_NEW_INVENTORY_DETAIL PN_INVENTORY_DETAIL%ROWTYPE;
    D_CURRENT_DATE DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    R_PN_INVENTORY_HIST PN_INVENTORY_HISTORY%ROWTYPE;
    N_BIN_HIS PN_INVENTORY_DETAIL.BIN%TYPE;
  BEGIN
    IF NVL(P_QUANTITY,0) <= 0 THEN
      RAISE_APPLICATION_ERROR(-20111, 'QTY not valid. It has to be greater than 0 ', TRUE);
    END IF;

    GET_PN_INVENTORY_DETAILS(P_BATCH, R_INVENTORY_DET);

    N_BIN_HIS := R_INVENTORY_DET.BIN;
    N_QUANTITY_TOTAL := NVL(R_INVENTORY_DET.QTY_AVAILABLE,0) + NVL(R_INVENTORY_DET.QTY_PENDING_RI,0) + NVL(R_INVENTORY_DET.QTY_US,0);

    IF N_QUANTITY_TOTAL <= 0 THEN
      RAISE_APPLICATION_ERROR(-20111, 'Transaction not allowed for Batch.', TRUE);
    END IF;

    IF P_QUANTITY = N_QUANTITY_TOTAL THEN
      
      R_INVENTORY_DET.BIN := P_BIN;
      N_BATCH := P_BATCH;
    ELSIF P_QUANTITY < N_QUANTITY_TOTAL THEN
      
      GET_PN_INVENTORY_DETAILS(P_BATCH, R_NEW_INVENTORY_DETAIL);

      N_BATCH := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('BATCH');
      R_NEW_INVENTORY_DETAIL.BATCH := N_BATCH;
      R_NEW_INVENTORY_DETAIL.BIN := P_BIN;
      R_NEW_INVENTORY_DETAIL.QTY_RESERVED := 0;
      R_NEW_INVENTORY_DETAIL.QTY_IN_TRANSFER := 0;
      R_NEW_INVENTORY_DETAIL.QTY_IN_REPAIR := 0;
      IF NVL(R_INVENTORY_DET.QTY_AVAILABLE, 0) > 0 THEN
        R_NEW_INVENTORY_DETAIL.QTY_AVAILABLE := P_QUANTITY;
        R_INVENTORY_DET.QTY_AVAILABLE := R_INVENTORY_DET.QTY_AVAILABLE - P_QUANTITY;
      END IF;
      IF NVL(R_INVENTORY_DET.QTY_PENDING_RI, 0) > 0 THEN
        R_NEW_INVENTORY_DETAIL.QTY_PENDING_RI := P_QUANTITY;
        R_INVENTORY_DET.QTY_PENDING_RI := R_INVENTORY_DET.QTY_PENDING_RI - P_QUANTITY;
      END IF;
      IF NVL(R_INVENTORY_DET.QTY_US, 0) > 0 THEN
        R_NEW_INVENTORY_DETAIL.QTY_US := P_QUANTITY;
        R_INVENTORY_DET.QTY_US := R_INVENTORY_DET.QTY_US - P_QUANTITY;
      END IF;

      R_NEW_INVENTORY_DETAIL.MODIFIED_DATE := D_CURRENT_DATE;
      R_NEW_INVENTORY_DETAIL.MODIFIED_BY := S_USER;

      INSERT INTO PN_INVENTORY_DETAIL VALUES R_NEW_INVENTORY_DETAIL;
    ELSE
      RAISE_APPLICATION_ERROR(-20111, 'QTY Greater than in Batch. ' || P_BATCH, TRUE);
    END IF;

    R_INVENTORY_DET.MODIFIED_DATE := D_CURRENT_DATE;
    R_INVENTORY_DET.MODIFIED_BY := S_USER;
    UPDATE PN_INVENTORY_DETAIL
    SET ROW = R_INVENTORY_DET
    WHERE BATCH = R_INVENTORY_DET.BATCH;

    R_PN_INVENTORY_HIST.TRANSACTION_NO := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('PNINVHIS');
    R_PN_INVENTORY_HIST.TRANSACTION_TYPE := 'BIN/TRANSFER';
    R_PN_INVENTORY_HIST.BATCH := N_BATCH;
    R_PN_INVENTORY_HIST.GOODS_RCVD_BATCH := R_INVENTORY_DET.GOODS_RCVD_BATCH;
    R_PN_INVENTORY_HIST.PN := R_INVENTORY_DET.PN;
    R_PN_INVENTORY_HIST.SN := R_INVENTORY_DET.SN;
    R_PN_INVENTORY_HIST.QTY := P_QUANTITY;

    R_PN_INVENTORY_HIST.CREATED_BY := S_USER;
    R_PN_INVENTORY_HIST.CREATED_DATE := D_CURRENT_DATE;
    R_PN_INVENTORY_HIST.MODIFIED_BY := S_USER;
    R_PN_INVENTORY_HIST.MODIFIED_DATE := D_CURRENT_DATE;
    R_PN_INVENTORY_HIST.LOCATION := R_INVENTORY_DET.LOCATION;
    R_PN_INVENTORY_HIST.BIN := N_BIN_HIS;
    R_PN_INVENTORY_HIST.CONDITION := R_INVENTORY_DET.CONDITION;
    R_PN_INVENTORY_HIST.TO_BIN := P_BIN;

    INSERT INTO PN_INVENTORY_HISTORY VALUES R_PN_INVENTORY_HIST;

    PKG_FUNCTION_INVENTORY.PN_INVENTORY_HISTORY_NLA_LOAD(R_PN_INVENTORY_HIST.TRANSACTION_NO, S_USER);

    UPDATE "RFID_SCANNER_INPUT"
    SET  "RFID_SCANNER_INPUT"."STATUS" = 'CLOSED'
    WHERE  "RFID_SCANNER_INPUT"."TRANSACTION_NUMBER" = P_TRANSACTION;

  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR(-20111, 'Error occurred in save_bin_transfer procedure for Batch ' || P_BATCH
        || ', Bin ' || P_BIN || ', Transaction ' || P_TRANSACTION || ', Quantity ' || P_QUANTITY || ': ' || SQLERRM, TRUE);

  END SAVE_BIN_TRANSFER;
  
  FUNCTION GET_BATCH_STATUS(N_BATCH NUMBER) RETURN XMLTYPE
  AS
    XML_TEMP XMLTYPE;
    XML_BATCH_STATUS XMLTYPE;
  BEGIN
  

    SELECT XMLELEMENT("available", QTY_AVAILABLE)
    INTO XML_TEMP
    FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;
    
    IF XML_TEMP IS NOT NULL THEN
      XML_BATCH_STATUS := XML_TEMP;
    END IF;
    

    SELECT XMLELEMENT("reserved", QTY_RESERVED )
    INTO XML_TEMP
    FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;
    
    IF XML_TEMP IS NOT NULL THEN
      IF XML_BATCH_STATUS IS NULL THEN
        XML_BATCH_STATUS := XML_TEMP;
      ELSE
        SELECT XMLCONCAT(XML_BATCH_STATUS, XML_TEMP)
        INTO XML_BATCH_STATUS
        FROM DUAL;
      END IF;
     END IF;
    

    SELECT XMLELEMENT("in_transfer", QTY_IN_TRANSFER)
    INTO XML_TEMP
    FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;
    
    IF XML_TEMP IS NOT NULL THEN
      IF XML_BATCH_STATUS IS NULL THEN
        XML_BATCH_STATUS := XML_TEMP;
      ELSE
        SELECT XMLCONCAT(XML_BATCH_STATUS, XML_TEMP)
        INTO XML_BATCH_STATUS
        FROM DUAL;
      END IF;
    END IF;


    SELECT XMLELEMENT("pending_ri", QTY_PENDING_RI)
    INTO XML_TEMP
    FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;
    
    IF XML_TEMP IS NOT NULL THEN
      IF XML_BATCH_STATUS IS NULL THEN
        XML_BATCH_STATUS := XML_TEMP;
      ELSE
        SELECT XMLCONCAT(XML_BATCH_STATUS, XML_TEMP)
        INTO XML_BATCH_STATUS
        FROM DUAL;
      END IF;
    END IF;


    SELECT XMLELEMENT("us", QTY_US)
    INTO XML_TEMP
    FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;
    
    IF XML_TEMP IS NOT NULL THEN
      IF XML_BATCH_STATUS IS NULL THEN
        XML_BATCH_STATUS := XML_TEMP;
      ELSE
        SELECT XMLCONCAT(XML_BATCH_STATUS, XML_TEMP)
        INTO XML_BATCH_STATUS
        FROM DUAL;
      END IF;
    END IF;


    SELECT XMLELEMENT("in_repair", QTY_IN_REPAIR)
    INTO XML_TEMP
    FROM PN_INVENTORY_DETAIL
    WHERE BATCH = N_BATCH;
    
    IF XML_TEMP IS NOT NULL THEN
      IF XML_BATCH_STATUS IS NULL THEN
        XML_BATCH_STATUS := XML_TEMP;
      ELSE
        SELECT XMLCONCAT(XML_BATCH_STATUS, XML_TEMP)
        INTO XML_BATCH_STATUS
        FROM DUAL;
      END IF;
    END IF;
   

    SELECT XMLELEMENT("issued", SUM (QTY))
    INTO XML_TEMP
    FROM PN_INVENTORY_HISTORY
    WHERE BATCH = N_BATCH
    GROUP BY BATCH;
    
    IF XML_TEMP IS NOT NULL THEN
      IF XML_BATCH_STATUS IS NULL THEN
        XML_BATCH_STATUS := XML_TEMP;
      ELSE
        SELECT XMLCONCAT(XML_BATCH_STATUS, XML_TEMP)
        INTO XML_BATCH_STATUS
        FROM DUAL;
      END IF;
    END IF;
   
    
    
    IF XML_BATCH_STATUS IS NOT NULL THEN
      SELECT XMLELEMENT("GetBatchStatusResponseReturn", XML_BATCH_STATUS)
      INTO XML_BATCH_STATUS
      FROM DUAL;
    END IF;
    
    DBMS_OUTPUT.PUT_LINE(XML_BATCH_STATUS.GETCLOBVAL);
    
    RETURN XML_BATCH_STATUS;
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(20001, 'Batch: ' || N_BATCH || ' no valid', TRUE);
  END GET_BATCH_STATUS;

END PKG_IFACE_RFID;

/ 

create or replace
PACKAGE PKG_IFACE_PICKLIST AS
  
  type refCursor is ref cursor;
  type st_dw_sel is record (
    n_wo                  "WO_TASK_CARD_PN"."WO"%type,
    s_task_card           "WO_TASK_CARD_PN"."TASK_CARD"%type,
    s_pn                  "WO_TASK_CARD_PN"."PN"%type,
    n_qty                 "WO_TASK_CARD_PN"."QTY"%type,
    n_qty_reserved        "WO_TASK_CARD_PN"."QTY_RESERVED"%type,
    s_modified_by         "WO_TASK_CARD_PN"."MODIFIED_BY"%type,
    dt_modified_date      "WO_TASK_CARD_PN"."MODIFIED_DATE"%type,
    s_reserve             "WO_TASK_CARD_PN"."RESERVE"%type,
    s_task_card_pn        "WO_TASK_CARD_PN"."TASK_CARD_PN"%type,
    s_task_card_pn_sn     "WO_TASK_CARD_PN"."TASK_CARD_PN_SN"%type,
    s_ac                  "WO_TASK_CARD_PN"."AC"%type,
    s_picklist_processed  "WO_TASK_CARD_PN"."PICKLIST_PROCESSED"%type);
    
    P_USER "PICKLIST_DISTRIBUTION"."CREATED_BY"%TYPE;
    
   type st_dw_sel_defect is record (
  --  n_wo                  "WO"."WO"%type,
    s_defect           "DEFECT_REPORT_PN"."DEFECT"%type,
    s_defect_type      "DEFECT_REPORT_PN"."DEFECT_TYPE"%type,
    l_defect_item         number(8) ,
    s_pn                  "DEFECT_REPORT_PN"."PN"%type,
    n_qty                 "DEFECT_REPORT_PN"."QTY"%type,   
    s_modified_by         "DEFECT_REPORT_PN"."MODIFIED_BY"%type,
    dt_modified_date      "DEFECT_REPORT_PN"."MODIFIED_DATE"%type,
    s_reserve             "DEFECT_REPORT_PN"."RESERVED"%type   ,
    n_wo                  "WO_TASK_CARD_PN"."WO"%type,
    s_ac                  "WO_TASK_CARD_PN"."AC"%type , 
    s_picklist_processed  "DEFECT_REPORT_PN"."PICKLIST_PROCESSED"%type,
    n_qty_reserved        "DEFECT_REPORT_PN"."QTY_RESERVED"%type
   ); 
    
    

  type st_dw_sel_cancellation is record (
    n_wo          "PICKLIST_HEADER"."WO"%type,
    s_task_card   "PICKLIST_HEADER"."TASK_CARD"%type,
    n_line        "PICKLIST_DISTRIBUTION"."PICKLIST_LINE"%type,
    s_transaction "PICKLIST_DISTRIBUTION"."TRANSACTION"%type,
    n_picklist    "PICKLIST_HEADER"."PICKLIST"%type,
    s_pn          "PICKLIST_DISTRIBUTION"."PN"%type,
    n_qty         "PICKLIST_DISTRIBUTION"."QTY"%type,
    s_so          "PICKLIST_HEADER"."SO"%type,
    n_order_line  "PICKLIST_DISTRIBUTION"."ORDER_LINE"%type,
    s_created_by  "PICKLIST_HEADER"."CREATED_BY"%type,
    s_task_card2  "PICKLIST_DISTRIBUTION"."TASK_CARD"%type,   
    s_status      "PICKLIST_HEADER"."STATUS"%type );
    
  -- This collection holds info for wo_task_card_pn entries
  type wo_tc_pn_array is table of st_dw_sel index by PLS_INTEGER;
  type defect_pn_array is table of st_dw_sel_defect index by PLS_INTEGER; 
  
  type dw_sel_cancel_array is table of st_dw_sel_cancellation index by PLS_INTEGER;
  
  procedure picklist_reservation(n_wo wo.wo%type, s_picklist_priority wo.priority%type default null);
  procedure load_pn(n_wo wo.wo%type, s_task_card wo_task_card.task_card%type, v_tc_pn_array in out wo_tc_pn_array);
  function load_pn(n_wo wo.wo%type, s_task_card wo_task_card.task_card%type) return number;
  procedure picklist_group_by_location(ms_pn in out pkg_type_structures.st_pn);                                 
 procedure load_requisition(--n_requisition number,
                             s_pn pn_master.pn%type,
                             is_priority system_tran_code.system_code%type,
                             is_requisition_type requisition_header.requistion_type%type,
                             is_location pn_inventory_level.location%type,
                             is_ac requisition_header.ac%type,
                             in_wo requisition_header.wo%type,
                             is_taskcard requisition_header.task_card%type,
                             is_ec requisition_header.eo%type,
                             is_company requisition_header.order_category%type,
                             is_taskcard_pn requisition_header.task_card_pn%type,
                             is_task_pn_sn requisition_header.task_card_sn%type,                            
                             is_site requisition_header.site%type,
                             n_qty number);
--  procedure load_requisition;
  procedure wf_picklist_distribution( ms_pn in out nocopy pkg_type_structures.st_pn );
  procedure new_picklist_header(n_picklist  picklist_header.picklist%type,
                                s_location  picklist_header.location%type,
                                n_wo        picklist_header.wo%type,
                                s_task_card picklist_header.task_card%type,
                                dt_require_on picklist_header.require_on%type,
                                n_require_hour number,
                                n_require_minute number,
                                s_delivery_location picklist_header.delivery_location%type,
                                s_priority    picklist_header.priority%type,
                                s_site        picklist_header.site%type,
                                s_task_card_pn picklist_header.task_card_pn%type,
                                s_task_card_pn_sn picklist_header.task_card_sn%type,
                                s_defect picklist_header.defect%type,
                                s_defect_type picklist_header.defect_type%type,
                                l_defect_item picklist_header.defect_item%type,
                                
                                s_ac picklist_header.ac%type,
                                s_user picklist_header.modified_by%type);
  
  function wf_edit(s_tpw wo.third_party_wo%type, s_ac wo.ac%type,
                   n_wo wo.wo%type, s_location wo.location%type,
                   n_picklist picklist_header.picklist%type, 
                   n_line picklist_distribution.picklist_line%type,
                   n_qty_in number,
                   s_pn_in pn_master.pn%type) return number;

  function managed_parts_picklist(ms_pn pkg_type_structures.st_pn, s_query varchar2) return boolean;
   
  procedure picklist_cancellation(n_wo wo.wo%type);
  procedure cancel_requisition(n_wo wo.wo%type, s_task_card varchar2);
  procedure CANCEL_REQUISITION_BY_DEFECT(s_defect VARCHAR2, s_defect_type VARCHAR2, l_defect_item Number);
  procedure load_pn_cancellation(n_wo wo.wo%type, s_task_card wo_task_card.task_card%type, v_tc_pn_array in out dw_sel_cancel_array);
  
  PROCEDURE WF_REQUISITION_CANCELATION(n_wo number, s_task_card varchar2 default null);
  
  PROCEDURE WF_PICKLIST_RESERVATION_CANCEL(n_wo number, s_task_card in out nocopy varchar2, gs_user in out nocopy varchar2);
  
  PROCEDURE WF_PICKLIST_RESERVATION(N_WO NUMBER, S_AC VARCHAR2, MS_LOCATION_SITE in out PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                    Ms_Location_Site_Req In Out Pkg_Type_Structures.St_Location_Site, 
                                    S_Task_Card Varchar2 Default Null, S_Task_Card_pn Varchar2 Default Null, S_Task_Card_sn Varchar2 Default Null,
                                    s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0,                                    
                                    Gs_Company_Multi In Out Nocopy Varchar2,
                                    GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER);
 
  
  PROCEDURE WF_RE_RESERVE_PART_AND_LABOR(N_WO NUMBER, S_PICKLIST_PRIORITY VARCHAR2, S_REQUISITION_TYPE VARCHAR2, S_TASK_CARD IN OUT NOCOPY VARCHAR2,
                                         GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER);
                                         
  procedure sendPicklistToPrintQueue(l_picklist number) ;     
  function eMobility_Picklist(s_type VARCHAR2, n_id number, N_WO NUMBER, S_AC VARCHAR2, S_TASK_CARD VARCHAR2 DEFAULT NULL,S_TASK_CARD_PN VARCHAR2 DEFAULT NULL , S_TASK_CARD_SN VARCHAR2 DEFAULT NULL , 
                                       s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0, 
                                       S_LOCATION Varchar2, S_DELIVERY_LOCATION Varchar2, S_SITE Varchar2, S_PICKLIST_PRIORITY Varchar2, S_REQUISITION_TYPE Varchar2,
                                       DT_REQUIRE_DATE date, L_REQUIRE_HOUR NUMBER, L_REQUIRE_minute NUMBER,
                                       GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER) return VARCHAR2;
                                       
  PROCEDURE PICKLIST_CANCEL_Defect(defect VARCHAR2, defect_type VARCHAR2, defect_item Number);
  procedure RESERV_CANCEL_SUB_DEFECT_LOOP(defect VARCHAR2, defect_type VARCHAR2, defect_item Number);
  FUNCTION LOAD_PN_for_cancel_defect(defect VARCHAR2, defect_type VARCHAR2, defect_item Number) RETURN DW_SEL_CANCEL_ARRAY;  
  function addPartToemobilityQueue(s_pn pn_master.pn%type , l_batch number , s_sn pn_inventory_detail.sn%type 
, l_qty pn_inventory_detail.qty_available%type)return number ; 

procedure addWoTaskPn(s_ac varchar2 , l_wo number , s_task varchar2, s_tc_pn varchar2 , s_tc_sn varchar2 , 
s_pn varchar2 ,  l_qty number , s_user varchar2 , s_reservation_type varchar2) ; 
  
end pkg_iface_picklist;


/

create or replace PACKAGE BODY "PKG_IFACE_PICKLIST" as
  g_stWO  pkg_type_structures.st_wo;
  g_dwSel st_dw_sel;


  g_sSite wo.site%type;
  g_sTPW          wo.third_party_wo%type;

  g_nQTY          wo_task_card_pn.qty%type;

  g_sTask_Card_PN wo_task_card_pn.task_card_pn%type;
  g_sTask_Card_SN wo_task_card_pn.task_card_pn_sn%type;
  g_sCompany      pn_master.gl_company%type;
  g_nRequisition  system_tran_config.config_number%type;
  g_sWOPick1      system_tran_config.config_flag%type;
  g_sBOcrt        system_tran_config.config_flag%type;
  g_sWOpursvrq    system_tran_config.config_flag%type;
  g_sWOpklnla     system_tran_config.config_flag%type;
  g_sPriorityReq  system_tran_code.system_code%type;
  g_sCompanyMultiReq    system_tran_config.config_flag%type;
  g_sRequisitionType    requisition_header.requistion_type%type;
  g_nRequire_hour_req   requisition_detail.require_hour%type;
  g_nRequire_minute_req requisition_detail.require_minute%type;

  g_dtRequire_Date_Req date;
  g_dtSchedule_Start_Date date;

  g_sAC             wo.ac%type;
  g_nWO             wo.wo%type;
  g_sTask_Card      wo_task_card_pn.task_card%type;
  g_sLocation       wo.location%type;
  g_sPN             wo_task_card_pn.pn%type;
  g_sEC             wo_task_card.eo%type;
  g_nInvDetIterated number;
  g_nInvDetRowCount number;
  g_type VARCHAR2(2);
  g_rNumber REQUISITION_HEADER.REQUISITION%TYPE;


  procedure new_picklist_header(n_picklist  picklist_header.picklist%type,
                                s_location  picklist_header.location%type,
                                n_wo        picklist_header.wo%type,
                                s_task_card picklist_header.task_card%type,
                                dt_require_on picklist_header.require_on%type,
                                n_require_hour number,
                                n_require_minute number,
                                s_delivery_location picklist_header.delivery_location%type,
                                s_priority    picklist_header.priority%type,
                                s_site        picklist_header.site%type,
                                s_task_card_pn picklist_header.task_card_pn%type,
                                s_task_card_pn_sn picklist_header.task_card_sn%type,
                                s_defect picklist_header.defect%type,
                                s_defect_type picklist_header.defect_type%type,
                                l_defect_item  picklist_header.defect_item%type,                                
                                s_ac picklist_header.ac%type,
                                s_user picklist_header.modified_by%type)
  as
    s_inventory_type  picklist_header.inventory_type%type;
    --s_user picklist_header.created_by%type;
    dt_today  date;
    t_stc_BYPASROU "SYSTEM_TRAN_CONFIG"%ROWTYPE;
    s_bypass_routing picklist_header.bypass_routing%type;
  begin
    --n_picklist := pkg_application_function.config_number('PICKLIST');
    --s_user := pkg_trax_session.f_getuser;
    dt_today := pkg_application_function.currentdatetime;
    t_stc_BYPASROU := "PKG_SYSTEM_ADMIN"."GET_SYSTEM_TRAN_CONFIG_RECORD"('BYPASROU');

    begin
      select module
      into s_inventory_type
      from wo
      where wo = n_wo;
    exception when others then 
      s_inventory_type := 'MAINTENANCE';
    end;
    if s_inventory_type <> 'GSE' then
      s_inventory_type := 'MAINTENANCE';
    end if;

    if t_stc_BYPASROU."CONFIG_FLAG" = 'Y' Then
      s_bypass_routing := 'Y';
    else
      s_bypass_routing := 'N';
    end if;

    insert into picklist_header
        (picklist,
         location,
         wo,
         task_card,
         require_on,
         require_hour,
         require_minute,
         created_by,
         created_date,
         modified_by,
         modified_date,
         status,
         delivery_location,
         priority,
         site,
         inventory_type,
         ac,
         bypass_routing,
         task_card_pn,
         task_card_sn ,
         defect ,  defect_type , defect_item
         )
    values ( n_picklist,
             s_location,
             n_wo,
             s_task_card,
             dt_require_on,
             n_require_hour,
             n_require_minute,
             s_user,
             dt_today,
             s_user,
             dt_today,
             'OPEN',
             s_delivery_location,
             s_priority,
             s_site,
             s_inventory_type,
             s_ac,
             s_bypass_routing,
             S_TASK_CARD_PN,
             s_task_card_pn_sn, 
             s_defect , s_defect_type , l_defect_item
             );

  end new_picklist_header;

  procedure picklist_reservation(n_wo wo.wo%type, s_picklist_priority wo.priority%type default null)
  as
    s_new                   varchar2(3 char);
    n_return                number;
    s_location              wo.location%type;
    s_ac                    wo.ac%type;
    dt_schedule_start_date  wo.schedule_start_date%type;
    s_tpw                   wo.third_party_wo%type;
    s_priority              wo.priority%type;
    s_site                  wo.site%type;

    s_task_card1             wo_task_card_pn.task_card%type;
    s_task_card2             wo_task_card_pn.task_card%type;

    v_tc_pn_array           wo_tc_pn_array;



    --s_ec                    wo_task_card.eo%type;
    s_pn                    wo_task_card_pn.pn%type;
    sv_task_card            wo_task_card_pn.task_card%type;
    --s_task_card             wo_task_card_pn.task_card%type;
    s_task_card_pn          wo_task_card_pn.task_card_pn%type;
    s_task_card_sn          wo_task_card_pn.task_card_pn_sn%type;
    n_qty                   wo_task_card_pn.qty%type;
    n_qty_reserved          wo_task_card_pn.qty_reserved%type;
    n_requisition           requisition_detail.qty_require%type;
    n_requisition_order     requisition_detail.qty_require%type;
    n_line                  picklist_distribution.picklist_line%type;
    n_picklist              picklist_distribution.picklist%type;
    n_distribution_line     picklist_distribution.distribution_line%type;

    s_pn_description        pn_master.pn_description%type;
    ms_pn                   pkg_type_structures.st_pn;
    gs_user varchar2(100);
  begin
    g_nWO := n_wo;

    -- All we have to start with is the W/O, right?
    -- So lets start off by getting some more useful info
    begin
      select location, ac, schedule_start_date,
             third_party_wo, priority, site, modified_by
      into g_sLocation, g_sAC, dt_schedule_start_date,
           s_tpw, s_priority, s_site, gs_user
      from wo
      where wo = n_wo;
       exception
        when NO_DATA_FOUND then
          dbms_output.put_line('ms_pn.s_owner: No Data Found');
    end;

    if s_picklist_priority is not null then
      s_priority := s_picklist_priority;
    end if;

    g_sSite := s_site;

    begin
      select rm.employee_contractor
      into ms_pn.s_owner
      from customer_order_header coh, relation_master rm
      where (coh.customer = rm.relation_code) and
            ((coh.order_type = 'W/O') and
             (coh.order_number = n_wo));
    exception
      when NO_DATA_FOUND then
        dbms_output.put_line('ms_pn.s_owner: No Data Found');
    end;

    if ((sqlcode = 100) or (ms_pn.s_owner < '0')) then 
      ms_pn.s_owner := null;
    end if;

    load_pn(n_wo, '', v_tc_pn_array);
    sv_task_card := '';

    begin
      for VELEMENT_eval in V_TC_PN_ARRAY.first..V_TC_PN_ARRAY.last
      LOOP
        null;
      end LOOP;
    exception
    when OTHERS then
      return;
    end;

    for vElement in v_tc_pn_array.first..v_tc_pn_array.last
    loop
      if (v_tc_pn_array.exists(vElement)) then
        g_sTask_Card := v_tc_pn_array(vElement).s_task_card;
        s_task_card_pn := v_tc_pn_array(vElement).s_task_card_pn;
        s_task_card_sn := v_tc_pn_array(vElement).s_task_card_pn_sn;
        s_ac := v_tc_pn_array(vElement).s_ac;

        select eo
        into g_sEC
        from wo_task_card
        where (wo = n_wo) and
              (task_card = g_sTask_Card) and
              (ac = s_ac) and
              (pn = s_task_card_pn) and
              (pn_sn = s_task_card_sn);

        if (sqlcode = 100) then g_sEC := null; end if;

        s_task_card1 := nvl(g_sTask_Card, ' ');
        s_task_card2 := nvl(sv_task_card, ' ');
        if (s_task_card1 <> s_task_card2) then
          s_new := 'NEW';
          sv_task_card := g_sTask_Card;
        end if;

        s_pn := v_tc_pn_array(vElement).s_pn;
        g_sPN := s_pn;
        n_qty := v_tc_pn_array(vElement).n_qty;
        n_qty_reserved := v_tc_pn_array(vElement).n_qty_reserved;

        if (n_qty_reserved is null) then n_qty_reserved := 0; end if;

        -- Load Requested Item
        n_requisition := 0;
        select sum(rd.qty_require)
        into n_requisition
        from requisition_header rh, requisition_detail rd
        where (rd.requisition = rh.requisition) and
              ((rh.wo = n_wo) and
               (rh.task_card = g_sTask_Card) and
               (rd.pn = s_pn) and
               (rd.status = 'OPEN'));

        if (n_requisition is null) then n_requisition := 0; end if;

        n_requisition_order := 0;
        select sum(rd.qty_require)
        into n_requisition_order
        from requisition_header rh, requisition_detail rd
        where (rd.requisition = rh.requisition) and
              ((rh.wo = n_wo) and
               (rh.task_card = g_sTask_Card) and
               (rd.pn = s_pn) and
               (rd.status = 'ORDER'));

        if (n_requisition_order is null) then n_requisition_order := 0; end if;
        n_qty := n_qty - (n_qty_reserved + n_requisition + n_requisition_order);

        if (n_qty > 0) then
          -- Load new picklist detail line
          select max(picklist)
          into n_line
          from picklist_distribution
          where (transaction = 'REQUIRE') and
                (picklist = n_picklist);

          n_line := 0;
          if (n_line is null) then
            n_line := 1;
          else
            n_line := n_line + 1;
          end if;

          -- Edit for Effectivity
          n_return := wf_edit(s_tpw, s_ac, n_wo, g_sLocation, n_picklist, n_line, n_qty, s_pn);

          select pnm.pn_description
          into s_pn_description
          from pn_master pnm, pn_interchangeable pni
          where (pni.pn = pnm.pn) and
                (pni.pn_interchangeable = s_pn);

          if (n_return > 0) then
            -- load new picklist header for task card
            if (s_new = 'NEW') then

              -- Load Multi Location
              if (n_picklist > 0) then
                declare
                  ms_pn_p pkg_type_structures.st_pn;
                begin
                  ms_pn_p.n_picklist := n_picklist;
                  picklist_group_by_location(ms_pn_p);
                end;
              end if;

              n_picklist := pkg_application_function.config_number('PICKLIST');

              new_picklist_header(n_picklist, g_sLocation, n_wo, g_sTask_Card,
                                dt_schedule_start_date,
                                0,
                                0,
                                g_sLocation,
                                s_priority,
                                s_site,
                                s_task_card_pn,
                                s_task_card_sn,null , null , 0,
                                g_sAC,
                                gs_user);

              --new_picklist_header(n_picklist, s_location, n_wo, g_sTask_Card,
              --    dt_schedule_start_date, '', s_priority, s_site);
              s_new := ' ';
            end if;

            begin
              SELECT "PICKLIST_DISTRIBUTION"."QTY"
              INTO n_qty
              FROM "PICKLIST_DISTRIBUTION"
              WHERE ( "PICKLIST_DISTRIBUTION"."TRANSACTION" = 'REQUIRE' ) AND
                 ( "PICKLIST_DISTRIBUTION"."PICKLIST" = n_picklist ) AND
                 ( "PICKLIST_DISTRIBUTION"."PICKLIST_LINE" = n_line );
            exception
              when NO_DATA_FOUND then
                dbms_output.put_line('n_picklist: No Data Found');
            end;

            n_qty_reserved := n_qty_reserved + n_qty;
            ms_pn.s_location := s_location;
            ms_pn.n_picklist := n_picklist;
            ms_pn.s_pn := s_pn;
            ms_pn.s_ac := g_sAC;
            ms_pn.n_picklist_line := n_line;
            ms_pn.n_qty := n_qty;

            wf_picklist_distribution(ms_pn);
            commit;

          end if;
        end if;
      end if;
    end loop;

  end picklist_reservation;

  procedure picklist_group_by_location(ms_pn in out pkg_type_structures.st_pn) as
    s_location_save picklist_header.location%type;
    n_picklist_new  picklist_header.picklist%type;
    n_qty           picklist_distribution.qty%type;
    n_qty_require   picklist_distribution.qty%type;

    s_indicator varchar2(3 char);
  begin
    for dcl_pl in (select pni.location,
                          picklist.picklist_line,
                          picklist.distribution_line,
                          picklist.qty,
                          decode(pni.location, ms_pn.s_location, 1, 2) as SORT,
                          picklist.batch
                  from picklist_distribution picklist, pn_inventory_detail pni
                  where (picklist.batch = pni.batch) and
                        ((picklist.transaction = 'DISTRIBU') and
                         (picklist.picklist = ms_pn.n_picklist)) and
                        (nvl(picklist.status, 'OPEN') = 'OPEN')
                  order by SORT asc, pni.location asc)
    loop
      s_location_save := dcl_pl.location;

      ms_pn.n_index := 1;
      ms_pn.n_picklist_array(ms_pn.n_index) := ms_pn.n_picklist;

      if (nvl(s_location_save, '') <> nvl(dcl_pl.location, '')) then
        n_picklist_new := pkg_application_function.config_number('PICKLIST');

        ms_pn.n_index := ms_pn.n_index + 1;
        ms_pn.n_picklist_array(ms_pn.n_index) := n_picklist_new;

        insert into picklist_header
            ( picklist,
              location,
              wo,
              task_card,
              require_on,
              status,
              so,
              notes,
              created_by,
              created_date,
              modified_by,
              modified_date,
              build_kit,
              order_type,
              order_number,
              site,
              no_of_print,
              delivery_location,
              priority,
              ac,
              original_location,
              inventory_type,
              task_card_pn,
              task_card_sn,
              require_hour,
              require_minute)
        select n_picklist_new,
              dcl_pl.location,
              wo,
              task_card,
              require_on,
              status,
              so,
              notes,
              created_by,
              created_date,
              modified_by,
              modified_date,
              build_kit,
              order_type,
              order_number,
              site,
              no_of_print,
              delivery_location,
              priority,
              ac,
              ms_pn.s_location,
              inventory_type,
              task_card_pn,
              task_card_sn,
              require_hour,
              require_minute
        from picklist_header
        where picklist = ms_pn.n_picklist;

        commit;

        s_indicator := 'YES';
        s_location_save := dcl_pl.location;
      end if;

      if (s_indicator = 'YES') then
        select qty
        into n_qty
        from picklist_distribution
        where (transaction = 'REQUIRE') and
              (picklist = n_picklist_new) and
              (picklist_line = dcl_pl.picklist_line);

        if (sqlcode = 100) then
          insert into picklist_distribution
              (transaction,
               picklist,
               picklist_line,
               pn,
               qty,
               batch,
               condition,
               sn,
               distribution_line,
               qty_picked,
               notes,
               created_by,
               created_date,
               modified_by,
               modified_date,
               order_line,
               status,
               original_picklist,
               task_card)
          select transaction,
                n_picklist_new,
                picklist_line,
                pn,
                dcl_pl.qty,
                batch,
                condition,
                sn,
                distribution_line,
                qty_picked,
                notes,
                created_by,
                created_date,
                modified_by,
                modified_date,
                order_line,
                status,
                ms_pn.n_picklist,
                task_card
          from picklist_distribution
          where (transaction = 'REQUIRE') and
                (picklist = ms_pn.n_picklist) and
                (picklist_line = dcl_pl.picklist_line);
        else
          -- Update
          select qty
          into n_qty_require
          from picklist_distribution
          where (transaction = 'REQUIRE') and
                (picklist = n_picklist_new) and
                (picklist_line = dcl_pl.picklist_line);

          if (n_qty_require is null) or n_qty_require < 0 then n_qty_require := 0; end if;
          n_qty_require := n_qty_require + dcl_pl.qty;
          if (n_qty_require is null) or n_qty_require < 0 then n_qty_require := 0; end if;

          update picklist_distribution
          set qty = n_qty_require
          where (transaction = 'REQUIRE') and
                (picklist = n_picklist_new) and
                (picklist_line = dcl_pl.picklist_line);
        end if;

        -- Update Original picklist with requirement
        select qty
        into n_qty_require
        from picklist_distribution
        where (transaction = 'REQUIRE') and
              (picklist = ms_pn.n_picklist) and
              (picklist_line = dcl_pl.picklist_line);

        if (n_qty_require is null) or n_qty_require < 0 then n_qty_require := 0; end if;
        n_qty_require := n_qty_require - dcl_pl.qty;
        if (n_qty_require is null) or n_qty_require < 0 then n_qty_require := 0; end if;

        update picklist_distribution
        set qty = n_qty_require
        where (transaction = 'REQUIRE') and
              (picklist = ms_pn.n_picklist) and
              (picklist_line = dcl_pl.picklist_line);

        -- Create new picklist line
        update picklist_distribution
        set picklist = n_picklist_new
        where (picklist = ms_pn.n_picklist) and
              (picklist_line = dcl_pl.picklist_line) and
              (distribution_line = dcl_pl.distribution_line);

        update pn_inventory_history
        set order_no = n_picklist_new
        where (transaction_type = 'PICKLIST/CREATE') and
              (batch = dcl_pl.batch) and
              (order_type = 'PICKLST') and
              (order_no = ms_pn.n_picklist) and
              (order_line = dcl_pl.picklist_line);
      else
        if (dcl_pl.location is not null) and length(trim(dcl_pl.location)) > 0 then
          update picklist_header
          set location = dcl_pl.location
          where picklist = ms_pn.n_picklist;
        end if;

        if (nvl(ms_pn.s_location, '') <> nvl(dcl_pl.location, '')) then
          -- Create new picklist line
          update picklist_distribution
          set original_picklist = ms_pn.n_picklist
          where (picklist = ms_pn.n_picklist) and
                (picklist_line = dcl_pl.picklist_line) and
                (distribution_line > 0);
        end if;
      end if;

    end loop;
  end picklist_group_by_location;

  procedure load_pn(n_wo wo.wo%type, s_task_card wo_task_card.task_card%type, v_tc_pn_array in out wo_tc_pn_array) as
  begin
    if ( s_task_card > '0') then
      select wtcp.wo, wtcp.task_card, wtcp.pn,
             wtcp.qty, wtcp.qty_reserved, wtcp.modified_by,
             wtcp.modified_date, wtcp.reserve, 
             wtcp.task_card_pn, wtcp.task_card_pn_sn, wtcp.ac,
             wtcp.picklist_processed
      bulk collect into v_tc_pn_array
      from wo_task_card_pn wtcp, wo_task_card wtc
      where (wtcp.wo = wtc.wo) and
            (wtcp.task_card = wtc.task_card) and
            (wtcp.task_card_pn = wtc.pn) and
            (wtcp.task_card_pn_sn = wtc.pn_sn) and
            (wtcp.ac = wtc.ac) and
            (wtcp.wo = n_wo) and
            (wtcp.task_card = s_task_card)
      order by wtcp.task_card asc;
    else
      select wtcp.wo, wtcp.task_card, wtcp.pn,
             wtcp.qty, wtcp.qty_reserved, wtcp.modified_by,
             wtcp.modified_date, wtcp.reserve, 
             wtcp.task_card_pn, wtcp.task_card_pn_sn, wtcp.ac,
             wtcp.picklist_processed
      bulk collect into v_tc_pn_array
      from wo_task_card_pn wtcp, wo_task_card wtc
      where (wtcp.wo = wtc.wo) and
            (wtcp.task_card = wtc.task_card) and
            (wtcp.task_card_pn = wtc.pn) and
            (wtcp.task_card_pn_sn = wtc.pn_sn) and
            (wtcp.ac = wtc.ac) and
            (wtcp.wo = n_wo)
      order by wtcp.task_card asc;
    end if;

  end load_pn;

  function load_pn(n_wo wo.wo%type, s_task_card wo_task_card.task_card%type) return number
  as
  n_count number;
  begin
    if ( s_task_card > '0') then
      select count(wtcp.wo)
      into n_count
      from wo_task_card_pn wtcp, wo_task_card wtc
      where (wtcp.wo = wtc.wo) and
            (wtcp.task_card = wtc.task_card) and
            (wtcp.task_card_pn = wtc.pn) and
            (wtcp.task_card_pn_sn = wtc.pn_sn) and
            (wtcp.ac = wtc.ac) and
            (wtcp.wo = n_wo) and
            (wtcp.task_card = s_task_card);
    else
      select count(wtcp.wo)
      into n_count
      from wo_task_card_pn wtcp, wo_task_card wtc
      where (wtcp.wo = wtc.wo) and
            (wtcp.task_card = wtc.task_card) and
            (wtcp.task_card_pn = wtc.pn) and
            (wtcp.task_card_pn_sn = wtc.pn_sn) and
            (wtcp.ac = wtc.ac) and
            (wtcp.wo = n_wo);

    end if;
    return n_count;
  end load_pn;

  function wf_edit(s_tpw wo.third_party_wo%type, s_ac wo.ac%type,
                   n_wo wo.wo%type, s_location wo.location%type,
                   n_picklist picklist_header.picklist%type, 
                   n_line picklist_distribution.picklist_line%type,
                   n_qty_in number,
                   s_pn_in pn_master.pn%type) return number
  as
    s_pn        pn_interchangeable.pn%type;
    s_sn        pn_inventory_detail.sn%type;
    s_pn_main   pn_interchangeable.pn%type;
    s_condition pn_inventory_detail.condition%type;
    n_batch     pn_inventory_detail.batch%type;
    b_managed boolean;
    s_original varchar2(10000 char);
    n_qty number;
    n_qty_rtn number;
    ms_pn pkg_type_structures.st_pn;
  begin

    -- P/N
    if s_pn_in is null then
      begin
        select pn
        into s_pn
        from picklist_distribution
        where ( transaction = 'REQUIRE') and
             ( picklist = n_picklist) and
             ( picklist_line = n_line );

        select pn
        into s_pn_main
        from pn_interchangeable
        where pn_interchangeable = s_pn;
      exception
        when NO_DATA_FOUND then
          dbms_output.put_line('s_pn: No Data Found');
      end;
    else
      s_pn := s_pn_in;
    end if;

    if (sqlcode = 100) then return 1; end if;

    -- A/C Effectivity
    if ( (s_tpw = 'N' and (s_ac > '0' or (s_ac is not null))) or pkg_trax_session.f_getprofile = 'LTP') then
      ms_pn.s_pn := s_pn;
      ms_pn.s_ac := s_ac;
      ms_pn.n_wo := n_wo;

      if pkg_function_inventory.pn_effectivity_edit_no_dw(ms_pn, 1) = 1 then 
        return 1;
      end if;

      null;
    end if;

    -- QTY uncomment
--    begin
--      select qty
--      into n_qty
--      from picklist_distribution
--      where ( transaction = 'REQUIRE') and
--           ( picklist = n_picklist) and
--           ( picklist_line = n_line );
--    exception
--      when NO_DATA_FOUND then
--        dbms_output.put_line('n_picklist: No Data Found');
--    end;
    n_qty := n_qty_in;

    if (n_qty <= 0 or (n_qty is null)) then return 1; end if;

    begin
      select batch, s_condition, sn
      into n_batch, s_condition, s_sn
      from picklist_distribution
      where ( transaction = 'REQUIRE') and
           ( picklist = n_picklist) and
           ( picklist_line = n_line );
      exception
        when NO_DATA_FOUND then
          dbms_output.put_line('n_picklist: No Data Found');
    end;

    ms_pn.s_location := s_location;
    ms_pn.s_pn := s_pn;
    ms_pn.s_sn := s_sn;
    ms_pn.s_condition := s_condition;
    ms_pn.n_batch := n_batch;
    ms_pn.n_wo := n_wo;
    ms_pn.s_build_kit := 'YES';

    begin    
      select stc.company
      into ms_pn.s_gl_company
      from wo wo, system_tran_code stc
      where (stc.system_code = wo.gl_company) and 
            (stc.system_transaction = 'ORDERCATEGORY') and
            (stc.system_tran_code_sub = '          ') and
            (wo.wo = n_wo);
      exception
        when NO_DATA_FOUND then
          dbms_output.put_line('n_picklist: No Data Found');
    end;

    begin      
      select rm.employee_contractor
      into ms_pn.s_owner
      from customer_order_header coh,
           relation_master rm
      where (coh.customer = rm.relation_code) and
            ((coh.order_type = 'W/O') and
             (coh.order_number = n_wo));
      exception
        when NO_DATA_FOUND then
          dbms_output.put_line('n_picklist: No Data Found');
    end;

    if (sqlcode = 100) or ms_pn.s_owner < '0' then
      ms_pn.s_owner := null;
    end if;

    n_qty_rtn := pkg_function_inventory.inventory_available(ms_pn, s_original);

    if (n_qty_rtn > 0) then
      b_managed := managed_parts_picklist(ms_pn, s_original);
      if ((g_nInvDetRowCount - g_nInvDetIterated) > 0) then
        declare
          type ref_cursor is ref cursor;
          cur_qty ref_cursor;

          s_mod varchar2(10000 char);
        begin
          s_mod := 'select sum(
                  case when ( loan_category is null ) then qty_available
                       when ( loan_category <> ''MANAGE'' ) then qty_available
                       when (' || nvl(ms_pn.s_owner, 'null') || ' = owner) then qty_available
                       else 0
                  end ) as qty
                from ( ' || s_original || ' )';

          open cur_qty for s_mod;
          fetch cur_qty into n_qty_rtn;

          if (n_qty_rtn is null) or (cur_qty%NOTFOUND) then
            n_qty_rtn := 0;
          end if;
        end;
      else
        n_qty_rtn := 0;
      end if;
    end if;

    if (n_qty > n_qty_rtn) then
      if pkg_application_function.config_flag('BOCRT') = 'Y' then
        load_requisition(ms_pn.s_pn, '', '', ms_pn.s_location, ms_pn.s_ac, ms_pn.n_wo, ms_pn.s_task_card, g_sEC, ms_pn.s_gl_company, ms_pn.s_task_card_pn, ms_pn.s_task_card_sn,
           g_sSite, n_qty - n_qty_rtn);
--       n_qty := 0;
      end if;

      if (n_qty_rtn = 0) then return 0; end if;

      n_qty := n_qty_rtn;      
    end if;

    return 1;
  end wf_edit;

  procedure load_requisition(--n_requisition number,
                             s_pn pn_master.pn%type,
                             is_priority system_tran_code.system_code%type,
                             is_requisition_type requisition_header.requistion_type%type,
                             is_location pn_inventory_level.location%type,
                             is_ac requisition_header.ac%type,
                             in_wo requisition_header.wo%type,
                             is_taskcard requisition_header.task_card%type,
                             is_ec requisition_header.eo%type,
                             is_company requisition_header.order_category%type,
                             is_taskcard_pn requisition_header.task_card_pn%type,
                             is_task_pn_sn requisition_header.task_card_sn%type,                                              
                             is_site requisition_header.site%type,
                             n_qty number)


  as
    dt_today date;
    dt_date_require date;
    n_requisition number;
    -- n_requisition system_tran_config.config_number%type;

    s_buyer             pn_inventory_level.buyer%type;
    s_priority          system_tran_code.system_code%type;
    s_pn_main           pn_master.pn%type;
    s_pn_description    pn_master.pn_description%type;
    s_uom               pn_master.stock_uom%type;
    s_gl_company        pn_master.gl_company%type;
    s_gl_expenditure    pn_master.gl_expenditure%type;
    s_gl                pn_master.gl%type;
    s_gl_cost_center    pn_master.gl_cost_center%type;
    s_inventory_type    pn_master.inventory_type%type;
    s_requisition_type  requisition_header.requistion_type%type;
  begin
    dt_today := pkg_application_function.currentdatetime;

    -- Requisition Header
    n_requisition := pkg_application_function.config_number('REQSEQ');

    -- Load Priority 
   begin
     select system_code
     into s_priority
     from system_tran_code
     where (system_transaction = 'PRIORITY') and
           (priority_level = '99');
     exception
          when NO_DATA_FOUND then
            dbms_output.put_line('n_picklist: No Data Found');
   end;

   begin
    select pnm.pn,
           pnm.pn_description,
           pnm.stock_uom,
           pnm.gl_company,
           pnm.gl_expenditure,
           pnm.gl,
           pnm.gl_cost_center,
           pnm.inventory_type
    into s_pn_main,
         s_pn_description,
         s_uom,
         s_gl_company,
         s_gl_expenditure,
         s_gl,
         s_gl_cost_center,
         s_inventory_type
    from pn_master pnm, pn_interchangeable pni
    where (pni.pn = pnm.pn) and
          (pni.pn_interchangeable = s_pn);
    exception
        when NO_DATA_FOUND then
          dbms_output.put_line('n_picklist: No Data Found');
  end;

    begin
      select buyer
      into s_buyer
      from pn_inventory_level
      where (pn = s_pn_main) AND
            (location = is_location);
      exception
      when no_data_found then
        s_buyer := null;
    end;

    begin
      select buyer
      into s_buyer
      from pn_inventory_level
      where (pn = s_pn_main) AND
            (location = is_location);
      exception
      when no_data_found then
        s_buyer := null;
    end;

    s_requisition_type := 'PREDRAW';
    if nvl(is_priority,'') <> '' then s_priority := is_priority; end if;
    if nvl(is_requisition_type,'') <> '' then s_requisition_type := is_requisition_type; end if;

    insert into requisition_header
      ( requisition,
        requisition_description,
        requester_location,
        ac,
        wo,
        task_card,
        priority,
        requistion_type,
        status,
        created_by,
        created_date,
        modified_by,
        modified_date,
        inventory_type,
        eo,
        site,
        task_card_pn,
        task_card_sn,
        order_category  ,
        authorization , 
        authorized_by , 
        authorized_date
        )
    values ( n_requisition,
      'W/O Pre-Draw',
      is_location,
      is_ac,
      in_wo,
      is_taskcard,
      s_priority,
      s_requisition_type,
      'OPEN',
      pkg_trax_session.f_getuser,
      dt_today,
      pkg_trax_session.f_getuser,
      dt_today,
      s_inventory_type,
      is_ec,
      is_site,
      is_taskcard_pn,
      is_task_pn_sn,
      is_company , 
      'Y' , 
       pkg_trax_session.f_getuser,
      dt_today
    );

    insert into requisition_detail
      ( requisition,
      requisition_line,
      pn,
      pn_description,
      non_inventory_flag,
      qty_require,
      uom,
      status,
      require_date,
      location,
      qty_received,
      gl_company,
      gl_expenditure,
      gl,
      gl_cost_center,
      created_by,
      created_date,
      modified_by,
      modified_date,
      assign_to)
    values ( n_requisition,
      1,
      s_pn,
      s_pn_description,
      'N',
      n_qty,
      s_uom,
      'OPEN',
      dt_today,
      is_location,
      0, 
      s_gl_company,
      s_gl_expenditure,
      s_gl,
      s_gl_cost_center,
      pkg_trax_session.f_getuser,
      dt_today,
      pkg_trax_session.f_getuser,
      dt_today,
      s_buyer);

    commit;
  /*  
// Check for authorization
st_requisition ms_requisition
ms_requisition.l_requisition = l_requisition
ms_requisition.s_send_notification = 'YES'
If gf_requisition_authorization_level (ms_requisition) = 0 Then
	OpenWithParm (w_requisition_print,l_requisition)	
End If

Return

  */
end load_requisition;

  procedure wf_picklist_distribution( ms_pn in out nocopy pkg_type_structures.st_pn )
  as
    -- Associative array to keep track of batches that were processed
    type number_array is table of pn_inventory_detail.batch%type
      index by PLS_INTEGER;
    n_batches number_array;

    s_original          varchar2(10000 char);
    n_qty_rtn           number;
    dt_today            date;

    n_batch             picklist_distribution.batch%type;
    s_condition         picklist_distribution.condition%type;
    n_line              picklist_distribution.picklist_line%type;
    n_notes             picklist_distribution.notes%type;
    n_qty               picklist_distribution.qty%type;
    s_sn                picklist_distribution.sn%type;
    s_pn                picklist_distribution.pn%type;

    s_bin               picklist_header.bin%type;
    s_bin_transfer      picklist_header.bin_transfer%type;
    s_build_kit_header  picklist_header.build_kit%type;
    s_location_header   picklist_header.location%type;
    s_task_card         picklist_header.task_card%type;
    s_task_card_pn      picklist_header.task_card_pn%type;
    s_task_card_sn      picklist_header.task_card_sn%type;
    s_user              picklist_header.created_by%type;
    n_wo                picklist_header.wo%type;

    s_inventory_quarantine  location_master.inventory_quarantine%type;

    --ms_pn pkg_type_structures.st_pn;
  begin
    s_user := nvl(ms_pn.s_wall_password, pkg_trax_session.f_getuser);

    begin
      select wo, task_card, task_card_pn, task_card_sn, location, build_kit,
             nvl(bin_transfer, 'N'), bin
      into n_wo, s_task_card, s_task_card_pn, s_task_card_sn, s_location_header,
           s_build_kit_header, s_bin_transfer, s_bin
      from picklist_header
      where picklist = ms_pn.n_picklist;

      select nvl(inventory_quarantine, 'N')
      into s_inventory_quarantine
      from location_master
      where location = s_location_header;
    exception
      when NO_DATA_FOUND then
        dbms_output.put_line('n_picklist: No Data Found');
    end;

    if (nvl(ms_pn.n_picklist_distribution_line, 0) = 0) then
  --    n_line := dw_eu.Getitemnumber(1, 'picklist_line');
  --  else
      n_line := ms_pn.n_picklist_line;
    end if;

    -- Reverse Picklist
    ms_pn.n_picklist_line := n_line;
    pkg_function_inventory.picklist_detail(ms_pn);

    if (nvl(ms_pn.n_picklist_distribution_line, 0) = 0) then
      begin
        select qty, batch, condition, sn, pn, notes
        into n_qty, n_batch, s_condition, s_sn, s_pn, n_notes
        from picklist_distribution
        where ( transaction = 'REQUIRE' ) and
              ( picklist = ms_pn.n_picklist ) and
              ( picklist_line = ms_pn.n_picklist_line );
      exception
        when NO_DATA_FOUND then
          dbms_output.put_line('n_picklist: No Data Found');
          s_pn:= ms_pn.s_pn;
          n_qty := ms_pn.n_qty;
      end;
    else
      n_qty := ms_pn.n_qty;
      n_batch := ms_pn.n_batch;
      s_condition := '';
      s_sn := ms_pn.s_sn;
      s_pn := ms_pn.s_pn;
      n_notes := ms_pn.n_notes;
    end if;

    s_bin := nvl(s_bin, '');
    if (s_bin = '') then
      s_bin_transfer := 'N';
    end if;

     -- Load Inventory
    ms_pn.s_pn := s_pn;
    ms_pn.s_condition := s_condition;
    ms_pn.s_sn := s_sn;
    ms_pn.n_batch := n_batch;
    ms_pn.n_wo := n_wo;
    ms_pn.s_effectivity := 'Y';
    ms_pn.s_location := s_location_header;

    if (s_build_kit_header = 'YES') then
     -- ms_pn.s_location := s_location_header;
      ms_pn.s_build_kit := s_build_kit_header;
    end if;

    ms_pn.s_effectivity := 'Y';

    if (ms_pn.s_order_type = 'S/O') then
      begin
        select stc.company
        into ms_pn.s_gl_company
        from customer_order_header coh, system_tran_code stc
        where stc.system_code = coh.company and
              stc.system_transaction = 'ORDERCATEGORY' and
              stc.system_tran_code_sub = '          ' and
              coh.order_number = ms_pn.n_so_number;
        exception
          when NO_DATA_FOUND then
            dbms_output.put_line('n_picklist: No Data Found');
      end;
    else
      begin
        select stc.company
        into ms_pn.s_gl_company
        from wo wo, system_tran_code stc
        where stc.system_code = wo.gl_company and
              stc.system_transaction = 'ORDERCATEGORY' and
              stc.system_tran_code_sub = '          ' and
              wo.wo = n_wo;
      exception
        when NO_DATA_FOUND then
          dbms_output.put_line('No Data Found');
      end;
    end if;

    if (s_inventory_quarantine = 'Y') then
      n_qty_rtn := pkg_function_inventory.inventory_available_quaratine(ms_pn, s_original);
    else
      n_qty_rtn := pkg_function_inventory.inventory_available(ms_pn, s_original);
    end if;

    --n_qty := 5;
    if (n_qty > n_qty_rtn) then 
      n_qty := n_qty_rtn; 
    end if;

    declare
      type ref_cursor is ref cursor;
      cur_query ref_cursor;

      n_avl_1 pn_inventory_detail.qty_available%type;
      n_us_1 pn_inventory_detail.qty_us%type;
      n_qty_avail pn_inventory_detail.qty_available%type;
      n_qty_us pn_inventory_detail.qty_us%type;

      n_qty_available pn_inventory_detail.qty_available%type;
      n_qty_reserved pn_inventory_detail.qty_reserved%type;
      s_current_location pn_inventory_detail.location%type;
      s_current_bin pn_inventory_detail.bin%type;
      dt_today date;

      n_new_batch pn_inventory_detail.batch%type;
      n_qty_rsv pn_inventory_detail.qty_available%type;

      n_goods_rcvd_batch pn_inventory_detail.goods_rcvd_batch%type;
      s_pn_dist pn_inventory_detail.pn%type;
      s_sn_dist pn_inventory_detail.sn%type;
      s_location_dist pn_inventory_detail.location%type;
      s_bin_dist pn_inventory_detail.bin%type;
      s_condition_dist pn_inventory_detail.condition%type;

      ms_pn_history pkg_type_structures.st_pn;
      ms_pn_history_clear pkg_type_structures.st_pn;

      inv_avl_col pkg_type_structures.inv_avl_array;
      n_RowCount number;
      n_Index number;

      l_picklist_distribution_line picklist_distribution.distribution_line%type;
    begin
      pkg_function_inventory.inv_avl_coll_populate(inv_avl_col, ms_pn);
      n_RowCount := inv_avl_col.count;

      n_index := 0;
      while (nvl(n_qty, 0) > 0) and (n_index <> n_RowCount)--Revert
      loop
        n_index := n_index + 1;

        if (s_inventory_quarantine = 'N') then
          if (inv_avl_col(n_index).n_avl_1 = 0) then goto next_iteration; end if;
          n_qty_available := inv_avl_col(n_index).n_qty_available;
        else
          if (inv_avl_col(n_index).n_us_1 = 0) then goto next_iteration; end if;
          n_qty_available := inv_avl_col(n_index).n_qty_us;
        end if;

        n_qty_reserved := inv_avl_col(n_index).n_qty_reserved;

        if (n_qty_available is null) then n_qty_available := 0; end if;
        if (n_qty_reserved is null) then n_qty_reserved := 0; end if;
        if (n_qty is null) then n_qty := 0; end if;

        n_batch := inv_avl_col(n_index).n_batch;
        s_current_location := inv_avl_col(n_index).s_location;
        s_current_bin := inv_avl_col(n_index).s_bin;
        n_new_batch := 0;

        if (n_qty > n_qty_available) then
          n_qty := n_qty - n_qty_available;
          n_qty_reserved := n_qty_reserved + n_qty_available;
          inv_avl_col(n_index).n_qty_reserved := n_qty_reserved;

          if (s_inventory_quarantine = 'N') then
            inv_avl_col(n_index).n_qty_available := 0;
          else
            inv_avl_col(n_index).n_qty_us := 0;
          end if;

          n_qty_rsv := n_qty_available;

          if (s_bin_transfer = 'Y') and (s_location_header = s_current_location) and (s_current_bin <> s_bin) then
            inv_avl_col(n_index).s_bin := s_bin;
          end if;
        elsif (n_qty_available > 0) then
          n_qty_available := n_qty_available - n_qty;
          n_qty_reserved := n_qty_reserved + n_qty;
          inv_avl_col(n_index).n_qty_reserved := n_qty_reserved;

          if (s_inventory_quarantine = 'N') then
            inv_avl_col(n_index).n_qty_available := n_qty_available;
          else
            inv_avl_col(n_index).n_qty_us := n_qty_available;
          end if;

          n_qty_rsv := n_qty;
          n_qty := 0;

          if (s_bin_transfer = 'Y') and (s_location_header = s_current_location) and (s_current_bin <> s_bin) then
            if (n_qty_available = 0) then
              inv_avl_col(n_index).s_bin := s_bin;
            else
              n_new_batch := pkg_application_function.config_number('BATCH');
              inv_avl_col(inv_avl_col.count + 1) := inv_avl_col(n_index);
              inv_avl_col(inv_avl_col.count).n_batch := n_new_batch;
              inv_avl_col(inv_avl_col.count).s_bin := s_bin;
              inv_avl_col(inv_avl_col.count).n_qty_reserved := 0;

              if (s_inventory_quarantine = 'N') then
                inv_avl_col(inv_avl_col.count).n_qty_available := 0;
              else
                inv_avl_col(inv_avl_col.count).n_qty_us := 0;
              end if;
            end if;
          end if;
        else
          goto next_iteration;
        end if;

        s_pn_dist := null;
        s_sn_dist := null;

        if (n_batch is not null) then
          begin
            select pn, sn, location, bin, condition, goods_rcvd_batch
            into s_pn_dist, s_sn_dist, s_location_dist, s_bin_dist, s_condition_dist, n_goods_rcvd_batch
            from pn_inventory_detail
            where batch = n_batch;
            exception
              when NO_DATA_FOUND then
                dbms_output.put_line('n_picklist: No Data Found');
          end;
        end if;

        if (nvl(n_new_batch, 0) > 0) then n_batch := n_new_batch; end if;
        dt_today := pkg_application_function.currentdatetime;

        if (nvl(ms_pn.n_picklist_distribution_line, 0) = 0) then
          l_picklist_distribution_line := pkg_function_inventory.distribution_number(ms_pn.n_picklist, ms_pn.n_picklist_line);
        else
          l_picklist_distribution_line := ms_pn.n_picklist_distribution_line;
        end if;

        insert into picklist_distribution
                (transaction,
                picklist,
                picklist_line,
                batch,
                pn,
                sn,
                qty,
                qty_picked,
                task_card,
                distribution_line,
                modified_date,
                modified_by,
                created_date,
                created_by,
                notes,
                condition,
                status)
            values ('REQUIRE',
                ms_pn.n_picklist,
                ms_pn.n_picklist_line,
                null,
                s_pn_dist,
                s_sn_dist,
                n_qty_rsv,
                1,
                ms_pn.s_task_card,
                0,
                dt_today,
                pkg_trax_session.f_getuser,
                dt_today,
                pkg_trax_session.f_getuser,
                n_notes,
                null,
                'OPEN');
        -------------------------------------
        insert into picklist_distribution
                (transaction,
                picklist,
                picklist_line,
                batch,
                pn,
                sn,
                qty,
                qty_picked,
                task_card,
                distribution_line,
                modified_date,
                modified_by,
                created_date,
                created_by,
                notes,
                condition,
                status)
            values ('DISTRIBU',
                ms_pn.n_picklist,
                ms_pn.n_picklist_line,
                n_batch,
                s_pn_dist,
                s_sn_dist,
                n_qty_rsv,
                1,
                ms_pn.s_task_card,
                l_picklist_distribution_line,
                dt_today,
                pkg_trax_session.f_getuser,
                dt_today,
                pkg_trax_session.f_getuser,
                n_notes,
                s_condition_dist,
                'OPEN');

        ms_pn_history := ms_pn_history_clear; -- Resetting
        ms_pn_history.n_batch := n_batch;
        ms_pn_history.n_goods_rcvd_batch := n_goods_rcvd_batch;
        ms_pn_history.s_pn := s_pn_dist;
        ms_pn_history.s_sn := s_sn_dist;
        ms_pn_history.n_qty := n_qty_rsv;
        ms_pn_history.s_condition := s_condition_dist;
        ms_pn_history.s_location := s_location_dist;
        ms_pn_history.s_bin := s_bin_dist;
        ms_pn_history.s_wall_password := pkg_trax_session.f_getUser;

        if (s_bin_transfer = 'Y') and (s_location_header = s_current_location) and (s_current_bin <> s_bin) then
          ms_pn_history.s_transaction_type := 'BIN/TRANSFER';
          ms_pn_history.s_to_bin := s_bin;
          pkg_function_inventory.insert_pn_inventory_history(ms_pn_history);
          ms_pn_history.s_bin := s_bin;
        end if;

        -- Picklist Create History
        ms_pn_history.s_transaction_type := 'PICKLIST/CREATE';
        ms_pn_history.s_to_bin := null;
        ms_pn_history.s_order_type := 'PICKLST';
        ms_pn_history.n_picklist := ms_pn.n_picklist;
        ms_pn_history.n_picklist_line := n_line;
        ms_pn_history.n_notes := n_notes;
        ms_pn_history.n_wo := n_wo;
        ms_pn_history.s_task_card := s_task_card;
        ms_pn_history.s_task_card_pn := s_task_card_pn;
        ms_pn_history.s_task_card_sn := s_task_card_sn;
        pkg_function_inventory.insert_pn_inventory_history(ms_pn_history);

        <<next_iteration>>
        null;
      end loop;

      n_Index := inv_avl_col.first;
      while (n_Index is not null)
      loop
        update pn_inventory_detail
        set qty_available = inv_avl_col(n_Index).n_qty_available,
            qty_us = inv_avl_col(n_Index).n_qty_us,
            qty_reserved = inv_avl_col(n_Index).n_qty_reserved
        where batch = inv_avl_col(n_Index).n_batch;

        n_Index := inv_avl_col.next(n_Index);
      end loop;

      n_Index := n_batches.first;
      while (n_Index is not null)
      loop
        declare
          s_pn_local pn_inventory_detail.pn%type;
          s_location_local pn_inventory_detail.location%type;
        begin
          begin
            select pn, location
            into s_pn_local, s_location_local
            from pn_inventory_detail
            where batch = n_batches(n_Index);
            exception
            when NO_DATA_FOUND then
              dbms_output.put_line('n_picklist: No Data Found');
          end;

          -- Check Levels
          if ( (nvl(ms_pn.s_transaction_type, '') <> 'ISSUE') or pkg_function_inventory.inventory_level_check_reorder('ISSUE', s_pn_local) = 'YES') and
             ( nvl(ms_pn.s_transaction_type, '') <> 'NOREQUISITION') then
             pkg_function_inventory.inventory_level_check(s_location_local, s_pn_local);
          end if;
        end;

        n_Index := n_batches.next(n_Index);
      end loop;
    end;

    commit;
  end wf_picklist_distribution;

  function managed_parts_picklist(ms_pn pkg_type_structures.st_pn, s_query varchar2) return boolean
  as
    n_batch           pn_inventory_detail.batch%type;
    s_loan_category   pn_inventory_detail.loan_category%type;
    s_customer        customer_inventory_owner.customer%type;
    s_ac              ac_master.ac%type;
    b_return          boolean;
    s_mod             varchar2(10000 char);

    type ref_cursor is ref cursor;
    type pn_inv_det_array is table of pn_inventory_detail%rowtype index by PLS_INTEGER;

    cur_query ref_cursor;
    v_pn_inv_det pn_inv_det_array;
  begin
    g_nInvDetIterated := 0;
    g_nInvDetRowCount := 0;
    b_return := false;
    s_ac := null;
    s_customer := null;
    s_loan_category := null;

    s_mod := 'select batch
              from ( ' || s_query || ' )';

    open cur_query for s_mod;--s_query;

    loop
      fetch cur_query into n_batch;
      exit when cur_query%NOTFOUND;

      begin
        select loan_category
        into s_loan_category
        from pn_inventory_detail
        where batch = n_batch;
        exception
          when NO_DATA_FOUND then
            dbms_output.put_line('n_picklist: No Data Found');
      end;

      if (s_loan_category = 'MANAGE') then
        begin
          select customer
          into s_customer
          from customer_inventory_owner cio
          where customer = (select customer
                            from customer_order_header coh, wo wo
                            where (coh.order_number = wo.wo) and
                                  (coh.order_type = 'W/O') and
                                  (nvl(wo.third_party_wo, 'N') = 'Y') and
                                  (coh.order_number = ms_pn.n_wo) and
                                  (cio.inv_owner = (select owner
                                                    from pn_inventory_detail
                                                    where loan_category = 'MANAGE' and
                                                          batch = n_batch)));
          exception
          when NO_DATA_FOUND then
            dbms_output.put_line('n_picklist: No Data Found');
        end;

        if (trim(nvl(s_customer, '')) <> '') then
          if (ms_pn.s_ac > '0') then
            begin
              select ac
              into s_ac
              from ac_master
              where (ac_ownership_control = 'MANAGED') and
                    (ac = ms_pn.s_ac) and
                    (customer = s_customer);
              exception
                when NO_DATA_FOUND then
                  dbms_output.put_line('n_picklist: No Data Found');
            end;

            if (trim(nvl(s_ac, '')) = '') then
              g_nInvDetIterated := g_nInvDetIterated + 1;
              b_return := true;
            end if;
          end if;
        else
          g_nInvDetIterated := g_nInvDetIterated + 1;
          b_return := true;
        end if;
      end if;
    end loop;

    g_nInvDetRowCount := cur_query%rowcount;

    return b_return;
  end managed_parts_picklist;

  procedure cancel_requisition(n_wo wo.wo%type, s_task_card varchar2) as
    dt_today date;
    s_task_card_t wo_task_card.task_card%type;
    s_return requisition_detail.uom%type;
  begin
    dt_today := pkg_application_function.currentdatetime;

    if (s_task_card < '0') then
      s_task_card_t := null;
    end if;

    for dcl_requisition in (select "REQUISITION_DETAIL"."REQUISITION",
                                   "REQUISITION_DETAIL"."REQUISITION_LINE",
                                   "REQUISITION_DETAIL"."STATUS"
                            from "REQUISITION_HEADER", "REQUISITION_DETAIL"
                            where ("REQUISITION_DETAIL"."REQUISITION" = "REQUISITION_HEADER"."REQUISITION") and
                                  ((s_task_card_t is null) and
                                   ("REQUISITION_HEADER"."WO" = n_wo) or
                                   (s_task_card_t is not null) and
                                   ("REQUISITION_HEADER"."WO" = n_wo) and
                                   ("REQUISITION_HEADER"."TASK_CARD" = s_task_card_t)) and "REQUISITION_DETAIL"."STATUS" = 'OPEN' )
    loop

        -- Cancel detail line
        update "REQUISITION_DETAIL"
        set status = 'CANCEL',
            modified_by = 'EMOBILITY',
            modified_date = dt_today ,
            CANCELED_BY = 'EMOBILITY' ,
            CANCELED_DATE = dt_today            
        where ("REQUISITION_DETAIL"."REQUISITION" = dcl_requisition.requisition) and
              ("REQUISITION_DETAIL"."REQUISITION_LINE" = dcl_requisition.requisition_line);

        begin
          select uom
          into s_return
          from requisition_detail
          where (requisition = dcl_requisition.requisition) and
                (status = 'OPEN');
        exception
          when NO_DATA_FOUND then
            dbms_output.put_line('uom: No Data Found');
        end;

        -- Cancel Header
        if (sqlcode = 100) then
          update requisition_header
          set status = 'CLOSED',
              modified_by = 'EMOBILITY',
              modified_date = dt_today
          where requisition = dcl_requisition.requisition;
        end if;
        --print picklist to report server for picklist use
     --   sendPicklistToPrintQueue(dcl_requisition.requisition) ;
     
    end loop;
  end cancel_requisition;

  procedure picklist_cancellation(n_wo wo.wo%type) as
    v_tc_pn_array dw_sel_cancel_array;
    ms_pn pkg_type_structures.st_pn;

    n_Count number;
    n_RowCount number;
    --n_Index number;
    dt_today date;

    s_created_by  picklist_distribution.created_by%type;
    s_wopick1 system_tran_config.config_flag%type;
    n_picklist picklist_header.picklist%type;
    s_task_card picklist_header.task_card%type;
    n_line picklist_distribution.picklist_line%type;
    n_qty picklist_distribution.qty%type;
    s_pn  picklist_distribution.pn%type;
    s_picklist_status picklist_header.status%type;
    s_task_card_pn wo_task_card_pn.pn%type;
    n_qty_reserved wo_task_card_pn.qty_reserved%type;
    n_batch picklist_distribution.batch%type;
    n_qty_available pn_inventory_detail.qty_available%type;
  begin
    dt_today := pkg_application_function.currentdatetime;
    s_wopick1 := pkg_application_function.config_flag('WOPICK1');

    -- Cancel Requisitions
    cancel_requisition(n_wo, '');

    -- Load
    load_pn_cancellation(n_wo, '', v_tc_pn_array);

    n_RowCount := v_tc_pn_array.count;
    --n_Index := 0;

    if (n_RowCount = 0) then
      return;
    end if;

    for n_Index in 1..n_RowCount
    loop
      n_picklist := v_tc_pn_array(n_Index).n_picklist;

      if (s_wopick1 = 'Y') then
        s_task_card := v_tc_pn_array(n_Index).s_task_card2;
      else
        s_task_card := v_tc_pn_array(n_Index).s_task_card;
      end if;

      n_line := v_tc_pn_array(n_Index).n_line;
      n_qty := v_tc_pn_array(n_index).n_qty;
      s_pn := v_tc_pn_array(n_index).s_pn;
      s_picklist_status := v_tc_pn_array(n_index).s_status;

      if (s_picklist_status = 'TRANSFER') then
        goto next_iteration;
      end if;

      ms_pn.n_picklist := n_picklist;
      ms_pn.n_picklist_line := n_line;
--      pkg_function_inventory.picklist_detail(ms_pn);

      begin
        select wtcp.pn, wtcp.qty_reserved
        into s_task_card_pn, n_qty_reserved
        from wo_task_card_pn wtcp, pn_interchangeable pni
        where (wtcp.pn = pni.pn_interchangeable) and
              ((wtcp.wo = n_wo) and
               (wtcp.task_card = s_task_card) and
               (pni.pn_interchangeable = s_pn));
      exception
        when NO_DATA_FOUND then
          dbms_output.put_line('uom: No Data Found');
      end;

      if (sqlcode <> 100) then
        if (n_qty_reserved is null) then n_qty_reserved := 0; end if;
        if (n_qty is null) then n_qty := 0; end if;
        n_qty_reserved := n_qty_reserved - n_qty;

        if (n_qty_reserved < 0) then n_qty_reserved := 0; end if;

        update wo_task_card_pn
        set qty_reserved = n_qty_reserved,
            modified_date = dt_today
        where (wo = n_wo) and
              (task_card = s_task_card) and
              (pn = s_task_card_pn);

      end if;

-- Sadiel Log 132546 ---------------
      DECLARE
        CURSOR CUR_BATCH_QTY IS
        select pd.batch, pd.qty
        FROM PICKLIST_DISTRIBUTION PD
        where pd.transaction = 'DISTRIBU' and
              pd.picklist = n_picklist and
              pd.picklist_line = n_line; 
        TYPE RT_BATCH_QTY IS RECORD(BATCH NUMBER, QTY NUMBER);
        TYPE TT_BATCH_QTY IS TABLE OF RT_BATCH_QTY;
        T_BATCH_QTY TT_BATCH_QTY := TT_BATCH_QTY();
      begin

        OPEN CUR_BATCH_QTY;
        FETCH CUR_BATCH_QTY BULK COLLECT INTO T_BATCH_QTY;
        CLOSE CUR_BATCH_QTY;

        IF T_BATCH_QTY.COUNT >= 1 THEN
          FOR I IN T_BATCH_QTY.FIRST..T_BATCH_QTY.LAST
          loop
            UPDATE PN_INVENTORY_DETAIL
            SET QTY_AVAILABLE = NVL(QTY_AVAILABLE, 0) + T_BATCH_QTY(I).QTY,
                qty_reserved = nvl(qty_reserved, 0) - T_BATCH_QTY(I).QTY
            WHERE PN_INVENTORY_DETAIL.BATCH = T_BATCH_QTY(I).BATCH;
          end loop;
        END IF;

      exception
          WHEN NO_DATA_FOUND THEN
            dbms_output.put_line('No Data Found');
      end;

 ------------------------------------     
      begin
        select created_by
        into s_created_by
        from picklist_distribution
        where transaction = v_tc_pn_array(n_Index).s_transaction and
              picklist = n_picklist and
              picklist_line = n_line;
      exception
        when NO_DATA_FOUND then
          dbms_output.put_line('uom: No Data Found');
      end;

      DELETE FROM PICKLIST_DISTRIBUTION
      where picklist = n_picklist and
            picklist_line = n_line;

      select count(*)
      into n_Count
      from picklist_distribution
      where picklist = n_picklist;

      if (n_count is null) then n_count := 0; end if;

      if (n_count = 0) then
        delete from picklist_header
        where picklist = n_picklist;
      end if;

      commit;

      -- send message to requester
      if (nvl(s_created_by, '') <> '') then
        pkg_application_function.send_note_to_user(
          'TRAXIFACE',
          s_created_by,
          'Picklist: ' || to_char(n_picklist) || ' on W/O: ' || to_char(n_wo) || ' reservation has been cancelled.');
      end if;

      <<next_iteration>>
      null;
    end loop;
  end picklist_cancellation;

  procedure load_pn_cancellation(n_wo wo.wo%type, s_task_card wo_task_card.task_card%type, v_tc_pn_array in out dw_sel_cancel_array) as
    s_query varchar2(2048 char);
    s_crlf varchar2(2 char);

    type ref_cursor is ref cursor;
    cur_query ref_cursor;

    n_wo_t          "PICKLIST_HEADER"."WO"%type;
    s_task_card_t   "PICKLIST_HEADER"."TASK_CARD"%type;
    n_line_t        "PICKLIST_DISTRIBUTION"."PICKLIST_LINE"%type;
    s_transaction_t "PICKLIST_DISTRIBUTION"."TRANSACTION"%type;
    n_picklist_t    "PICKLIST_HEADER"."PICKLIST"%type;
    s_pn_t          "PICKLIST_DISTRIBUTION"."PN"%type;
    n_qty_t         "PICKLIST_DISTRIBUTION"."QTY"%type;
    s_so_t          "PICKLIST_HEADER"."SO"%type;
    n_order_line_t  "PICKLIST_DISTRIBUTION"."ORDER_LINE"%type;
    s_created_by_t  "PICKLIST_HEADER"."CREATED_BY"%type;
    s_task_card_t2  "PICKLIST_DISTRIBUTION"."TASK_CARD"%type;   
    s_status_t      "PICKLIST_HEADER"."STATUS"%type;
  begin
    s_crlf := chr(13) || chr(10);

    s_query := 'SELECT "PICKLIST_HEADER"."WO",   
         "PICKLIST_HEADER"."TASK_CARD",   
         "PICKLIST_DISTRIBUTION"."PICKLIST_LINE",   
         "PICKLIST_DISTRIBUTION"."TRANSACTION",   
         "PICKLIST_HEADER"."PICKLIST",   
         "PICKLIST_DISTRIBUTION"."PN",   
         "PICKLIST_DISTRIBUTION"."QTY",   
         "PICKLIST_HEADER"."SO",   
         "PICKLIST_DISTRIBUTION"."ORDER_LINE",   
         "PICKLIST_HEADER"."CREATED_BY",   
         "PICKLIST_DISTRIBUTION"."TASK_CARD",   
         "PICKLIST_HEADER"."STATUS"  
    FROM "PICKLIST_HEADER",   
         "PICKLIST_DISTRIBUTION"  
    WHERE ( picklist_header.picklist = picklist_distribution.picklist (+)) and
          ("PICKLIST_HEADER"."WO" = ' || to_char(n_wo) || ') and
          (("PICKLIST_HEADER"."STATUS" = ''OPEN'') or
           ("PICKLIST_HEADER"."STATUS" = ''TRANSFER''))';

    if (s_task_card > '0') then
      if (pkg_application_function.config_flag('WOPICK1') = 'N') then
        s_query := s_query || ' and ' || s_crlf || 
            '("PICKLIST_HEADER"."TASK_CARD" = ' || s_task_card || ')';
      else
        s_query := s_query || ' and ' || s_crlf || 
            '("PICKLIST_DISTRIBUTION"."TASK_CARD" = ' || s_task_card || ')';
      end if;
    end if;

    s_query := s_query || ' and ' || s_crlf || 
        '("PICKLIST_DISTRIBUTION"."TRANSACTION" = ''REQUIRE'')';
    s_query := s_query || ' and ' || s_crlf ||
        '("PICKLIST_DISTRIBUTION"."STATUS" = ''OPEN'')';

    open cur_query for s_query;

    loop
      fetch cur_query into n_wo_t, s_task_card_t, n_line_t, 
                             s_transaction_t, n_picklist_t, s_pn_t, n_qty_t,
                             s_so_t, n_order_line_t, s_created_by_t,
                             s_task_card_t2, s_status_t;
      exit when cur_query%NOTFOUND;

      v_tc_pn_array(v_tc_pn_array.count + 1).n_wo := n_wo_t;
      v_tc_pn_array(v_tc_pn_array.count).s_task_card := s_task_card_t;
      v_tc_pn_array(v_tc_pn_array.count).n_line := n_line_t;
      v_tc_pn_array(v_tc_pn_array.count).s_transaction := s_transaction_t;
      v_tc_pn_array(v_tc_pn_array.count).n_picklist := n_picklist_t;
      v_tc_pn_array(v_tc_pn_array.count).s_pn := s_pn_t;
      v_tc_pn_array(v_tc_pn_array.count).n_qty := n_qty_t;
      v_tc_pn_array(v_tc_pn_array.count).s_so := s_so_t;
      v_tc_pn_array(v_tc_pn_array.count).n_order_line := n_order_line_t;
      v_tc_pn_array(v_tc_pn_array.count).s_created_by := s_created_by_t;
      v_tc_pn_array(v_tc_pn_array.count).s_task_card2 := s_task_card_t2;
      v_tc_pn_array(v_tc_pn_array.count).s_status := s_status_t;
    end loop;
  end load_pn_cancellation;

  PROCEDURE OF_PICKLIST_HISTORY(MS_PN IN OUT NOCOPY PKG_TYPE_STRUCTURES.ST_PN, gS_USER varchar2 default 'TRAXIFACE')
  AS
    L_TRN NUMBER := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('PNINVHIS');
    DT_TODAY DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    S_USER varchar2(100);
  BEGIN
    IF NVL(MS_PN.S_WALL_PASSWORD, '') = '' THEN
      s_user := gs_user;
    ELSE
      S_USER := MS_PN.S_WALL_PASSWORD;
    End If;

    INSERT INTO "PN_INVENTORY_HISTORY"  
        ( "TRANSACTION_NO",   
        "TRANSACTION_TYPE",   
        "BATCH",   
        "GOODS_RCVD_BATCH",   
        "PN",   
        "SN",   
        "QTY",   
        "CREATED_BY",   
        "CREATED_DATE",   
        "MODIFIED_BY",   
        "MODIFIED_DATE",   
        "CONDITION",
        "LOCATION",
        "BIN",
        "ORDER_TYPE",
        "ORDER_NO",
        "ORDER_LINE",
        "NOTES",
        "WO",
        "TASK_CARD",
        "TASK_CARD_PN",
        "TASK_CARD_SN",
        "TO_BIN")
    VALUES ( L_TRN,   
        ms_pn.s_transaction_type,   
        ms_pn.n_batch,   
        ms_pn.n_goods_rcvd_batch,   
        ms_pn.s_pn,   
        ms_pn.s_sn,   
        ms_pn.n_qty,   
        s_user,   
        dt_today,   
        s_user,   
        dt_today,   
        ms_pn.s_condition,
        ms_pn.s_location,
        ms_pn.s_bin,
        ms_pn.s_order_type, 
        ms_pn.n_picklist,
        ms_pn.n_picklist_line,
        ms_pn.n_notes,
        ms_pn.n_wo,
        ms_pn.s_task_card,
        ms_pn.s_task_card_pn,
        MS_PN.S_TASK_CARD_SN,
        ms_pn.s_to_bin);
  end OF_PICKLIST_HISTORY;

  PROCEDURE OF_PICKLIST_DETAIL(ms_pn in out nocopy pkg_type_structures.st_pn)
  AS
  L_BATCH NUMBER;
  L_GOODS_RCVD_BATCH NUMBER;
  D_QTY_AVAILABLE NUMBER;
  D_QTY_RESERVED NUMBER;
  D_QTY NUMBER;
  D_QTY_US NUMBER;
  S_PN VARCHAR2(100);
  S_SN VARCHAR2(100);
  S_CONDITION VARCHAR2(100);
  S_LOCATION VARCHAR2(100);
  S_BIN VARCHAR2(100);
  s_location_header VARCHAR2(100);
  S_INVENTORY_QUARANTINE VARCHAR2(100);
  cursor cur_pd is
   SELECT *
    FROM "PICKLIST_DISTRIBUTION"  
   WHERE ( "PICKLIST_DISTRIBUTION"."TRANSACTION" = 'DISTRIBU' ) AND  
         ( "PICKLIST_DISTRIBUTION"."PICKLIST" = MS_PN.N_PICKLIST ) AND  
         ( "PICKLIST_DISTRIBUTION"."PICKLIST_LINE" = MS_PN.N_PICKLIST_LINE ) AND
         ( NVL(MS_PN.N_PICKLIST_DISTRIBUTION_LINE, 0) <= 0 OR "PICKLIST_DISTRIBUTION"."DISTRIBUTION_LINE" = MS_PN.N_PICKLIST_DISTRIBUTION_LINE );
    TYPE TT_PD IS TABLE OF PICKLIST_DISTRIBUTION%ROWTYPE;
    DW_PICKLIST_DETAIL TT_PD := TT_PD();
  BEGIN
    OPEN CUR_PD;
    FETCH CUR_PD BULK COLLECT INTO DW_PICKLIST_DETAIL;
    CLOSE CUR_PD;

    IF DW_PICKLIST_DETAIL is not null and DW_PICKLIST_DETAIL.count > 0 then
      SELECT "PICKLIST_HEADER"."LOCATION"
      INTO s_location_header
      FROM "PICKLIST_HEADER"  
      WHERE "PICKLIST_HEADER"."PICKLIST" = ms_pn.n_picklist;

      SELECT NVL("LOCATION_MASTER"."INVENTORY_QUARANTINE",'N')  
        INTO s_inventory_quarantine  
        FROM "LOCATION_MASTER"  
       WHERE "LOCATION_MASTER"."LOCATION" = s_location_header;

       FOR I_CROW IN reverse DW_PICKLIST_DETAIL.first..DW_PICKLIST_DETAIL.last
       LOOP
        L_BATCH := DW_PICKLIST_DETAIL(I_CROW).BATCH;
        d_qty  :=   nvl(dw_picklist_detail(i_crow).qty, 0);

        SELECT nvl("PN_INVENTORY_DETAIL"."QTY_AVAILABLE",0),   
            nvl("PN_INVENTORY_DETAIL"."QTY_RESERVED",0),
            nvl("PN_INVENTORY_DETAIL"."QTY_US",0),
            "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH",
            "PN_INVENTORY_DETAIL"."PN",
            "PN_INVENTORY_DETAIL"."SN",
            "PN_INVENTORY_DETAIL"."CONDITION",
            "PN_INVENTORY_DETAIL"."LOCATION",
            "PN_INVENTORY_DETAIL"."BIN"  
        INTO d_qty_available,   
            d_qty_reserved,
            d_qty_us,
            l_goods_rcvd_batch,
            s_pn,
            s_sn,
            s_condition,
            s_location,
            s_bin
        FROM "PN_INVENTORY_DETAIL"  
        WHERE "PN_INVENTORY_DETAIL"."BATCH" = L_BATCH;

        IF S_INVENTORY_QUARANTINE = 'N' THEN
          d_qty_available := d_qty_available + d_qty;
        ELSE
          D_QTY_US := D_QTY_US + D_QTY;
        END IF;

        d_qty_reserved  := d_qty_reserved   - d_qty;

        If s_inventory_quarantine = 'N' Then
          UPDATE "PN_INVENTORY_DETAIL"  
          SET "QTY_AVAILABLE" = d_qty_available,   
              "QTY_RESERVED" = d_qty_reserved  
          WHERE "PN_INVENTORY_DETAIL"."BATCH" = l_batch;
            Else
          UPDATE "PN_INVENTORY_DETAIL"  
          SET "QTY_US" = d_qty_us,   
              "QTY_RESERVED" = d_qty_reserved  
          WHERE "PN_INVENTORY_DETAIL"."BATCH" = l_batch;
        End If;

        DECLARE
          ms_pn_history pkg_type_structures.st_pn;
        BEGIN
          MS_PN_HISTORY.s_transaction_type  := 'PICKLIST/CANCEL';
          MS_PN_HISTORY.N_BATCH  := L_BATCH;
          MS_PN_HISTORY.N_GOODS_RCVD_BATCH  := l_GOODS_RCVD_BATCH;
          ms_pn_history.s_pn  := s_pn;
          MS_PN_HISTORY.S_SN  := S_SN;
          MS_PN_HISTORY.N_QTY  := D_QTY;
          ms_pn_history.s_location  := s_location;
          MS_PN_HISTORY.S_CONDITION  := S_CONDITION;
          MS_PN_HISTORY.S_BIN  := S_BIN;
          ms_pn_history.s_order_type  := 'PICKLST';
          ms_pn_history.n_picklist  := ms_pn.n_picklist;
          MS_PN_HISTORY.N_PICKLIST_LINE  := MS_PN.N_PICKLIST_LINE;
          MS_PN_HISTORY.S_WALL_PASSWORD  := MS_PN.S_WALL_PASSWORD;
          of_picklist_history(ms_pn_history);
        end;

        delete
        FROM "PICKLIST_DISTRIBUTION"  
        WHERE TRANSACTION = DW_PICKLIST_DETAIL(I_CROW).TRANSACTION
        AND   PICKLIST = DW_PICKLIST_DETAIL(I_CROW).PICKLIST
        AND   PICKLIST_LINE = DW_PICKLIST_DETAIL(I_CROW).PICKLIST_LINE
        and   DISTRIBUTION_LINE = dw_picklist_detail(i_crow).DISTRIBUTION_LINE;

       end loop;
    end if;

  end OF_PICKLIST_DETAIL;

  PROCEDURE PICKLIST_DISTRIBUTION_AUDIT(L_PICKLIST NUMBER, L_PICKLIST_LINE NUMBER, S_ACTION VARCHAR2, gs_user varchar2 default 'TRAXIFACE')
  AS
    L_COUNT NUMBER;
    dt_today DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
  begin
    SELECT COUNT(*)
    INTO l_count
    FROM "PICKLIST_DISTRIBUTION_AUDIT"  
    WHERE "PICKLIST_DISTRIBUTION_AUDIT"."PICKLIST" = L_PICKLIST AND
           "PICKLIST_DISTRIBUTION_AUDIT"."PICKLIST_LINE" = L_PICKLIST_LINE AND
           "PICKLIST_DISTRIBUTION_AUDIT"."ACTION" = S_ACTION AND
             "PICKLIST_DISTRIBUTION_AUDIT"."CREATED_BY" = GS_USER AND
          "PICKLIST_DISTRIBUTION_AUDIT"."CREATED_DATE" = dt_today;

    If NVL(l_count, 0) = 0 Then
     INSERT INTO "PICKLIST_DISTRIBUTION_AUDIT"  
           ( "TRANSACTION", 
          "PICKLIST", 
          "PICKLIST_LINE", 
          "PN", 
          "QTY", 
          "BATCH", 
          "CONDITION", 
          "SN", 
          "DISTRIBUTION_LINE", 
          "QTY_PICKED", 
          "NOTES", 
          "CREATED_BY", 
          "CREATED_DATE", 
          "MODIFIED_BY", 
          "MODIFIED_DATE", 
          "ORDER_LINE", 
          "STATUS", 
          "ORIGINAL_PICKLIST", 
          "TASK_CARD", 
          "REQUISITION", 
          "REQUISITION_LINE", 
          "RO_FOLLOWING_ID", 
          "PRINT_TAG", 
          "AUTOMATED_WAREHOUSE_ISSUED", 
          "DATE_PICKED",
          "ACTION")  
        SELECT "PICKLIST_DISTRIBUTION"."TRANSACTION", 
            "PICKLIST_DISTRIBUTION"."PICKLIST", 
            "PICKLIST_DISTRIBUTION"."PICKLIST_LINE", 
            "PICKLIST_DISTRIBUTION"."PN", 
            "PICKLIST_DISTRIBUTION"."QTY", 
            "PICKLIST_DISTRIBUTION"."BATCH", 
            "PICKLIST_DISTRIBUTION"."CONDITION", 
            "PICKLIST_DISTRIBUTION"."SN", 
            "PICKLIST_DISTRIBUTION"."DISTRIBUTION_LINE", 
            "PICKLIST_DISTRIBUTION"."QTY_PICKED", 
            "PICKLIST_DISTRIBUTION"."NOTES", 
            gs_user, 
            dt_today, 
            gs_user, 
            dt_today, 
            "PICKLIST_DISTRIBUTION"."ORDER_LINE", 
            "PICKLIST_DISTRIBUTION"."STATUS", 
            "PICKLIST_DISTRIBUTION"."ORIGINAL_PICKLIST", 
            "PICKLIST_DISTRIBUTION"."TASK_CARD", 
            "PICKLIST_DISTRIBUTION"."REQUISITION", 
            "PICKLIST_DISTRIBUTION"."REQUISITION_LINE", 
            "PICKLIST_DISTRIBUTION"."RO_FOLLOWING_ID", 
            "PICKLIST_DISTRIBUTION"."PRINT_TAG", 
            "PICKLIST_DISTRIBUTION"."AUTOMATED_WAREHOUSE_ISSUED", 
            "PICKLIST_DISTRIBUTION"."DATE_PICKED",
            s_action
         FROM "PICKLIST_DISTRIBUTION"  
        WHERE ( "PICKLIST_DISTRIBUTION"."PICKLIST" = L_PICKLIST ) AND
            ( "PICKLIST_DISTRIBUTION"."PICKLIST_LINE" = L_PICKLIST_LINE );
    End If;
  end PICKLIST_DISTRIBUTION_AUDIT;

  PROCEDURE PICKLIST_HEADER_AUDIT(L_PICKLIST NUMBER,  S_ACTION VARCHAR2, gs_user in out nocopy varchar2)
  AS
    dt_today date := pkg_application_function.currentdatetime;
  BEGIN
    INSERT INTO "PICKLIST_HEADER_AUDIT"  
          ( "PICKLIST", 
            "LOCATION", 
            "WO", 
            "TASK_CARD", 
            "REQUIRE_ON", 
            "STATUS", 
            "SO", 
            "NOTES", 
            "CREATED_BY", 
            "CREATED_DATE", 
            "MODIFIED_BY", 
            "MODIFIED_DATE", 
            "BUILD_KIT", 
            "ORDER_TYPE", 
            "ORDER_NUMBER", 
            "SITE", 
            "NO_OF_PRINT", 
            "DELIVERY_LOCATION", 
            "PRIORITY", 
            "AC", 
            "ISSUE_TO", 
            "ORIGINAL_LOCATION", 
            "INVENTORY_TYPE", 
            "ISSUE_TO_EMPLOYEE", 
            "TASK_CARD_PN", 
            "TASK_CARD_SN", 
            "BYPASS_ROUTING", 
            "REQUIRE_HOUR", 
            "REQUIRE_MINUTE", 
            "BIN_TRANSFER", 
            "BIN", 
            "PICKED_FLAG", 
            "PICKED_BY", 
            "PICKED_DATE", 
            "IN_USE",
            "ACTION")  
           SELECT "PICKLIST_HEADER"."PICKLIST",   
              "PICKLIST_HEADER"."LOCATION",   
              "PICKLIST_HEADER"."WO",   
              "PICKLIST_HEADER"."TASK_CARD",   
              "PICKLIST_HEADER"."REQUIRE_ON",   
              "PICKLIST_HEADER"."STATUS",   
              "PICKLIST_HEADER"."SO", 
              "PICKLIST_HEADER"."NOTES", 
              gs_user, 
              dt_today, 
              gs_user, 
              dt_today, 
              "PICKLIST_HEADER"."BUILD_KIT", 
              "PICKLIST_HEADER"."ORDER_TYPE", 
              "PICKLIST_HEADER"."ORDER_NUMBER", 
              "PICKLIST_HEADER"."SITE", 
              "PICKLIST_HEADER"."NO_OF_PRINT", 
              "PICKLIST_HEADER"."DELIVERY_LOCATION", 
              "PICKLIST_HEADER"."PRIORITY", 
              "PICKLIST_HEADER"."AC", 
              "PICKLIST_HEADER"."ISSUE_TO", 
              "PICKLIST_HEADER"."ORIGINAL_LOCATION", 
              "PICKLIST_HEADER"."INVENTORY_TYPE", 
              "PICKLIST_HEADER"."ISSUE_TO_EMPLOYEE", 
              "PICKLIST_HEADER"."TASK_CARD_PN", 
              "PICKLIST_HEADER"."TASK_CARD_SN", 
              "PICKLIST_HEADER"."BYPASS_ROUTING", 
              "PICKLIST_HEADER"."REQUIRE_HOUR", 
              "PICKLIST_HEADER"."REQUIRE_MINUTE", 
              "PICKLIST_HEADER"."BIN_TRANSFER", 
              "PICKLIST_HEADER"."BIN", 
              "PICKLIST_HEADER"."PICKED_FLAG", 
              "PICKLIST_HEADER"."PICKED_BY", 
              "PICKLIST_HEADER"."PICKED_DATE", 
              "PICKLIST_HEADER"."IN_USE",
              s_action
             FROM "PICKLIST_HEADER"  
             WHERE ( "PICKLIST_HEADER"."PICKLIST" = L_PICKLIST ) AND NOT EXISTS (SELECT 1 
                                                            FROM "PICKLIST_HEADER_AUDIT" 
                                                            WHERE "PICKLIST_HEADER_AUDIT"."PICKLIST" = L_PICKLIST 
                                                            AND "PICKLIST_HEADER_AUDIT"."CREATED_BY" = GS_USER  
                                                            AND "PICKLIST_HEADER_AUDIT"."CREATED_DATE" = DT_TODAY );
  end PICKLIST_HEADER_AUDIT;

  FUNCTION WF_LOAD_PN_for_cancel(n_wo number, s_task_card varchar2 default null, IS_WOPICK1 varchar2) RETURN DW_SEL_CANCEL_ARRAY
  AS
    S_ORIGINAL VARCHAR2(32000);
    s_and VARCHAR2(32000);
    s_file VARCHAR2(32000);
    s_fld VARCHAR2(32000);
    s_select VARCHAR2(32000);
    S_COMPARE VARCHAR2(32000);
    S_WHERE VARCHAR2(32000) := '  ';
    S_MOD VARCHAR2(32000);
    t_DW_SEL_CANCEL_ARRAY DW_SEL_CANCEL_ARRAY;
    cur_query refCursor;
  BEGIN
    s_original := 'SELECT "PICKLIST_HEADER"."WO",   
                         "PICKLIST_HEADER"."TASK_CARD",   
                         "PICKLIST_DISTRIBUTION"."PICKLIST_LINE",   
                         "PICKLIST_DISTRIBUTION"."TRANSACTION",   
                         "PICKLIST_HEADER"."PICKLIST",   
                         "PICKLIST_DISTRIBUTION"."PN",   
                         "PICKLIST_DISTRIBUTION"."QTY",   
                         "PICKLIST_HEADER"."SO",   
                         "PICKLIST_DISTRIBUTION"."ORDER_LINE",   
                         "PICKLIST_HEADER"."CREATED_BY",   
                         "PICKLIST_DISTRIBUTION"."TASK_CARD",   
                         "PICKLIST_HEADER"."STATUS"  
                    FROM "PICKLIST_HEADER",   
                         "PICKLIST_DISTRIBUTION"  
                   WHERE ( picklist_header.picklist = picklist_distribution.picklist )';
    S_COMPARE := ' = ' ;
    S_AND     := ' and ';
    S_FILE    := 'PICKLIST_HEADER';
    S_FLD     := 'WO';
    S_SELECT  := n_WO;

    s_where :=  s_where || s_and || s_file || '.' || s_fld ||  s_compare || s_select;   

    --Status
    S_FILE    := 'PICKLIST_HEADER';
    S_FLD     := 'STATUS';
    S_SELECT  := '''OPEN''';
    s_where := s_where || s_and || ' ( ' || s_file || '.' || s_fld ||  s_compare || s_select;

    S_FILE    := 'PICKLIST_HEADER';
    S_FLD     := 'STATUS';
    S_SELECT  := '''TRANSFER''';
    s_where :=  s_where || ' or ' || s_file || '.' || s_fld ||  s_compare || s_select || ' ) ';		   

    IF TRIM(S_TASK_CARD) IS NOT NULL THEN
      IF nvl(trim(IS_WOPICK1), 'N') = 'N' THEN
        s_file    := 'PICKLIST_HEADER';
      ELSE
        S_FILE    := 'PICKLIST_DISTRIBUTION';   
      End If;

      S_FLD     := 'TASK_CARD';
      S_SELECT  := '''' || S_TASK_CARD ||'''';
      S_WHERE :=  S_WHERE || S_AND || S_FILE || '.' || S_FLD ||  S_COMPARE || S_SELECT;
    End If;

    S_FILE    := 'PICKLIST_DISTRIBUTION';
    S_FLD     := 'TRANSACTION';
    S_SELECT  := '''REQUIRE''';
    s_where :=  s_where || s_and || s_file || '.' || s_fld ||  s_compare || s_select;

    S_FILE    := 'PICKLIST_DISTRIBUTION';
    S_FLD     := 'STATUS';
    S_SELECT  := '''OPEN''';
    s_where :=  s_where || s_and || s_file || '.' || s_fld ||  s_compare || s_select;

    S_MOD := S_ORIGINAL || S_WHERE;

    OPEN CUR_QUERY FOR S_MOD;
    FETCH CUR_QUERY BULK COLLECT INTO T_DW_SEL_CANCEL_ARRAY;
    close CUR_QUERY;

    return T_DW_SEL_CANCEL_ARRAY;

  end WF_LOAD_PN_for_cancel;

  PROCEDURE W_WO_REQ_CANCEL_EU_SUB_WO_LOOP(N_WO number, s_task_card varchar2 default null)
  AS
  BEGIN
    --UE_POSTOPEN
    cancel_requisition(n_wo, trim(s_task_card));
  end W_WO_REQ_CANCEL_EU_SUB_WO_LOOP;

  procedure W_WO_RESERV_CANCEL_SUB_WO_LOOP(N_WO number, s_task_card in out nocopy varchar2, gs_user in out nocopy varchar2)
  AS
    S_WOPICK1 VARCHAR2(100);
    t_DW_SEL_CANCEL_ARRAY DW_SEL_CANCEL_ARRAY;
  BEGIN
    --UE_POSTOPEN
    S_WOPICK1 := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPICK1');
    CANCEL_REQUISITION(N_WO, TRIM(S_TASK_CARD));
    t_DW_SEL_CANCEL_ARRAY := WF_LOAD_PN_for_cancel(n_wo, trim(s_task_card), trim(S_WOPICK1));

    IF T_DW_SEL_CANCEL_ARRAY IS NOT NULL AND T_DW_SEL_CANCEL_ARRAY.COUNT > 0 THEN
      FOR I IN T_DW_SEL_CANCEL_ARRAY.FIRST..T_DW_SEL_CANCEL_ARRAY.LAST
      LOOP
        DECLARE
          L_LINE NUMBER;
          S_PN VARCHAR(100);
          s_task_card VARCHAR(100);
          s_task_card_pn VARCHAR(100);
          S_PICKLIST_STATUS VARCHAR(100);
          D_QTY NUMBER;
          D_QTY_RESERVED NUMBER;
          DT_TODAY DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
          il_picklist number;
        BEGIN
          il_picklist := T_DW_SEL_CANCEL_ARRAY(i).n_picklist;

          IF S_WOPICK1 = 'Y' THEN
            s_task_card  := T_DW_SEL_CANCEL_ARRAY(i).s_task_card2;
          ELSE
            S_TASK_CARD  := T_DW_SEL_CANCEL_ARRAY(i).s_TASK_CARD;
          End If;

          L_LINE  := T_DW_SEL_CANCEL_ARRAY(I).N_LINE;
          D_QTY := T_DW_SEL_CANCEL_ARRAY(I).N_QTY;
          S_PN  := T_DW_SEL_CANCEL_ARRAY(I).S_PN;
          s_picklist_status := T_DW_SEL_CANCEL_ARRAY(i).s_status;

          IF S_PICKLIST_STATUS <> 'TRANSFER' THEN
            DECLARE 
              CURSOR CUR_PD IS
              SELECT *
              FROM PICKLIST_DISTRIBUTION
              WHERE TRANSACTION = 'REQUIRE'
              AND PICKLIST = IL_PICKLIST
              AND PICKLIST_LINE = L_LINE;
              TYPE TT_PICKLIST_DISTRIBUTION IS TABLE OF PICKLIST_DISTRIBUTION%ROWTYPE;
              T_PICKLIST_DISTRIBUTION TT_PICKLIST_DISTRIBUTION := TT_PICKLIST_DISTRIBUTION();
              MS_PN PKG_TYPE_STRUCTURES.ST_PN;
              N_SQLCODE NUMBER;
              l_count number := 0;
            BEGIN
              OPEN CUR_PD;
              FETCH CUR_PD BULK COLLECT INTO T_PICKLIST_DISTRIBUTION;
              CLOSE CUR_PD;

              PICKLIST_DISTRIBUTION_AUDIT(il_picklist, l_line, 'CANCEL');

              MS_PN.n_PICKLIST := IL_PICKLIST;
              ms_pn.n_picklist_line := l_line;
              of_picklist_detail(ms_pn);

              begin
                SELECT "WO_TASK_CARD_PN"."PN",   
                    "WO_TASK_CARD_PN"."QTY_RESERVED"  
                 INTO s_task_card_pn,   
                    d_qty_reserved  
                 FROM "WO_TASK_CARD_PN",   
                    "PN_INTERCHANGEABLE"  
                WHERE ( "WO_TASK_CARD_PN"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
                    ( "WO_TASK_CARD_PN"."WO" = n_wo ) AND  
                    ( "WO_TASK_CARD_PN"."TASK_CARD" = S_TASK_CARD ) AND  
                    ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = S_PN );

                n_sqlcode := sqlcode;
              exception
              WHEN OTHERS THEN
                N_SQLCODE := SQLCODE;

                DECLARE
                  s_pn_main varchar2(100);
                BEGIN
                  SELECT "PN_INTERCHANGEABLE"."PN"
                  INTO s_pn_main
                  FROM "PN_INTERCHANGEABLE"
                  WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn;

                  SELECT "WO_TASK_CARD_PN"."PN",   
                      "WO_TASK_CARD_PN"."QTY_RESERVED"  
                   INTO s_task_card_pn,   
                      d_qty_reserved  
                   FROM "WO_TASK_CARD_PN",   
                      "PN_INTERCHANGEABLE"  
                  WHERE ( "WO_TASK_CARD_PN"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
                      (  "WO_TASK_CARD_PN"."WO" = n_wo ) AND  
                      ( "WO_TASK_CARD_PN"."TASK_CARD" = s_task_card ) AND  
                      ( "PN_INTERCHANGEABLE"."PN" = S_PN_MAIN )  AND 
                      ("WO_TASK_CARD_PN"."QTY_RESERVED") > 0  AND ROWNUM =1;

                  n_sqlcode := sqlcode;
                EXCEPTION
                WHEN OTHERS THEN
                  n_sqlcode := sqlcode;
                end;
              end;

              IF N_SQLCODE <> 100 THEN
                D_QTY_RESERVED := NVL(D_QTY_RESERVED, 0);
                D_QTY := NVL(D_QTY, 0);
                d_qty_reserved := d_qty_reserved - d_qty;

                If d_qty_reserved < 0 then d_qty_reserved := 0; end if;

                UPDATE "WO_TASK_CARD_PN"  
                SET "QTY_RESERVED" = d_qty_reserved,
                       "MODIFIED_DATE" = dt_today
                WHERE ( "WO_TASK_CARD_PN"."WO" = n_wo ) AND  
                    ( "WO_TASK_CARD_PN"."TASK_CARD" = s_task_card ) AND  
                    ( "WO_TASK_CARD_PN"."PN" = s_task_card_pn );
              End If;

              if T_PICKLIST_DISTRIBUTION is not null and T_PICKLIST_DISTRIBUTION.count > 0 then
               gs_user := 'EMOBILITY' ; 
                UPDATE "PICKLIST_DISTRIBUTION"  
                set status = 'CANCEL',
                "MODIFIED_DATE" = dt_today ,
                 "MODIFIED_BY" = gs_user
                WHERE TRANSACTION = T_PICKLIST_DISTRIBUTION(1).TRANSACTION
                AND   PICKLIST = T_PICKLIST_DISTRIBUTION(1).PICKLIST
                AND   PICKLIST_LINE = T_PICKLIST_DISTRIBUTION(1).PICKLIST_LINE 
                and   DISTRIBUTION_LINE = T_PICKLIST_DISTRIBUTION(1).DISTRIBUTION_LINE;
            
           
                picklist_header_audit(il_picklist, 'CANCEL', gs_user);
                UPDATE  "PICKLIST_HEADER"  
                 set status = 'CANCEL',
                "MODIFIED_DATE" = dt_today ,
                "MODIFIED_BY" = gs_user
                WHERE "PICKLIST_HEADER"."PICKLIST" = il_picklist;
            
              END IF;
            END;
          END IF;
        end;
      end loop;
    end if;

  end W_WO_RESERV_CANCEL_SUB_WO_LOOP;

  PROCEDURE W_WO_REQ_CANCELATION_EU(n_wo number, s_task_card varchar2 default null)
  AS
  BEGIN
--    --UE_LOAD_ALL_WO
    IF TRIM(S_TASK_CARD) IS NOT NULL THEN
      W_WO_REQ_CANCEL_EU_SUB_WO_LOOP(N_WO, TRIM(S_TASK_CARD));
    ELSE
      DECLARE
        cursor CUR_WO_SUB is
        SELECT "WO"."WO"
        FROM "WO"
        START WITH "WO"."WO" = n_WO
        CONNECT BY PRIOR "WO"."WO" = "WO"."NH_WO";
        TYPE TT_SUB_WO IS TABLE OF NUMBER;
        t_sub_wo TT_SUB_WO := TT_SUB_WO();
      BEGIN
        OPEN CUR_WO_SUB;
        FETCH CUR_WO_SUB BULK COLLECT INTO T_SUB_WO;
        CLOSE CUR_WO_SUB;

        IF T_SUB_WO IS NOT NULL AND T_SUB_WO.COUNT > 0 THEN
          FOR I IN T_SUB_WO.FIRST..T_SUB_WO.LAST
          LOOP
            W_WO_REQ_CANCEL_EU_SUB_WO_LOOP(T_SUB_WO(i));
          end loop;
        END IF;

      end;
    end if;
  end W_WO_REQ_CANCELATION_EU;

  PROCEDURE W_WO_RESERV_CANCELATION_EU(N_WO NUMBER, s_task_card in out nocopy varchar2, gs_user in out nocopy varchar2)
  as
  BEGIN
    
    P_USER := gs_user;
    --UE_LOAD_ALL_WO
    if TRIM(S_TASK_CARD) is not null then
      W_WO_RESERV_CANCEL_SUB_WO_LOOP(N_WO, S_TASK_CARD,gs_user);
    ELSE
      DECLARE
        cursor CUR_WO_SUB is
        SELECT "WO"."WO"
        FROM "WO"
        START WITH "WO"."WO" = n_WO
        CONNECT BY PRIOR "WO"."WO" = "WO"."NH_WO";
        TYPE TT_SUB_WO IS TABLE OF NUMBER;
        t_sub_wo TT_SUB_WO := TT_SUB_WO();
      BEGIN
        OPEN CUR_WO_SUB;
        FETCH CUR_WO_SUB BULK COLLECT INTO T_SUB_WO;
        CLOSE CUR_WO_SUB;

        IF T_SUB_WO IS NOT NULL AND T_SUB_WO.COUNT > 0 THEN
          FOR I IN T_SUB_WO.FIRST..T_SUB_WO.LAST
          LOOP
            W_WO_RESERV_CANCEL_SUB_WO_LOOP(T_SUB_WO(I), s_task_card, gs_user);
          end loop;
        END IF;

      end;
    end if;
  end w_wo_reserv_cancelation_eu;

  PROCEDURE WF_REQUISITION_CANCELATION(n_wo number, s_task_card varchar2 default null)
  AS
  BEGIN
    w_wo_req_cancelation_eu(n_wo, TRIM(S_TASK_CARD));
  end WF_REQUISITION_CANCELATION;

  PROCEDURE WF_PICKLIST_RESERVATION_CANCEL(n_wo number, s_task_card in out nocopy varchar2, gs_user in out nocopy varchar2)
  AS
  BEGIN
    W_WO_RESERV_CANCELATION_EU(n_wo, S_TASK_CARD, gs_user);
  end WF_PICKLIST_RESERVATION_CANCEL;

  FUNCTION WF_LOAD_PN_FOR_RESERVE(N_WO NUMBER, S_AC VARCHAR2, S_TASK_CARD VARCHAR2 DEFAULT NULL ,
   S_TASK_CARD_PN VARCHAR2 DEFAULT NULL ,  S_TASK_CARD_SN VARCHAR2 DEFAULT NULL) RETURN wo_tc_pn_array
  AS
    S_ORIGINAL VARCHAR2(32000);
    s_and VARCHAR2(32000);
    s_file VARCHAR2(32000);
    s_fld VARCHAR2(32000);
    s_select VARCHAR2(32000);
    S_COMPARE VARCHAR2(32000);
    s_where VARCHAR2(32000) := '  ';
    S_MOD VARCHAR2(32000);
    ms_wo wo%rowtype;
    T_DW_SEL wo_tc_pn_array;
    cur_query refCursor;
  BEGIN

    SELECT *
    INTO MS_WO
    FROM WO
    where wo = n_wo;
    S_ORIGINAL := ' SELECT "WO_TASK_CARD_PN"."WO",   
                           "WO_TASK_CARD_PN"."TASK_CARD",   
                           "WO_TASK_CARD_PN"."PN",   
                           "WO_TASK_CARD_PN"."QTY",   
                           "WO_TASK_CARD_PN"."QTY_RESERVED",   
                           "WO_TASK_CARD_PN"."MODIFIED_BY",   
                           "WO_TASK_CARD_PN"."MODIFIED_DATE",   
                           "WO_TASK_CARD_PN"."RESERVE",   
                           "WO_TASK_CARD_PN"."TASK_CARD_PN",   
                           "WO_TASK_CARD_PN"."TASK_CARD_PN_SN",   
                           "WO_TASK_CARD_PN"."AC",   
                           "WO_TASK_CARD_PN"."PICKLIST_PROCESSED"  
                      FROM "WO_TASK_CARD_PN",   
                           "WO_TASK_CARD"  
                     WHERE ( "WO_TASK_CARD_PN"."WO" = "WO_TASK_CARD"."WO" ) and  
                           ( "WO_TASK_CARD_PN"."TASK_CARD" = "WO_TASK_CARD"."TASK_CARD" ) and  
                           ( "WO_TASK_CARD_PN"."TASK_CARD_PN" = "WO_TASK_CARD"."PN" ) and  
                           ( "WO_TASK_CARD_PN"."TASK_CARD_PN_SN" = "WO_TASK_CARD"."PN_SN" ) and  
                           ( "WO_TASK_CARD_PN"."AC" = "WO_TASK_CARD"."AC" )  and "WO_TASK_CARD_PN"."RESERVE" = ''YES'' ';
    S_COMPARE := ' = ';
    S_AND := ' AND ';
    S_FILE := 'WO_TASK_CARD_PN';
    S_FLD := 'WO';
    S_SELECT := N_WO;

    S_WHERE :=  S_WHERE || S_AND || S_FILE || '.' || S_FLD ||  S_COMPARE || S_SELECT;
    S_WHERE :=  S_WHERE || S_AND || 'WO_TASK_CARD.STATUS not in (''CLOSED'', ''CANCEL'')';

    IF TRIM(S_TASK_CARD) IS NOT NULL THEN
      S_FLD := 'TASK_CARD';
      S_SELECT := '''' || S_TASK_CARD || '''';
      S_WHERE :=  S_WHERE || S_AND || S_FILE || '.' || S_FLD ||  S_COMPARE || S_SELECT;

--      S_FLD := 'AC';
--      S_SELECT := '''' || S_AC || '''';
--      S_WHERE :=  S_WHERE || S_AND || S_FILE || '.' || S_FLD ||  S_COMPARE || S_SELECT;

      S_FLD := 'TASK_CARD_PN';
      IF(TRIM(s_task_card_pn) IS NULL)
      then
       S_SELECT := '''' || LPAD(' ', 35) || '''';
      else
      S_SELECT := '''' || s_task_card_pn || '''';
      end if;
      S_WHERE :=  S_WHERE || S_AND || S_FILE || '.' || S_FLD ||  S_COMPARE || S_SELECT;

      S_FLD := 'TASK_CARD_PN_SN';
      IF(TRIM(s_task_card_sn) IS NULL)
      THEN
      S_SELECT := '''' || LPAD(' ', 35) || '''';
      ELSE
       S_SELECT := '''' || s_task_card_sn || '''';
      END IF;
      S_WHERE :=  S_WHERE || S_AND || S_FILE || '.' || S_FLD ||  S_COMPARE || S_SELECT;
    end if;

    S_WHERE :=  S_WHERE || ' order by WO_TASK_CARD_PN.TASK_CARD asc ';

    S_MOD := s_original || S_WHERE;
    plog.debug(s_mod);
    OPEN CUR_QUERY FOR S_MOD;
    FETCH CUR_QUERY BULK COLLECT INTO T_DW_SEL;
    close CUR_QUERY;
     plog.debug('WF_LOAD_PN_FOR_RESERVE count returned: ' || T_DW_SEL.count);
    return T_DW_SEL;

  end WF_LOAD_PN_FOR_RESERVE;



  FUNCTION WF_LOAD_DEFECT_PN_FOR_RESERVE(N_WO NUMBER, S_AC VARCHAR2, S_DEFECT VARCHAR2 DEFAULT NULL ,
   S_DEFECT_TYPE VARCHAR2 DEFAULT NULL ,  l_defect_item number DEFAULT 0) RETURN defect_pn_array
  AS
    S_ORIGINAL VARCHAR2(32000);
    s_and VARCHAR2(32000);
    s_file VARCHAR2(32000);
    s_fld VARCHAR2(32000);
    s_select VARCHAR2(32000);
    S_COMPARE VARCHAR2(32000);
    s_where VARCHAR2(32000) := '  ';
    S_MOD VARCHAR2(32000);

    T_DW_SEL_DEFECT defect_pn_array;
    cur_query refCursor;
  BEGIN


    S_ORIGINAL := ' SELECT "DEFECT_REPORT_PN"."DEFECT",   
                           "DEFECT_REPORT_PN"."DEFECT_TYPE",   
                           "DEFECT_REPORT_PN"."DEFECT_ITEM",
                           "DEFECT_REPORT_PN"."PN",   
                           "DEFECT_REPORT_PN"."QTY",                                 
                           "DEFECT_REPORT_PN"."MODIFIED_BY",   
                           "DEFECT_REPORT_PN"."MODIFIED_DATE",   
                           "DEFECT_REPORT_PN"."RESERVED" , ' || N_WO || ' , ''' || S_AC || '''  ,           

                            "DEFECT_REPORT_PN"."PICKLIST_PROCESSED" , 
                             "DEFECT_REPORT_PN"."QTY_RESERVED" 
                      FROM "DEFECT_REPORT_PN"                            
                     where  "DEFECT_REPORT_PN"."RESERVED" = ''YES''  and "DEFECT_REPORT_PN"."DEFECT" = ''' || s_defect || '''   
                            and "DEFECT_REPORT_PN"."DEFECT_TYPE" = ''' || s_defect_type || '''  
                            and "DEFECT_REPORT_PN"."DEFECT_ITEM" = ' || l_defect_item   ;    




    S_MOD := s_original ;

    plog.debug (s_original);

    OPEN CUR_QUERY FOR S_MOD;
    FETCH CUR_QUERY BULK COLLECT INTO T_DW_SEL_DEFECT;
    close CUR_QUERY;

    return T_DW_SEL_DEFECT;

  end WF_LOAD_DEFECT_PN_FOR_RESERVE;

  FUNCTION WF_LOAD_picklist_parts (n_id number, N_WO NUMBER, S_AC VARCHAR2) RETURN defect_pn_array
  AS
    S_ORIGINAL VARCHAR2(32000);
    s_and VARCHAR2(32000);
    s_file VARCHAR2(32000);
    s_fld VARCHAR2(32000);
    s_select VARCHAR2(32000);
    S_COMPARE VARCHAR2(32000);
    s_where VARCHAR2(32000) := '  ';
    S_MOD VARCHAR2(32000);

    T_DW_SEL_DEFECT defect_pn_array;
    cur_query refCursor;
  BEGIN


    S_ORIGINAL := ' SELECT "EMOBILITY_PICKLIST_QUEUE"."SN",   
                           ''no dfect'',   
                           "EMOBILITY_PICKLIST_QUEUE"."BATCH_NO",
                           "EMOBILITY_PICKLIST_QUEUE"."PN",   
                           "EMOBILITY_PICKLIST_QUEUE"."QTY",                                 
                            ''EMOBILE'',   
                           sysdate,   
                           ''N'' , ' || NVL(N_WO,0) || ' , ''' || S_AC || '''  ,                              
                           ''N'' , 
                           0 
                      FROM "EMOBILITY_PICKLIST_QUEUE"                            
                     where  "EMOBILITY_PICKLIST_QUEUE"."TANSACTION_ID" = ' || to_char(n_id)    ;    




    S_MOD := s_original ;

    plog.debug (s_original);

    OPEN CUR_QUERY FOR S_MOD;
    FETCH CUR_QUERY BULK COLLECT INTO T_DW_SEL_DEFECT;
    close CUR_QUERY;

    return T_DW_SEL_DEFECT;

  end WF_LOAD_picklist_parts;

  FUNCTION GF_ETOPS_VALIDATION(l_wo number, s_pn varchar2) RETURN VARCHAR2
  AS
    s_return varchar2(100);
  BEGIN
    begin
      SELECT  '1'
       INTO s_return
            FROM "WO_TASK_CARD_PN",   
               "WO" W,   
               "PN_MASTER" PM,   
               "PN_INTERCHANGEABLE",   
               "WO_TASK_CARD",   
               "AC_MASTER",   
               "PN_INVENTORY_DETAIL"  
         WHERE ( "WO_TASK_CARD_PN"."WO" = W."WO" ) and  
               ( "PN_INTERCHANGEABLE"."PN" = PM."PN" ) and  
               ( "WO_TASK_CARD_PN"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
               ( "WO_TASK_CARD"."WO" = W."WO" ) and  
               ( "WO_TASK_CARD"."TASK_CARD" = "WO_TASK_CARD_PN"."TASK_CARD" ) and  
               ( "WO_TASK_CARD"."AC" = "WO_TASK_CARD_PN"."AC" ) and  
               ( "WO_TASK_CARD"."PN" = "WO_TASK_CARD_PN"."TASK_CARD_PN" ) and  
               ( "WO_TASK_CARD"."PN_SN" = "WO_TASK_CARD_PN"."TASK_CARD_PN_SN" ) and  
               ( W."AC" = "AC_MASTER"."AC" ) and  
               ( "PN_INVENTORY_DETAIL"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
               ( W."LOCATION" = "PN_INVENTORY_DETAIL"."LOCATION" ) and  
               ( NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'NO' ) AND  
               ( "AC_MASTER"."ETOPS" is not NULL ) AND  
               ( "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0  )   
                AND PM."PN" NOT IN (SELECT DISTINCT "PN_INTERCHANGEABLE"."PN" FROM "PN_INTERCHANGEABLE", "PN_INVENTORY_DETAIL" 
                                                WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE"= "PN_INVENTORY_DETAIL"."PN" AND (NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'YES'  or NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'ALL')
                                                            AND "PN_INTERCHANGEABLE"."PN" = PM."PN" AND "PN_INVENTORY_DETAIL"."LOCATION" = W."LOCATION" AND "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0)
             AND W."WO" = L_WO AND "WO_TASK_CARD_PN"."PN" = S_PN;
    EXCEPTION
    WHEN OTHERS THEN
      s_return := null;
    END;  

    if nvl(trim(s_return), ' ') <> ' ' then return s_return; end if;

    s_return := null;

    begin
      SELECT DISTINCT '2'
       INTO s_return
            FROM "WO_TASK_CARD_PN",   
               "WO" W,   
               "PN_MASTER" PM,   
               "PN_INTERCHANGEABLE",   
               "WO_TASK_CARD",   
               "AC_MASTER"
         WHERE ( "WO_TASK_CARD_PN"."WO" = W."WO" ) and  
               ( "PN_INTERCHANGEABLE"."PN" = PM."PN" ) and  
               ( "WO_TASK_CARD_PN"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
               ( "WO_TASK_CARD"."WO" = W."WO" ) and  
               ( "WO_TASK_CARD"."TASK_CARD" = "WO_TASK_CARD_PN"."TASK_CARD" ) and  
               ( "WO_TASK_CARD"."AC" = "WO_TASK_CARD_PN"."AC" ) and  
               ( "WO_TASK_CARD"."PN" = "WO_TASK_CARD_PN"."TASK_CARD_PN" ) and  
               ( "WO_TASK_CARD"."PN_SN" = "WO_TASK_CARD_PN"."TASK_CARD_PN_SN" ) and  
               ( W."AC" = "AC_MASTER"."AC" ) and  
               ( NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'NO' ) AND  
               ( "AC_MASTER"."ETOPS" is not NULL ) AND  
               ("WO_TASK_CARD_PN"."PN" NOT IN (SELECT DISTINCT "PN" FROM "PN_INVENTORY_DETAIL"  WHERE "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0  AND "PN_INVENTORY_DETAIL"."LOCATION" = W."LOCATION")   )
                AND PM."PN" NOT IN (SELECT DISTINCT "PN_INTERCHANGEABLE"."PN" FROM "PN_INTERCHANGEABLE", "PN_INVENTORY_DETAIL" 
                                                WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE"= "PN_INVENTORY_DETAIL"."PN" AND (NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'YES'  or NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'ALL')  
                                                            AND "PN_INTERCHANGEABLE"."PN" = PM."PN" AND "PN_INVENTORY_DETAIL"."LOCATION" = W."LOCATION" AND "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0) 
        AND W."WO" = l_wo AND "WO_TASK_CARD_PN"."PN" = s_pn;
    EXCEPTION
    WHEN OTHERS THEN
      S_RETURN := NULL;
    END;

    if nvl(s_return, ' ') <> ' ' then return s_return; end if;

    s_return := null;

    begin
      SELECT DISTINCT '3'
       INTO s_return
            FROM "WO_TASK_CARD_PN",   
               "WO" W,   
               "PN_MASTER" PM,   
               "PN_INTERCHANGEABLE",   
               "WO_TASK_CARD",   
               "AC_MASTER",   
               "PN_INVENTORY_DETAIL"  
         WHERE ( "WO_TASK_CARD_PN"."WO" = W."WO" ) and  
               ( "PN_INTERCHANGEABLE"."PN" = PM."PN" ) and  
               ( "WO_TASK_CARD_PN"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
               ( "WO_TASK_CARD"."WO" = W."WO" ) and  
               ( "WO_TASK_CARD"."TASK_CARD" = "WO_TASK_CARD_PN"."TASK_CARD" ) and  
               ( "WO_TASK_CARD"."AC" = "WO_TASK_CARD_PN"."AC" ) and  
               ( "WO_TASK_CARD"."PN" = "WO_TASK_CARD_PN"."TASK_CARD_PN" ) and  
               ( "WO_TASK_CARD"."PN_SN" = "WO_TASK_CARD_PN"."TASK_CARD_PN_SN" ) and  
               ( W."AC" = "AC_MASTER"."AC" ) and  
               ( "PN_INVENTORY_DETAIL"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
               ( W."LOCATION" = "PN_INVENTORY_DETAIL"."LOCATION" ) and  
               ( NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'NO' ) AND  
               ( "AC_MASTER"."ETOPS" is not NULL ) AND  
               ( "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0  )   
                  AND PM."PN" IN (SELECT "PN_INTERCHANGEABLE"."PN" FROM "PN_EFFECTIVITY_DISTRIBUTION", "PN_INTERCHANGEABLE"
                WHERE  "PN_INTERCHANGEABLE"."PN" =  PM."PN" AND "PN_EFFECTIVITY_DISTRIBUTION"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" AND (NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'YES'  or NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'ALL') AND
                    "PN_EFFECTIVITY_DISTRIBUTION"."AC" = W."AC")  AND
          ("WO_TASK_CARD_PN"."PN"  IN (SELECT DISTINCT "PN" FROM "PN_INVENTORY_DETAIL"  WHERE "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0  AND "PN_INVENTORY_DETAIL"."LOCATION" = W."LOCATION")   )
               AND PM."PN" IN (SELECT DISTINCT "PN_INTERCHANGEABLE"."PN" FROM "PN_INTERCHANGEABLE", "PN_INVENTORY_DETAIL" 
                                                WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE"= "PN_INVENTORY_DETAIL"."PN" AND (NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'YES'  or NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'ALL') 
                                                            AND "PN_INTERCHANGEABLE"."PN" = PM."PN" AND "PN_INVENTORY_DETAIL"."LOCATION" = W."LOCATION" AND "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0)

      AND W."WO" = l_wo AND "WO_TASK_CARD_PN"."PN" = s_pn;
    EXCEPTION
    WHEN OTHERS THEN
      S_RETURN := NULL;
    END;

    if nvl(s_return, ' ') <> ' ' then return s_return; end if;

    s_return := null;

    begin
        SELECT DISTINCT '4'
         INTO s_return
              FROM "WO_TASK_CARD_PN",   
                 "WO" W,   
                 "PN_MASTER" PM,   
                 "PN_INTERCHANGEABLE",   
                 "WO_TASK_CARD",   
                 "AC_MASTER"
           WHERE ( "WO_TASK_CARD_PN"."WO" = W."WO" ) and  
                 ( "PN_INTERCHANGEABLE"."PN" = PM."PN" ) and  
                 ( "WO_TASK_CARD_PN"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
                 ( "WO_TASK_CARD"."WO" = W."WO" ) and  
                 ( "WO_TASK_CARD"."TASK_CARD" = "WO_TASK_CARD_PN"."TASK_CARD" ) and  
                 ( "WO_TASK_CARD"."AC" = "WO_TASK_CARD_PN"."AC" ) and  
                 ( "WO_TASK_CARD"."PN" = "WO_TASK_CARD_PN"."TASK_CARD_PN" ) and  
                 ( "WO_TASK_CARD"."PN_SN" = "WO_TASK_CARD_PN"."TASK_CARD_PN_SN" ) and  
                 ( W."AC" = "AC_MASTER"."AC" ) and  
                 ( NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'NO' ) AND  
                 ( "AC_MASTER"."ETOPS" is not NULL ) AND  
                 ("WO_TASK_CARD_PN"."PN" NOT IN (SELECT DISTINCT "PN" FROM "PN_INVENTORY_DETAIL"  WHERE "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0  AND "PN_INVENTORY_DETAIL"."LOCATION" = W."LOCATION")   )
                 AND PM."PN" IN (SELECT DISTINCT "PN_INTERCHANGEABLE"."PN" FROM "PN_INTERCHANGEABLE", "PN_INVENTORY_DETAIL" 
                                                  WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE"= "PN_INVENTORY_DETAIL"."PN" AND (NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'YES'  or NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'NO') = 'ALL')  
                                                              AND "PN_INTERCHANGEABLE"."PN" = PM."PN" AND "PN_INVENTORY_DETAIL"."LOCATION" = W."LOCATION" AND "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0)


            AND W."WO" = L_WO AND "WO_TASK_CARD_PN"."PN" = S_PN;
     EXCEPTION
    WHEN OTHERS THEN
      S_RETURN := NULL;
    END;

    return s_return;
  end GF_ETOPS_VALIDATION;

  FUNCTION DF_GET_INTERCHANGE_EFFECTIVE(s_pn varchar2, s_ac varchar2, l_wo number) RETURN VARCHAR2
  AS
    S_PN_INTER VARCHAR2(100);
    s_location VARCHAR2(100);
  BEGIN
    SELECT "WO"."LOCATION"
    INTO s_location
    FROM "WO"
    WHERE "WO"."WO" = l_wo;

    begin
      SELECT DISTINCT PI."PN_INTERCHANGEABLE"
      INTO s_pn_inter
      FROM "PN_INTERCHANGEABLE"  PI,  "PN_EFFECTIVITY_DISTRIBUTION", "PN_INVENTORY_DETAIL" 
      WHERE PI."PN" = (SELECT "PN_INTERCHANGEABLE"."PN" FROM "PN_INTERCHANGEABLE" WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn )
      AND PI."PN_INTERCHANGEABLE" <> s_pn AND (NVL(PI."ETOPS_FLAG",'NO') = 'YES'  or NVL(PI."ETOPS_FLAG",'NO') = 'ALL')
      AND "PN_EFFECTIVITY_DISTRIBUTION"."PN" = PI."PN_INTERCHANGEABLE"  AND "PN_EFFECTIVITY_DISTRIBUTION"."AC" = s_ac
      AND "PN_INVENTORY_DETAIL"."PN" = PI."PN_INTERCHANGEABLE" AND  "PN_INVENTORY_DETAIL"."QTY_AVAILABLE" > 0  AND 
              "PN_INVENTORY_DETAIL"."LOCATION" = S_LOCATION 
      AND ROWNUM =1;
    EXCEPTION
    WHEN OTHERS THEN
      s_pn_inter := null;
    END;  
    if nvl(s_pn_inter, ' ') = ' ' then s_pn_inter := s_pn; end if;

    return s_pn_inter;
  end DF_GET_INTERCHANGE_EFFECTIVE;

  function WF_NEW(IS_TRAN in out nocopy varchar2, IL_PICKLIST in out nocopy number, is_pn in out nocopy varchar2, IS_TASK_CARD in out nocopy varchar2, id_qty in out nocopy number, GS_USER varchar2 default 'TRAXIFACE', n_batch in out nocopy number, s_sn in out nocopy varchar2) return picklist_distribution%rowtype
  AS
    DW_EU PICKLIST_DISTRIBUTION%ROWTYPE;
    l_line number;
  BEGIN
    IS_TRAN := 'NEW';
    dw_eu.Created_date := pkg_application_function.currentdatetime;
    DW_EU.CREATED_BY := GS_USER;
    dw_eu.Modified_date := dw_eu.Created_date;
    DW_EU.MODIFIED_BY := GS_USER;

    l_line := 0;

    begin
      SELECT MAX("PICKLIST_DISTRIBUTION"."PICKLIST_LINE")  
      INTO l_line  
      FROM "PICKLIST_DISTRIBUTION"  
      WHERE ( "PICKLIST_DISTRIBUTION"."TRANSACTION" = 'REQUIRE' ) AND  
        ( "PICKLIST_DISTRIBUTION"."PICKLIST" = IL_PICKLIST );
    EXCEPTION
    WHEN OTHERS THEN
      l_line := 1;
    end;
    IF NVL(L_LINE, 0) <= 0 THEN
      l_line := 1;
    ELSE
      L_LINE := L_LINE + 1;
    end if;

    dw_eu.picklist_line := l_line;
    dw_eu.picklist := il_picklist;
    dw_eu.pn := is_pn;
    DW_EU.TASK_CARD := IS_TASK_CARD;
    dw_eu.qty := id_qty;
    dw_eu."BATCH" := n_batch;
    dw_eu."SN" := s_sn;

    return DW_EU;

  end wf_new;

  FUNCTION GF_GSE_PN_EFFECTIVITY_EDIT (MS_PN IN OUT NOCOPY PKG_TYPE_STRUCTURES.ST_PN, OPTIONAL IN OUT NOCOPY NUMBER) RETURN NUMBER
  AS
    s_return VARCHAR2(100);
    s_gse VARCHAR2(100);
    s_tpw VARCHAR2(100);
    s_etops_code VARCHAR2(100);
    s_etops_flag VARCHAR2(100);
    s_etops VARCHAR2(100);
    S_TOOL_CONTROL_ITEM VARCHAR2(100);
  BEGIN
    MS_PN.S_MESSAGE_ERROR1 := NULL;
    ms_pn.s_message_error2 := null;
    MS_PN.S_MESSAGE_TYPE := NULL;
    MS_PN.S_MESSAGE_ANSWER := NULL;

    If optional = 0  and trim(ms_pn.s_pn) is null Then Return 0; end if;

    begin
      SELECT "PN_INTERCHANGEABLE"."ETOPS",   
           "PN_INTERCHANGEABLE"."ETOPS_FLAG",   
           "PN_MASTER"."TOOL_CONTROL_ITEM"  
      INTO s_etops_code,   
           s_etops_flag,
           s_tool_control_item
      FROM "PN_MASTER",   
           "PN_INTERCHANGEABLE"  
      WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) and  
           ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = MS_PN.S_PN );
    exception
    WHEN OTHERS THEN
      S_ETOPS_CODE := null;
      S_ETOPS_FLAG := null;
      S_TOOL_CONTROL_ITEM := null;
    END;

    If s_tool_control_item = 'Y' Then Return 0; end if;

    IF MS_PN.N_WO > 0 THEN
     begin 
      SELECT "WO"."AC",   
           "WO"."THIRD_PARTY_WO" 
      INTO s_gse,   
           s_tpw  
      FROM "WO"  
      WHERE "WO"."WO" = ms_pn.n_wo;

     EXCEPTION
     WHEN OTHERS THEN
      MS_PN.S_MESSAGE_ERROR1 :='W/O';
      MS_PN.S_MESSAGE_ERROR2 := 'Not found.';
      MS_PN.S_MESSAGE_TYPE  := 'StopSign!';
      RETURN 1 ;
     End;
    ELSE
    S_GSE :=  MS_PN.S_AC;
    S_TPW := 'N';
    End If;

    If nvl(s_tpw, 'N') = 'N' and trim(s_gse) is not null Then

      begin
        SELECT "PN_EFFECTIVITY_DISTR_GSE"."SELECT"  
          INTO s_return  
          FROM "PN_EFFECTIVITY_DISTR_GSE",   
               "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_A",   
               "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_B"  
         WHERE ( "PN_EFFECTIVITY_DISTR_GSE"."PN" = "PN_INTERCHANGEABLE_A"."PN_INTERCHANGEABLE" ) and  
               ( "PN_INTERCHANGEABLE_A"."PN" = "PN_INTERCHANGEABLE_B"."PN" ) and  
               ( ( "PN_EFFECTIVITY_DISTR_GSE"."GSE" = S_GSE ) AND  
               ( "PN_INTERCHANGEABLE_B"."PN_INTERCHANGEABLE" = ms_pn.s_pn ) );

      EXCEPTION
      WHEN OTHERS THEN
            MS_PN.S_MESSAGE_ERROR1 :='P/N Effectivity';
          MS_PN.S_MESSAGE_ERROR2 := 'Not valid for GSE.';
          MS_PN.S_MESSAGE_TYPE  := 'StopSign!'	;
          RETURN 1	;				
      END;
    End If;

    return 0;
  end GF_GSE_PN_EFFECTIVITY_EDIT;

  FUNCTION GF_PN_EFFECTIVITY_EDIT(MS_PN in out nocopy PKG_TYPE_STRUCTURES.ST_PN, optional in out nocopy number) RETURN NUMBER
  AS
    S_RETURN VARCHAR2(100);
    S_AC VARCHAR2(100);
    S_TPW VARCHAR2(100);
    S_ETOPS_CODE VARCHAR2(100);
    S_ETOPS_FLAG VARCHAR2(100);
    S_ETOPS VARCHAR2(100);
    S_TOOL_CONTROL_ITEM VARCHAR2(100);
    S_INVENTORY_TYPE VARCHAR2(100);
    S_INDICATOR VARCHAR2(100);
    S_PN_MAIN VARCHAR2(100);
    S_ETOPS_DOWNGRADE VARCHAR2(100);
    S_ETOPS_WARNING VARCHAR2(100);
    S_AC_OWNERSHIP_CONTROL VARCHAR2(100);
    L_AC_ETOPS NUMBER;
    l_pn_etops number;
    n_SQLCODE number;
  BEGIN

    MS_PN.S_MESSAGE_ERROR1 := NULL;
    ms_pn.s_message_error2 := null;
    MS_PN.S_MESSAGE_TYPE := NULL;
    ms_pn.s_message_answer := null;

    IF TRIM(MS_PN.S_ETOPS_CHECK) IS NULL THEN MS_PN.S_ETOPS_CHECK := 'YES'; END IF;
    If optional = 0  and trim(ms_pn.s_pn) is null Then Return 0; end if;

    begin
    SELECT "PN_INTERCHANGEABLE"."ETOPS",   
             "PN_INTERCHANGEABLE"."ETOPS_FLAG",   
             "PN_MASTER"."TOOL_CONTROL_ITEM",
        "PN_MASTER"."INVENTORY_TYPE",
        NVL("PN_MASTER"."EFFECTIVITY_PN_INTERCHANGEABLE",'NO') ,
        "PN_INTERCHANGEABLE"."PN"
        INTO s_etops_code,   
             S_ETOPS_FLAG,
             S_TOOL_CONTROL_ITEM,
             s_inventory_type,
             s_indicator,
             s_pn_main
        FROM "PN_MASTER",   
             "PN_INTERCHANGEABLE"  
       WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) and  
             ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = MS_PN.S_PN );
    exception
    WHEN OTHERS THEN
      S_ETOPS_CODE := null;
      S_ETOPS_FLAG := null;
      S_TOOL_CONTROL_ITEM := null;
      S_INVENTORY_TYPE := null;
      S_INDICATOR := null;
      s_pn_main := null;
    end;

    IF S_TOOL_CONTROL_ITEM = 'Y' THEN RETURN 0; END IF;
    IF S_INVENTORY_TYPE = 'GENERAL' THEN RETURN 0; END IF;
    If s_inventory_type = 'GSE' Then Return gf_gse_pn_effectivity_edit(ms_pn, optional); end if;

    s_etops_warning := pkg_application_function.config_flag('ETOPS');

    IF NVL(MS_PN.N_WO, 0) > 0 THEN
      begin
        SELECT "WO"."AC",   
               "WO"."THIRD_PARTY_WO" 
        INTO s_ac,   
             s_tpw  
        FROM "WO"  
        WHERE "WO"."WO" = MS_PN.N_WO;
      EXCEPTION
      WHEN OTHERS THEN
        MS_PN.S_MESSAGE_ERROR1 :='W/O';
        MS_PN.S_MESSAGE_ERROR2 := 'Not found.';
        MS_PN.S_MESSAGE_TYPE  := 'StopSign!';
        RETURN 1 ;
      End;
    Else
      IF OPTIONAL = 2 OR OPTIONAL = 3 THEN
        s_ac :=  ms_pn.s_ac;
      ELSE
        s_ac :=  ms_pn.s_ac;
      END IF;
      S_TPW := 'N';
    End If;

    If s_tpw =  'Y' Then

      IF TRIM(S_AC) IS NOT NULL THEN
        begin
          SELECT "AC_MASTER"."AC_OWNERSHIP_CONTROL"  
            INTO   s_ac_ownership_control  
            FROM "AC_MASTER"  
           WHERE "AC_MASTER"."AC" = s_ac;

          IF TRIM(S_AC_OWNERSHIP_CONTROL) IS NULL THEN S_AC_OWNERSHIP_CONTROL := 'OK'; END IF;
          IF S_AC_OWNERSHIP_CONTROL  <> 'TPO' THEN S_TPW :=  'N'; end if;
        EXCEPTION
        WHEN OTHERS THEN
          null;
        end;
      END IF;
    End If;

    If nvl(s_tpw, 'N') = 'N' and trim(s_ac) is not null Then

      IF S_INDICATOR = 'YES' THEN

        begin
        SELECT "PN_EFFECTIVITY_DISTRIBUTION"."SELECT"  
         INTO s_return  
         FROM "PN_EFFECTIVITY_DISTRIBUTION"  
        WHERE ( "PN_EFFECTIVITY_DISTRIBUTION"."AC" = s_ac ) AND  
            ( "PN_EFFECTIVITY_DISTRIBUTION"."PN" = MS_PN.S_PN );
        EXCEPTION
        WHEN OTHERS THEN
          n_SQLCODE := sqlcode;
          s_return := null;
        end;
      Else

        begin
         SELECT "PN_EFFECTIVITY_DISTRIBUTION"."SELECT" 
           INTO s_return 
           FROM "PN_EFFECTIVITY_DISTRIBUTION"
        WHERE  "PN_EFFECTIVITY_DISTRIBUTION"."PN" =  s_pn_main AND
               "PN_EFFECTIVITY_DISTRIBUTION"."AC" = s_ac;	
        exception
        WHEN OTHERS THEN
          n_SQLCODE := sqlcode;
          s_return := null;
        END;

      End If;

      If n_SQLCODE = 100 Then

        n_SQLCODE := 0;

        IF S_ETOPS_WARNING = 'N' AND 	OPTIONAL = 2 THEN

          begin
            SELECT "AC_MASTER"."ETOPS",
                       NVL("AC_MASTER"."ETOPS_DOWNGRADE",'NO') 
            INTO s_etops,
                 s_etops_downgrade
            FROM "AC_MASTER"  
            WHERE "AC_MASTER"."AC" = S_AC;
          EXCEPTION
          WHEN OTHERS THEN
            S_ETOPS := NULL;
            s_etops_downgrade := null;
          END;

          If trim(s_etops) is not null Then optional := 1; end if;

        End If;


        If optional = 2  Then

          MS_PN.S_MESSAGE_ERROR1 :='Warning P/N';
          MS_PN.S_MESSAGE_ERROR2 := 'Not effective to A/C.';
          MS_PN.S_MESSAGE_TYPE  := 'Exclamation!';
          MS_PN.S_MESSAGE_ANSWER := 'OKCancel!';
          Return 1;

        Else

          MS_PN.S_MESSAGE_ERROR1 := 'P/N Effectivity';
          MS_PN.S_MESSAGE_ERROR2 := 'Not valid for A/C.';
          MS_PN.S_MESSAGE_TYPE  := 'StopSign!';
          Return 1;

        END IF;

      End If;

    End If;


    If ms_pn.s_etops_check <>  'YES' Then 
      IF S_ETOPS_WARNING  = 'Y' AND S_ETOPS_FLAG = 'NO' THEN
        MS_PN.S_MESSAGE_ERROR1 := 'ETOPS Not Authorized';
        MS_PN.S_MESSAGE_ERROR2 := 'This P/N is not authorized for ETOPS operation';
        MS_PN.S_MESSAGE_TYPE := 'Exclamation!';
      END IF;
      Return 0;
    End If;

    If nvl(s_tpw, 'N') = 'N' and trim(s_ac) is not null Then

      begin
        SELECT "AC_MASTER"."ETOPS",
                   NVL("AC_MASTER"."ETOPS_DOWNGRADE",'NO') 
        INTO s_etops,
             s_etops_downgrade
        FROM "AC_MASTER"  
        WHERE "AC_MASTER"."AC" = S_AC;
      exception
      WHEN OTHERS THEN
        S_ETOPS := NULL;
        s_etops_downgrade := null;
      END;

      If  trim(s_etops) is null Then
        If s_etops_flag = 'YES' Then

          MS_PN.S_MESSAGE_ERROR1 := 'Warning A/C';
          MS_PN.S_MESSAGE_ERROR2 := 'Does NOT require ETOPS rated P/N.';
          MS_PN.S_MESSAGE_TYPE := 'Exclamation!';
          RETURN 0;
        End if;

      Else

          If s_etops_downgrade = 'YES' Then s_etops_warning := 'Y'; end if;

          IF S_ETOPS_FLAG = 'NO' THEN
            IF S_ETOPS_WARNING = 'Y' THEN					
              MS_PN.S_MESSAGE_ERROR1 := 'Warning A/C';
              MS_PN.S_MESSAGE_ERROR2 := 'This P/N is not authorized for ETOPS operation';
              MS_PN.S_MESSAGE_TYPE := 'Exclamation!';
              Return 0;					
            ELSE
              MS_PN.S_MESSAGE_ERROR1 :='A/C';
              MS_PN.S_MESSAGE_ERROR2 := 'Requires ETOPS P/N.';
              MS_PN.S_MESSAGE_TYPE := 'StopSign!';
              RETURN 1;							
            End If;

          Elsif nvl(s_etops, ' ') <> nvl(s_etops_code, ' ') Then
            IF S_ETOPS_WARNING = 'Y' THEN
              MS_PN.S_MESSAGE_ERROR1 := 'Warning A/C';
              MS_PN.S_MESSAGE_ERROR2 := 'Requires ETOPS P/N.';
              MS_PN.S_MESSAGE_TYPE := 'Exclamation!';
              Return 0;
            ELSE
                begin
                  SELECT "SYSTEM_TRAN_CODE"."MEL_DAYS"  
                   INTO l_ac_etops  
                   FROM "SYSTEM_TRAN_CODE"  
                  WHERE ( "SYSTEM_TRAN_CODE"."SYSTEM_TRANSACTION" = 'ETOPS' ) AND  
                      ( "SYSTEM_TRAN_CODE"."SYSTEM_CODE" = S_ETOPS );
                EXCEPTION
                WHEN OTHERS THEN
                    l_ac_etops := 0;
                END;

                begin
                SELECT "SYSTEM_TRAN_CODE"."MEL_DAYS"  
                INTO l_pn_etops  
                FROM "SYSTEM_TRAN_CODE"  
                WHERE ( "SYSTEM_TRAN_CODE"."SYSTEM_TRANSACTION" = 'ETOPS' ) AND  
                  ( "SYSTEM_TRAN_CODE"."SYSTEM_CODE" = s_etops_code );
                EXCEPTION
                WHEN OTHERS THEN
                  l_pn_etops := 0;
                end;

                If l_ac_etops > l_pn_etops Then

                  MS_PN.S_MESSAGE_ERROR1 := 'A/C';
                  MS_PN.S_MESSAGE_ERROR2 := 'Requires ETOPS P/N or Comparable.';
                  MS_PN.S_MESSAGE_TYPE := 'StopSign!';
                  RETURN 1;

                END IF;
              END IF;
          END IF;
      END IF;
    END IF;
    RETURN 0;
  end GF_PN_EFFECTIVITY_EDIT;

  function GF_INVENTORY_AVAILABLE(DW_PN_INVENTORY_AVL IN OUT NOCOPY PKG_TYPE_STRUCTURES.DW_INVENTORY_TRAN_AVL, MS_PN IN OUT NOCOPY PKG_TYPE_STRUCTURES.ST_PN, IS_ORIGINAL IN OUT NOCOPY VARCHAR2,
                                  gs_company_multi in out nocopy varchar2, quarantine boolean default false) return number
  AS
    S_AND VARCHAR2(100) := ' and ';
    S_WHERE VARCHAR2(32000) := '  ';
    S_MOD VARCHAR2(32000);
    S_CUSTOMER VARCHAR2(100);
    S_PKQTYOWNER VARCHAR2(100);
    S_COMPANYMULTIPL VARCHAR2(100);
    d_qty number;
    S_RETURN VARCHAR2(100);
    S_BY_PASS VARCHAR2(100);
    cur_query refCursor;
  BEGIN

    If ms_pn.s_build_kit = 'YES' Then
      If trim(ms_pn.s_location) is not null then  
        S_WHERE := S_WHERE || S_AND || 'PN_INVENTORY_DETAIL.LOCATION ''' || ms_pn.s_location || ''''; 
      END IF;
    End If;

    IF MS_PN.S_ORDER_TYPE = 'S/O' THEN
      IF TRIM(MS_PN.S_PN) IS NOT NULL THEN  
        S_WHERE := S_WHERE || S_AND || 'PN_INVENTORY_DETAIL.PN = ''' || MS_PN.S_PN || '''';
      End If;
    ELSE
      IF TRIM(MS_PN.S_PN) IS NOT NULL THEN  
        S_WHERE := S_WHERE || S_AND || 'PN_INTERCHANGEABLE_B.PN_INTERCHANGEABLE = ''' || MS_PN.S_PN || '''';
      END IF;
    End If;

    IF trim(MS_PN.S_CONDITION) is not null THEN  
      S_WHERE := S_WHERE || S_AND || 'PN_INVENTORY_DETAIL.CONDITION = ''' || MS_PN.S_CONDITION || '''';
    End If;


    IF TRIM(MS_PN.S_SN) IS NOT NULL THEN  
      S_WHERE := S_WHERE || S_AND || 'PN_INVENTORY_DETAIL.SN = ''' || MS_PN.S_SN || '''';
    End If;

    IF NVL(MS_PN.n_BATCH, 0) > 0 THEN  
      S_WHERE := S_WHERE || S_AND || 'PN_INVENTORY_DETAIL.BATCH = ' || MS_PN.n_BATCH;
    End If;

    S_COMPANYMULTIPL := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('COMPANYMULTIPL');

    if gs_company_multi = 'Y' and s_COMPANYMULTIPL = 'Y' then

      S_WHERE := S_WHERE || S_AND || ' ( LENGTH(PN_INVENTORY_DETAIL.OWNER) > 0 OR ' ||
                                    '   PN_INVENTORY_DETAIL.GL_COMPANY = ''' || ms_pn.s_gl_company || ''' )';

    end if;

    S_WHERE := S_WHERE || S_AND || 'PN_INVENTORY_DETAIL.QTY_AVAILABLE > 0 ';

    begin
      SELECT "PN_MASTER"."TOOL_CONTROL_ITEM",
            "PN_MASTER"."HAZARDOUS_MATERIAL"
      INTO s_return, s_by_pass  
      FROM "PN_INTERCHANGEABLE",   
        "PN_MASTER"  
      WHERE ( "PN_MASTER"."PN" = "PN_INTERCHANGEABLE"."PN" ) and  
        ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = MS_PN.S_PN ) );
    EXCEPTION
    WHEN OTHERS THEN
      S_RETURN := NULL;
      s_by_pass := null;
    END;

    if trim(s_return) is null then s_return := 'N'; end if;

    if not quarantine then
      IF S_RETURN = 'Y' THEN 
        S_WHERE := S_WHERE || S_AND || 'nvl(PN_INVENTORY_DETAIL.TOOL_LIFE_EXPIRATION, sysdate + 200000) > sysdate ';
      ELSE
        S_WHERE := S_WHERE || S_AND || 'nvl(PN_INVENTORY_DETAIL.SHELF_LIFE_EXPIRATION, sysdate + 200000) > sysdate ';
      END IF;

      IF trim(S_BY_PASS) is null THEN S_BY_PASS := 'N'; end if;

      IF S_BY_PASS = 'Y' THEN 
          S_WHERE := S_WHERE || S_AND || ' NVL(LOCATION_MASTER_ROUTINE.HAZARDOUS_BY_PASS, ''N'') = ''N'' ';
      END IF;
    end if;
    if trim(ms_pn.s_ac) is null then ms_pn.s_ac := ' '; end if;

    if trim(ms_pn.s_original_ac) is null then ms_pn.s_original_ac := 'NO'; end if;
    IF MS_PN.S_ORIGINAL_AC = 'YES' THEN 
      S_WHERE := S_WHERE || ' and ' || '  (NVL(PN_INVENTORY_DETAIL.ORIGINAL_AC_ISSUE_TO_ONLY, ''NO'') = ''NO'' ';
      S_WHERE := S_WHERE || ' or ' || '   (NVL(PN_INVENTORY_DETAIL.ORIGINAL_AC_ISSUE_TO_ONLY, ''YES'') = ''YES'' '; 
      S_WHERE := S_WHERE || ' and ' || '   PN_INVENTORY_DETAIL.ORIGINAL_AC = ''' || MS_PN.S_AC || ''' )) ';
    END IF;

    s_PKQTYOWNER := pkg_application_function.config_flag('PKQTYOWNER');

    If s_PKQTYOWNER = 'Y' Then 
      If nvl(ms_pn.n_wo, 0) > 0 Then
        begin
          SELECT "RELATION_MASTER"."EMPLOYEE_CONTRACTOR"
          INTO s_customer
          FROM "WO",
              "CUSTOMER_ORDER_HEADER",
              "RELATION_MASTER"
          WHERE ( "CUSTOMER_ORDER_HEADER"."ORDER_TYPE" = 'W/O' ) AND  
              ( "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER" = ms_pn.n_wo ) AND     
              ( NVL("WO"."THIRD_PARTY_WO", 'N') = 'Y' ) AND
              "CUSTOMER_ORDER_HEADER"."CUSTOMER" = "RELATION_MASTER"."RELATION_CODE" AND
              "RELATION_MASTER"."RELATION_TRANSACTION" = 'CUSTOMER' AND 
              rownum <= 1; --Log 168531
        EXCEPTION
        WHEN OTHERS THEN
          s_customer := null;
        END;
      END IF;
    END IF;

    IF nvl(MS_PN.S_EFFECTIVITY, 'N') = 'Y' THEN
      DECLARE
        S_PN_MAIN VARCHAR2(100);
        S_PN_INTER VARCHAR2(100);
        S_PNS VARCHAR2(32000);
        cursor dcl_pn_inter is
        SELECT "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE"  
        FROM "PN_INTERCHANGEABLE",   
          "PN_MASTER"  
        WHERE ( "PN_MASTER"."PN" = "PN_INTERCHANGEABLE"."PN" ) AND  
              (  "PN_INTERCHANGEABLE"."PN" = S_PN_MAIN ) ;
        TYPE TT_PN_INTER IS TABLE OF VARCHAR2(100);
        t_PN_INTER TT_PN_INTER := TT_PN_INTER();
      begin
        SELECT "PN_INTERCHANGEABLE"."PN"  
        INTO s_pn_main
        FROM "PN_INTERCHANGEABLE"
        WHERE ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = ms_pn.s_pn );

        OPEN DCL_PN_INTER;
        FETCH DCL_PN_INTER BULK COLLECT INTO T_PN_INTER;
        close DCL_PN_INTER;

        s_pns := ' ';

        IF T_PN_INTER.COUNT > 0 THEN

          FOR I IN T_PN_INTER.FIRST..T_PN_INTER.LAST
          loop

            s_pn_inter := T_PN_INTER(i);

            DECLARE
              MS_PN_INTER PKG_TYPE_STRUCTURES.ST_PN;
              optional number := 1;
            BEGIN
              MS_PN_INTER.S_PN := S_PN_INTER;
              MS_PN_INTER.N_WO := MS_PN.N_WO;
              ms_pn_inter.s_ac := ms_pn.s_ac;

              IF GF_PN_EFFECTIVITY_EDIT(MS_PN_INTER, OPTIONAL) = 0 THEN 
                IF S_PNS = ' ' THEN
                  S_PNS := S_PNS || '''' || S_PN_INTER || ''''; 
                ELSE
                  S_PNS := S_PNS || ', ''' || S_PN_INTER || ''''; 
                end if;
              END IF;
            END;
          END LOOP;

        end if;

        if s_pns = ' ' then s_pns := ''' no pn '''; end if;

        s_where := s_where || s_and || 'PN_INVENTORY_DETAIL.PN IN ( ' || S_PNS || ' ) ';
      end;
    End If;

    s_where := s_where || s_and || ' pn_inventory_detail.installed_ac is null and trim(pn_inventory_detail.nha_pn) is null ';

    IF TRIM(MS_PN.S_LOCATION) IS NOT NULL THEN  
      S_WHERE := S_WHERE || S_AND || ' LOCATION_MASTER_ROUTINE.MASTER_LOCATION = ''' || TRIM(MS_PN.S_LOCATION) || '''';
    End If;

    --Log 168531  
    IF s_PKQTYOWNER = 'Y' AND nvl(s_customer, ' ') <> ' ' THEN
      s_where := s_where || ' ORDER BY LOCATION_MASTER_ROUTINE.MASTER_LOCATION_SEQUENCE ASC, OWNER_SORT ASC, DT_SHELF_LIFE_COMPUTED ASC, "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH" ASC, "PN_INVENTORY_DETAIL"."BATCH" ASC ';
    ELSE
      s_where := s_where || ' ORDER BY "PN_INVENTORY_DETAIL"."BATCH" ASC ';
    END IF ;
     --End Log 168531

    s_mod := is_original || ' ' || s_where;

    OPEN CUR_QUERY FOR S_MOD USING S_CUSTOMER;
    FETCH CUR_QUERY BULK COLLECT INTO DW_PN_INVENTORY_AVL;
    close CUR_QUERY;

    IF DW_PN_INVENTORY_AVL.COUNT > 0 THEN
      D_QTY := DW_PN_INVENTORY_AVL(1).QTY_AVAILABLE;
    ELSE
      D_QTY := 0;
    end if;

    return d_qty;
  end GF_INVENTORY_AVAILABLE;

  FUNCTION GF_MANAGED_PARTS_PICKLIST(dw_pn_inventory_avl in out nocopy PKG_TYPE_STRUCTURES.dw_INVENTORY_TRAN_AVL, MS_PN PKG_TYPE_STRUCTURES.ST_PN) RETURN BOOLEAN
  AS
    D_QTY NUMBER;
    L_BATCH NUMBER;
    B_RETURN BOOLEAN := false;
    S_LOAN_CATEGORY VARCHAR2(100);
    S_CUSTOMER VARCHAR2(100);
    S_AC VARCHAR2(100);
    dw_pn_inventory_avl_helper PKG_TYPE_STRUCTURES.dw_INVENTORY_TRAN_AVL := PKG_TYPE_STRUCTURES.dw_INVENTORY_TRAN_AVL();
  BEGIN
    IF DW_PN_INVENTORY_AVL.COUNT > 0 THEN
      FOR I_CROW IN DW_PN_INVENTORY_AVL.FIRST..DW_PN_INVENTORY_AVL.LAST
      LOOP
        l_batch := dw_pn_inventory_avl(i_crow).batch;

        begin
          SELECT "PN_INVENTORY_DETAIL"."LOAN_CATEGORY"
          INTO s_loan_category
          FROM "PN_INVENTORY_DETAIL"
          WHERE "PN_INVENTORY_DETAIL"."BATCH" = L_BATCH;
        EXCEPTION
        WHEN OTHERS THEN
          s_loan_category := null;
        END;

        IF S_LOAN_CATEGORY = 'MANAGE' THEN

          begin
            SELECT "CUSTOMER_INVENTORY_OWNER"."CUSTOMER"
            INTO s_customer
            FROM "CUSTOMER_INVENTORY_OWNER"
            WHERE "CUSTOMER_INVENTORY_OWNER"."CUSTOMER" = (SELECT "CUSTOMER_ORDER_HEADER"."CUSTOMER"
                                  FROM "CUSTOMER_ORDER_HEADER",
                                     "WO"
                                  WHERE "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER" = "WO"."WO" AND
                                      "CUSTOMER_ORDER_HEADER"."ORDER_TYPE" = 'W/O' AND
                                      NVL("WO"."THIRD_PARTY_WO", 'N') = 'Y' AND
                                      "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER" = ms_pn.n_wo) AND
                                      "CUSTOMER_INVENTORY_OWNER"."INV_OWNER" = (SELECT "RELATION_MASTER"."RELATION_CODE"
                                                  FROM "RELATION_MASTER"
                                                  WHERE "RELATION_MASTER"."RELATION_TRANSACTION" = 'OWNER' AND
                                                      "RELATION_MASTER"."RELATION_CODE" = (SELECT "PN_INVENTORY_DETAIL"."OWNER"
                                                                       FROM "PN_INVENTORY_DETAIL"
                                                                       WHERE "PN_INVENTORY_DETAIL"."LOAN_CATEGORY" = 'MANAGE' AND
                                                                           "PN_INVENTORY_DETAIL"."BATCH" = L_BATCH));
          EXCEPTION
          WHEN OTHERS THEN
            s_customer := null;
          END;

          IF NVL(S_CUSTOMER, '          ') <> '          ' THEN
            IF TRIM(MS_PN.S_AC) IS NOT NULL THEN
              begin
                SELECT "AC_MASTER"."AC"
                INTO s_ac
                FROM "AC_MASTER"
                WHERE "AC_MASTER"."AC_OWNERSHIP_CONTROL" = 'MANAGED' AND
                      "AC_MASTER"."AC" = ms_pn.s_ac AND
                      "AC_MASTER"."CUSTOMER" = S_CUSTOMER;
              EXCEPTION
              WHEN OTHERS THEN
                s_ac := null;
              end;
              IF NVL(S_AC, '          ') = '          ' THEN 
                B_RETURN := TRUE;
              ELSE
                DW_PN_INVENTORY_AVL_HELPER.EXTEND;
                dw_pn_inventory_avl_helper(dw_pn_inventory_avl_helper.last) := dw_pn_inventory_avl(i_crow);
              END IF;
            End If;
          ELSE				
            b_return := true;
          END IF;
        else
          DW_PN_INVENTORY_AVL_HELPER.EXTEND;
          dw_pn_inventory_avl_helper(dw_pn_inventory_avl_helper.last) := dw_pn_inventory_avl(i_crow);
        End If;
      END LOOP;

      dw_pn_inventory_avl := null;
      dw_pn_inventory_avl := dw_pn_inventory_avl_helper;

      return b_return;

    end if;
  end gf_managed_parts_picklist;

  PROCEDURE GF_REQ_HEADER_STATUS_SET(L_REQUISITION NUMBER)
  AS
    S_RETURN VARCHAR2(100);
    l_count number;
  BEGIN
    begin
      SELECT "REQUISITION_DETAIL"."UOM"  
        INTO s_return  
        FROM "REQUISITION_DETAIL"  
       WHERE ( "REQUISITION_DETAIL"."REQUISITION" = L_REQUISITION ) AND  
        ( "REQUISITION_DETAIL"."STATUS" IN ( 'OPEN', 'ORDER' ) )  
          AND ROWNUM <= 1;
    EXCEPTION
    WHEN OTHERS THEN

      S_RETURN := NULL;

      begin
        SELECT count(*)  
          INTO l_count  
          FROM "REQUISITION_DETAIL"  
         WHERE "REQUISITION_DETAIL"."REQUISITION" = L_REQUISITION;
      exception
      WHEN OTHERS THEN
        L_COUNT := 0;
      end;

      IF NVL(L_COUNT, 0) > 0 THEN
        UPDATE "REQUISITION_HEADER"  
          SET "STATUS" = 'CLOSED',
            "AUTHORIZATION" = 'X'  
        WHERE "REQUISITION_HEADER"."REQUISITION" = l_requisition;
      end if;

      DECLARE
        S_SPACE VARCHAR2(100) := RPAD(' ', ' ', 35);
        s_requisition varchar2(100) := l_requisition;
      begin
        UPDATE "MASTER_AUTHORIZATION_UPD"
        SET "STATUS" = 'CANCEL'  
        WHERE ( "MASTER_AUTHORIZATION_UPD"."TRANSACTION_TYPE" = 'REQTYPE' ) AND  
            ( "MASTER_AUTHORIZATION_UPD"."P_KEY_1" = s_requisition ) AND
            ( "MASTER_AUTHORIZATION_UPD"."P_KEY_2" = s_space ) AND
            ( "MASTER_AUTHORIZATION_UPD"."P_KEY_3" = s_space ) AND
            ( "MASTER_AUTHORIZATION_UPD"."P_KEY_4" = s_space ) AND
            ( "MASTER_AUTHORIZATION_UPD"."P_KEY_5" = S_SPACE ) AND
            ( "MASTER_AUTHORIZATION_UPD"."STATUS" = 'OPEN' OR "MASTER_AUTHORIZATION_UPD"."STATUS" = 'PENDING');
      end;

    end;
  END GF_REQ_HEADER_STATUS_SET;

  FUNCTION GF_REQ_AUTHORIZATION_LEVEL(l_requisition number, gs_user in out nocopy varchar2) RETURN NUMBER
  AS
    D_ORDER_TOTAL NUMBER;
    D_AUTHORIZATION_AMOUNT NUMBER;
    D_AUTHORIZATION_MIN NUMBER;
    DT_TODAY DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    S_AUTHORIZATION VARCHAR2(100);
    S_RETURN VARCHAR2(100);
    STC_S_CONTROL VARCHAR2(100);
    STC_S_ACTION VARCHAR2(100);
    L_WO NUMBER;
    S_AUTHORIZED VARCHAR2(100);
    DT_AUTHORIZED DATE;
    s_location VARCHAR2(100);
    s_authorization_location VARCHAR2(100);
    S_LOCATION_RELATION VARCHAR2(100);
    IS_REQATHNIV VARCHAR2(100);
    d_inv_amount NUMBER;
    d_non_inv_amount NUMBER;
    d_req_qty NUMBER;
    D_QUOTED_AMOUNT NUMBER;
    S_NON_PN VARCHAR2(100);
    cursor cur_non_inv is 
      SELECT * 
      FROM "REQUISITION_DETAIL"  
      WHERE ( "REQUISITION_DETAIL"."REQUISITION" = L_REQUISITION  ) AND  
          ( "REQUISITION_DETAIL"."NON_INVENTORY_FLAG" = 'Y' );
    TYPE T_DCL_NON_INV IS TABLE OF REQUISITION_DETAIL%ROWTYPE;
    dcl_non_inv t_dcl_non_inv := t_dcl_non_inv();
  BEGIN
    GF_REQ_HEAdER_STATUS_SET(L_REQUISITION);

    begin
      SELECT "REQUISITION_HEADER"."REQUESTER_LOCATION",   
          "REQUISITION_HEADER"."PRIORITY",
          "REQUISITION_HEADER"."AUTHORIZATION",
          "REQUISITION_HEADER"."WO" 
      INTO STC_S_CONTROL,   
          stc_s_action,
          S_AUTHORIZATION,
          l_wo
      FROM "REQUISITION_HEADER"  
      WHERE ( "REQUISITION_HEADER"."REQUISITION" = L_REQUISITION);
    EXCEPTION
    WHEN OTHERS THEN
      return 1;
    end;

    if s_authorization = 'Y' Then Return 0; end if;

    begin
      SELECT "CUSTOMER_AUTHORIZATION"."CREATED_BY"  
      INTO s_return  
      FROM "CUSTOMER_AUTHORIZATION"  
      WHERE ( "CUSTOMER_AUTHORIZATION"."REQUISTION" = L_REQUISITION ) AND  
          ( "CUSTOMER_AUTHORIZATION"."AUTHORIZATION" IN ( 'PENDING', 'REJECTED' ) );
    exception
    WHEN OTHERS THEN
      return 1;
    end;

    s_authorization := PKG_APPLICATION_FUNCTION.config_flag('REQSEQ');

    If s_authorization = 'N'  Then

      SELECT "REQUISITION_HEADER"."AUTHORIZATION",   
          "REQUISITION_HEADER"."AUTHORIZED_DATE"
      INTO s_authorized,   
          dt_authorized  
      FROM "REQUISITION_HEADER"  
      WHERE "REQUISITION_HEADER"."REQUISITION" = l_requisition;

      IF trim(S_AUTHORIZED) is null THEN
          DECLARE
            SO_L_REQUISITION NUMBER := L_REQUISITION;
          BEGIN
            UPDATE "REQUISITION_HEADER"  
            SET "AUTHORIZATION" = 'Y',   
                "AUTHORIZED_BY" = gs_user,   
                "AUTHORIZED_DATE" = DT_TODAY  
            WHERE "REQUISITION_HEADER"."REQUISITION" = L_REQUISITION;
          END;
      End If;

      RETURN 0;
    End If;

    BEGIN
      SELECT "REQUISITION_HEADER"."REQUESTER_LOCATION" 
      INTO s_location
      FROM "REQUISITION_HEADER"  
      WHERE ( "REQUISITION_HEADER"."REQUISITION" = l_requisition    );

      SELECT "AUTHORIZATION_MASTER"."AUTHORIZED_AMOUNT",   
          "AUTHORIZATION_MASTER"."LOCATION",
          "AUTHORIZATION_MASTER"."LOCATION_RELATION",
          "AUTHORIZATION_MASTER"."MINIMUM_AMOUNT"
      INTO d_authorization_amount, 
          s_authorization_location,
          s_location_relation,
          d_authorization_min
      FROM "AUTHORIZATION_MASTER"
      WHERE ( "AUTHORIZATION_MASTER"."USER" = gs_user ) and  
          ( "AUTHORIZATION_MASTER"."TYPE" = 'REQUISITION' );
    EXCEPTION
    WHEN OTHERS THEN
      return 1;
    end;

    is_REQATHNIV := pkg_application_function.config_flag('REQATHNIV');

    if is_REQATHNIV = 'Y' then

      begin
        SELECT DISTINCT nvl(sum("REQUISITION_DETAIL"."QTY_REQUIRE" * "PN_MASTER"."AVERAGE_COST"),0)  
        INTO d_inv_amount  
        FROM "REQUISITION_DETAIL",   
            "PN_INTERCHANGEABLE",   
            "PN_MASTER"  
        WHERE "PN_MASTER"."PN" = "PN_INTERCHANGEABLE"."PN"  and  
            requisition_detail.pn = pn_interchangeable.pn_interchangeable (+) and  
            "REQUISITION_DETAIL"."REQUISITION" = l_requisition  and
            "REQUISITION_DETAIL"."NON_INVENTORY_FLAG" = 'N';
      EXCEPTION
      WHEN OTHERS THEN
        d_inv_amount := 0;
      END;    

      d_non_inv_amount := 0;

      OPEN CUR_NON_INV;
      FETCH CUR_NON_INV BULK COLLECT INTO DCL_NON_INV;
      close CUR_NON_INV;

      IF DCL_NON_INV IS NOT NULL AND DCL_NON_INV.COUNT > 0 THEN

        FOR I IN DCL_NON_INV.FIRST..DCL_NON_INV.LAST
        LOOP
            S_NON_PN := DCL_NON_INV(I).PN;
            D_REQ_QTY := nvl(DCL_NON_INV(I).QTY_REQUIRE, 0);
            D_QUOTED_AMOUNT := 0;

            begin
              SELECT nvl(min("REQUISITION_QUOTE_DISTRIBUTION"."UNIT_COST"),0)  
              INTO d_quoted_amount  
              FROM "REQUISITION_QUOTE_DISTRIBUTION",   
                  "REQUISITION_QUOTE_HEADER"  
              WHERE ( "REQUISITION_QUOTE_HEADER"."QUOTE_NO" = "REQUISITION_QUOTE_DISTRIBUTION"."QUOTE_NO" ) and  
                  ( "REQUISITION_QUOTE_HEADER"."QUOTE_LINE" = "REQUISITION_QUOTE_DISTRIBUTION"."QUOTE_LINE" ) and  
                  ( ( "REQUISITION_QUOTE_DISTRIBUTION"."PN" = S_NON_PN  ) AND  
                  ( "REQUISITION_QUOTE_HEADER"."REQUISITION" = l_requisition  ) AND
                  "REQUISITION_QUOTE_DISTRIBUTION"."STATUS" = 'QUOTED');
            EXCEPTION
            WHEN OTHERS THEN
              d_quoted_amount := 0;
            END;

            IF nvl(D_QUOTED_AMOUNT, 0) = 0 THEN
              RETURN 1;
            end if;

            D_NON_INV_AMOUNT := D_NON_INV_AMOUNT + (D_QUOTED_AMOUNT	* D_REQ_QTY );
        END LOOP;

      end if;

      d_order_total := d_inv_amount + d_non_inv_amount;

    else

      begin
        SELECT sum("REQUISITION_DETAIL"."QTY_REQUIRE"  * "PN_MASTER"."AVERAGE_COST")  
        INTO d_order_total  
        FROM "REQUISITION_DETAIL",   
            "PN_INTERCHANGEABLE",   
            "PN_MASTER"  
        WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) and  
            ( requisition_detail.pn = pn_interchangeable.pn_interchangeable (+)) and  
            ( ( "REQUISITION_DETAIL"."REQUISITION" = L_REQUISITION ) );
      EXCEPTION
      WHEN OTHERS THEN
        d_order_total := 0;
      end;

    end if;

    IF (D_ORDER_TOTAL > D_AUTHORIZATION_AMOUNT) OR (D_ORDER_TOTAL < NVL(D_AUTHORIZATION_MIN, 0)) THEN
      RETURN 1;
    End If;

    IF TRIM(S_AUTHORIZATION_LOCATION) IS NOT NULL THEN
      IF NVL(S_AUTHORIZATION_LOCATION,' ') <> NVL(S_LOCATION,' ') AND S_LOCATION_RELATION = 'EQUAL' THEN
        RETURN 1;
      ELSIF S_AUTHORIZATION_LOCATION = S_LOCATION AND S_LOCATION_RELATION = 'NOTEQUAL' THEN
        RETURN 1;
      END IF;
    End If;

    SELECT "REQUISITION_HEADER"."AUTHORIZATION",   
        "REQUISITION_HEADER"."AUTHORIZED_DATE"
    INTO s_authorized,   
        dt_authorized  
    FROM "REQUISITION_HEADER"  
    WHERE "REQUISITION_HEADER"."REQUISITION" = l_requisition;

    If trim(s_authorized) is null or dt_authorized is null Then s_authorized := null; end if;

    If trim(s_authorized) is null Then
      UPDATE "REQUISITION_HEADER"  
      SET "AUTHORIZATION" = 'Y',   
          "AUTHORIZED_BY" = gs_user,   
          "AUTHORIZED_DATE" = dt_today  
      WHERE "REQUISITION_HEADER"."REQUISITION" = L_REQUISITION ;
    End If;

    Return 0;

  end gf_req_authorization_level;

  PROCEDURE WF_LOAD_REQUISITION(d_qty number, il_requisition in out nocopy number, IS_PN in out nocopy varchar2, is_priority_req in out nocopy varchar2,
                                IS_REQUISITION_TYPE IN OUT NOCOPY VARCHAR2, IS_COMPANYMULTIREQ IN OUT NOCOPY VARCHAR2, GS_COMPANY_MULTI IN OUT NOCOPY VARCHAR2,
                                IS_COMPANY IN OUT NOCOPY VARCHAR2, IS_TASK_CARD IN OUT NOCOPY VARCHAR2, GS_USER in out nocopy VARCHAR2, IS_EC IN OUT NOCOPY VARCHAR2,
                                IS_SITE IN OUT NOCOPY VARCHAR2, IS_TASK_CARD_PN IN OUT NOCOPY VARCHAR2, IS_TASK_CARD_PN_SN IN OUT NOCOPY VARCHAR2,
                                is_defect  requisition_header.defect%type,               
                                is_defect_type requisition_header.defect_type%type,
                                il_defect_item requisition_header.defect_item%type, 
                                IL_WO IN OUT NOCOPY NUMBER,
                                IS_LOCATION IN OUT NOCOPY VARCHAR2, IS_AC IN OUT NOCOPY VARCHAR2, IDT_REQUIRE_DATE_REQ IN OUT NOCOPY DATE, IDT_SCHEDULE_START_DATE IN OUT NOCOPY DATE,
                                IL_REQUIRE_HOUR_REQ IN OUT NOCOPY NUMBER, il_require_minute_req IN OUT NOCOPY NUMBER)
  AS
    S_PRIORITY VARCHAR2(100);
    s_pn_description VARCHAR2(100);
    s_uom VARCHAR2(100);
    s_pn_main VARCHAR2(100);
    S_INVENTORY_TYPE VARCHAR2(100);
    S_GL_COMPANY VARCHAR2(100);
    S_GL_EXPENDITURE VARCHAR2(100);
    S_GL VARCHAR2(100);
    S_GL_COST_CENTER VARCHAR2(100);
    S_REQUISITION_TYPE VARCHAR2(100);
    DT_TODAY DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    DT_DATE_REQUIRE DATE;
    L_REQUISITION NUMBER := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('REQSEQ');
    S_PLANNER VARCHAR2(100);
    s_buyer VARCHAR2(100);
    s_non_inv_flag VARCHAR2(10) := 'N' ;
  BEGIN
    il_requisition := l_requisition;

    BEGIN
      SELECT "SYSTEM_TRAN_CODE"."SYSTEM_CODE"  
      INTO s_priority  
      FROM "SYSTEM_TRAN_CODE"  
      WHERE ( "SYSTEM_TRAN_CODE"."SYSTEM_TRANSACTION" = 'PRIORITY' ) AND  
          ( "SYSTEM_TRAN_CODE"."PRIORITY_LEVEL" = '98' );
    EXCEPTION
    WHEN OTHERS THEN
      begin
        SELECT "SYSTEM_TRAN_CODE"."SYSTEM_CODE"  
        INTO s_priority  
        FROM "SYSTEM_TRAN_CODE"  
        WHERE ( "SYSTEM_TRAN_CODE"."SYSTEM_TRANSACTION" = 'PRIORITY' ) AND  
            ( "SYSTEM_TRAN_CODE"."PRIORITY_LEVEL" = '99' )  AND 
            ROWNUM = 1;
      EXCEPTION
      WHEN OTHERS THEN
        s_priority := null;
      end;
    end;

    begin
      SELECT "PN_MASTER"."PN",   
            "PN_MASTER"."PN_DESCRIPTION",   
            "PN_MASTER"."STOCK_UOM",   
            "PN_MASTER"."GL_COMPANY",   
            "PN_MASTER"."GL_EXPENDITURE",   
            "PN_MASTER"."GL",   
            "PN_MASTER"."GL_COST_CENTER",
            "PN_MASTER"."INVENTORY_TYPE"   
        INTO s_pn_main,   
            s_pn_description,   
            s_uom,   
            s_gl_company,   
            s_gl_expenditure,   
            s_gl,   
            s_gl_cost_center,
            s_inventory_type  
        FROM "PN_MASTER",   
            "PN_INTERCHANGEABLE"  
        WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) AND  
            ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = IS_PN ) );
    EXCEPTION
    WHEN OTHERS THEN
      null;
      s_non_inv_flag := 'Y';
      s_uom := 'EA' ; 
      S_INVENTORY_TYPE := 'MAINTENANCE' ;
    end;

    begin
      SELECT "PN_INVENTORY_LEVEL"."BUYER"
      INTO s_buyer  
      FROM "PN_INVENTORY_LEVEL"  
      WHERE ( "PN_INVENTORY_LEVEL"."PN" = S_PN_MAIN )  AND
            ROWNUM =1;
    EXCEPTION
    WHEN OTHERS THEN
      s_buyer := null;
    end;
    g_type := 'R-';
    
    begin
      select buyer
      into s_buyer
      from pn_inventory_level
      where (pn = s_pn_main) AND
            (location = is_location);
      exception
      when no_data_found then
        s_buyer := null;
    end;

    s_requisition_type := 'PREDRAW';  
    IF NVL(IS_PRIORITY_REQ, ' ') <> ' ' THEN S_PRIORITY := IS_PRIORITY_REQ; END IF;
    If nvl(is_requisition_type, ' ') <> ' ' Then s_requisition_type := is_requisition_type; end if;
    GS_COMPANY_MULTI := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('COMPANYMULTI'); --LOG 238863.
    IF (IS_COMPANYMULTIREQ = 'N' AND GS_COMPANY_MULTI = 'Y') THEN 
      S_GL_COMPANY := is_company;
    ELSE
      is_company := null;
    End If;

    INSERT INTO "REQUISITION_HEADER"  
        ( "REQUISITION",   
          "REQUISITION_DESCRIPTION",   
          "REQUESTER_LOCATION",   
          "AC",   
          "WO",   
          "TASK_CARD",   
          "PRIORITY",   
          "REQUISTION_TYPE",   
          "STATUS",   
          "CREATED_BY",   
          "CREATED_DATE",   
          "MODIFIED_BY",   
          "MODIFIED_DATE",
          "INVENTORY_TYPE",
          "EO",
          "SITE",
          "TASK_CARD_PN",
          "TASK_CARD_SN",
          "ORDER_CATEGORY" , 
          "DEFECT" , "DEFECT_TYPE" , "DEFECT_ITEM",
            authorization , 
        authorized_by , 
        authorized_date
          ) 
    VALUES ( l_requisition,   
          'W/O Pre-Draw',   
          is_location,   
          is_ac,   
          il_wo,   
          is_task_card,   
          s_priority,   
          s_requisition_type,   
          'OPEN',   
          gs_user,   
          dt_today,   
          gs_user,   
          dt_today,
          s_inventory_type,
          is_ec,
          is_site,
          is_task_card_pn,
          IS_TASK_CARD_PN_SN,
          is_company ,  is_DEFECT , is_DEFECT_TYPE , il_DEFECT_ITEM ,
           'Y' , 
          gs_user,
          dt_today
      );
      g_rNumber :=  l_requisition;   

    IF IDT_REQUIRE_DATE_REQ IS NOT NULL THEN
      DT_DATE_REQUIRE := IDT_REQUIRE_DATE_REQ;
    ELSE
      dt_date_require := idt_schedule_start_date;
    end if;

    INSERT INTO "REQUISITION_DETAIL"  
        ( "REQUISITION",   
        "REQUISITION_LINE",   
        "PN",   
        "PN_DESCRIPTION",   
        "NON_INVENTORY_FLAG",   
        "QTY_REQUIRE",   
        "UOM",   
        "STATUS",   
        "REQUIRE_DATE",   
        "REQUIRE_HOUR",   
        "REQUIRE_MINUTE",   
        "LOCATION",   
        "QTY_RECEIVED",   
        "GL_COMPANY",   
        "GL_EXPENDITURE",   
        "GL",   
        "GL_COST_CENTER",   
        "CREATED_BY",   
        "CREATED_DATE",   
        "MODIFIED_BY",   
        "MODIFIED_DATE",
        "ASSIGN_TO")  
    VALUES ( l_requisition,   
        1,   
        is_pn,   
        s_pn_description,   
        'N',   
        d_qty,   
        s_uom,   
        'OPEN',   
        dt_date_require,   
        il_require_hour_req,
        il_require_minute_req,
        is_location,   
        0,   
        s_gl_company,   
        s_gl_expenditure,   
        s_gl,   
        s_gl_cost_center,   
        gs_user,   
        dt_today,   
        gs_user,   
        DT_TODAY,
        s_buyer);

  end wf_load_requisition;

  FUNCTION WF_EDIT(DW_EU IN OUT NOCOPY PICKLIST_DISTRIBUTION%ROWTYPE, DW_PN_INVENTORY_AVL IN OUT NOCOPY PKG_TYPE_STRUCTURES.DW_INVENTORY_TRAN_AVL, DW_PN_INVENTORY_AVL_QTY IN OUT NOCOPY NUMBER,
                   dw_pn_inventory_avl_qty1 in out nocopy number, dw_pn_inventory_avl_qty2 in out nocopy number, is_errfld in out nocopy varchar2, IS_TPW in out nocopy varchar2,
                   IS_AC IN OUT NOCOPY VARCHAR2, IL_WO IN OUT NOCOPY VARCHAR2, IS_LOCATION IN OUT NOCOPY VARCHAR2, IS_ETOPS_ACTION IN OUT NOCOPY VARCHAR2,
                   IS_ORIGINAL IN OUT NOCOPY VARCHAR2, GS_COMPANY_MULTI IN OUT NOCOPY VARCHAR2, IS_BOCRT IN OUT NOCOPY VARCHAR2, IS_SHORTAGE_PRINT_ONLY IN OUT NOCOPY VARCHAR2,
                   IL_REQUISITION IN OUT NOCOPY NUMBER, IS_PN IN OUT NOCOPY VARCHAR2, IS_PRIORITY_REQ IN OUT NOCOPY VARCHAR2,
                   IS_REQUISITION_TYPE IN OUT NOCOPY VARCHAR2, IS_COMPANYMULTIREQ IN OUT NOCOPY VARCHAR2,
                   IS_COMPANY IN OUT NOCOPY VARCHAR2, IS_TASK_CARD IN OUT NOCOPY VARCHAR2, GS_USER in out nocopy VARCHAR2, IS_EC IN OUT NOCOPY VARCHAR2,
                   IS_SITE IN OUT NOCOPY VARCHAR2, IS_TASK_CARD_PN IN OUT NOCOPY VARCHAR2, IS_TASK_CARD_PN_SN IN OUT NOCOPY VARCHAR2,
                   IS_DEFECT  VARCHAR2,IS_DEFECT_TYPE  VARCHAR2,IL_DEFECT_ITEM  NUMBER,
                   IDT_REQUIRE_DATE_REQ IN OUT NOCOPY DATE, IDT_SCHEDULE_START_DATE IN OUT NOCOPY DATE,
                   IL_REQUIRE_HOUR_REQ IN OUT NOCOPY number, il_require_minute_req IN OUT NOCOPY number) return number
  AS
    S_PN VARCHAR2(100) := dw_eu.pn;
    s_pn_main VARCHAR2(100);
    S_RETURN VARCHAR2(100);
    B_MANAGED BOOLEAN;
    MS_PN PKG_TYPE_STRUCTURES.ST_PN;
    II_NONEFFECTIVE NUMBER;
    D_QTY NUMBER;
    D_QTY_RTN NUMBER;
    s_condition VARCHAR2(100);
    S_SN VARCHAR2(100);
    l_batch NUMBER;
    L_PICKLIST NUMBER;
    b_non_inventory boolean ;
  BEGIN
    g_type := 'P-';

    is_errfld := ' ';

    begin  
    SELECT "PN_INTERCHANGEABLE"."PN"  
    INTO s_pn_main  
    FROM "PN_INTERCHANGEABLE"  
    WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = S_PN;
    EXCEPTION
    WHEN OTHERS THEN
       b_non_inventory := true; 
        ii_nonEffective := 1;
    end;

    MS_PN.S_PN := S_PN;
    MS_PN.S_AC := IS_AC;
    ms_pn.n_wo := il_wo;

    IF (IS_TPW = 'N' AND  (trim(IS_AC) is not null)) OR pkg_application_function.getcompanyPROFILE = 'LTP' THEN
      ii_nonEffective := 1;
    END IF;

  if not b_non_inventory then   
    DECLARE
      optional number := 1;
    BEGIN
      IF GF_PN_EFFECTIVITY_EDIT(MS_PN, OPTIONAL) = 1 THEN 
        II_NONEFFECTIVE := 0;
        RETURN  1  ;
      END IF;
    END;
  end if;  
    d_qty  := dw_eu.qty;

    If nvl(d_qty, 0) <= 0  Then 	Return  1  ; end if;

    L_BATCH := DW_EU.BATCH;
    L_PICKLIST := DW_EU.PICKLIST;
    S_CONDITION := DW_EU.CONDITION;
    S_SN := DW_EU.SN;
    S_PN  := DW_EU.PN;
    MS_PN.S_LOCATION := IS_LOCATION;
    MS_PN.S_PN := S_PN;
    MS_PN.S_CONDITION := S_CONDITION;
    MS_PN.S_SN := S_SN;
    MS_PN.n_BATCH := L_BATCH;
     if not b_non_inventory then   
        MS_PN.S_EFFECTIVITY := 'Y';
     else
      MS_PN.S_EFFECTIVITY := 'N';
    end if; 
    ms_pn.n_wo := il_wo;

    begin
      SELECT "SYSTEM_TRAN_CODE"."COMPANY"
      INTO ms_pn.s_gl_company
      FROM "WO",
               "SYSTEM_TRAN_CODE"
      WHERE "SYSTEM_TRAN_CODE"."SYSTEM_CODE"  = "WO"."GL_COMPANY"
      AND "SYSTEM_TRANSACTION"  = 'ORDERCATEGORY'
      AND "SYSTEM_TRAN_CODE"."SYSTEM_TRAN_CODE_SUB" = '          '
      AND "WO"."WO"  =  il_wo;
    EXCEPTION
    WHEN OTHERS THEN
      MS_PN.s_gl_company := NULL;
    END;

    begin
      SELECT "RELATION_MASTER"."EMPLOYEE_CONTRACTOR"  
      INTO ms_pn.s_owner  
      FROM "CUSTOMER_ORDER_HEADER",   
          "RELATION_MASTER"  
      WHERE ( "CUSTOMER_ORDER_HEADER"."CUSTOMER" = "RELATION_MASTER"."RELATION_CODE" ) and  
        ( ( "CUSTOMER_ORDER_HEADER"."ORDER_TYPE" = 'W/O' ) AND  
        ( "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER" = il_wo ) );
    EXCEPTION
    WHEN OTHERS THEN
      MS_PN.S_OWNER := null;
    END;

    IF NVL(iS_ETOPS_ACTION, '5') = '3' OR NVL(iS_ETOPS_ACTION,'5') = '4' THEN
      MS_PN.S_ORDER_TYPE := 'S/O';
    end if;

    d_qty_rtn := GF_INVENTORY_AVAILABLE(DW_PN_INVENTORY_AVL, MS_PN, IS_ORIGINAL, gs_company_multi);

    IF D_QTY_RTN > 0 THEN
      b_managed := gf_managed_parts_picklist(dw_pn_inventory_avl, ms_pn);

      IF DW_PN_INVENTORY_AVL is not null and DW_PN_INVENTORY_AVL.COUNT() > 0 THEN

        dw_pn_inventory_avl_qty := 0;
        DW_PN_INVENTORY_AVL_QTY1 := 0;
        DW_PN_INVENTORY_AVL_QTY2 := 0;

        FOR I IN DW_PN_INVENTORY_AVL.FIRST..DW_PN_INVENTORY_AVL.LAST
        LOOP
          IF TRIM(DW_PN_INVENTORY_AVL(I).LOAN_CATEGORY) IS NULL THEN
            DW_PN_INVENTORY_AVL_QTY := DW_PN_INVENTORY_AVL_QTY + nvl(DW_PN_INVENTORY_AVL(I).QTY_AVAILABLE, 0);
          ELSE
            IF TRIM(DW_PN_INVENTORY_AVL(I).LOAN_CATEGORY) <> 'MANAGE' THEN
              DW_PN_INVENTORY_AVL_QTY := DW_PN_INVENTORY_AVL_QTY + nvl(DW_PN_INVENTORY_AVL(I).QTY_AVAILABLE, 0);
            ELSE
              IF NVL(TRIM(MS_PN.S_OWNER), ' ') = NVL (TRIM(DW_PN_INVENTORY_AVL(I).OWNER), ' ') THEN
                DW_PN_INVENTORY_AVL_QTY := DW_PN_INVENTORY_AVL_QTY + nvl(DW_PN_INVENTORY_AVL(I).QTY_AVAILABLE, 0);
              ELSE
                DW_PN_INVENTORY_AVL_QTY := 0;
              end if;
            end if;
          end if;

          DW_PN_INVENTORY_AVL_QTY1 := DW_PN_INVENTORY_AVL_QTY1 + nvl(DW_PN_INVENTORY_AVL(I).QTY_AVAILABLE, 0);

          IF TRIM(DW_PN_INVENTORY_AVL(I).LOAN_CATEGORY) IS NULL THEN
            DW_PN_INVENTORY_AVL_QTY2 := DW_PN_INVENTORY_AVL_QTY2 + nvl(DW_PN_INVENTORY_AVL(I).QTY_us, 0);
          ELSE
            IF TRIM(DW_PN_INVENTORY_AVL(I).LOAN_CATEGORY) <> 'MANAGE' THEN
              DW_PN_INVENTORY_AVL_QTY2 := DW_PN_INVENTORY_AVL_QTY2 + nvl(DW_PN_INVENTORY_AVL(I).QTY_us, 0);
            ELSE
              IF NVL(TRIM(MS_PN.S_OWNER), ' ') = NVL (TRIM(DW_PN_INVENTORY_AVL(I).OWNER), ' ') THEN
                DW_PN_INVENTORY_AVL_QTY2 := DW_PN_INVENTORY_AVL_QTY2 + NVL(DW_PN_INVENTORY_AVL(I).QTY_US, 0);
              ELSE
                DW_PN_INVENTORY_AVL_QTY2 := 0;
              end if;
            END IF;
          end if;

        end loop;

        d_qty_rtn := dw_pn_inventory_avl_qty;
      ELSE 
        D_QTY_RTN := 0;
      END IF;
    End If;

    IF D_QTY > D_QTY_RTN THEN
      is_shortage_print_only := 'N';
      is_bocrt := 'Y';

      If is_bocrt = 'Y'  and is_shortage_print_only = 'N' Then 	

      wf_load_requisition(d_qty - d_qty_rtn, il_requisition, IS_PN, is_priority_req,
                                                                                    IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ, GS_COMPANY_MULTI,
                                                                                    IS_COMPANY, IS_TASK_CARD, GS_USER, IS_EC,
                                                                                    IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, IS_DEFECT , IS_DEFECT_TYPE, IL_DEFECT_ITEM ,  IL_WO,
                                                                                    IS_LOCATION, IS_AC, IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                                                                    IL_REQUIRE_HOUR_REQ, il_require_minute_req);
      END IF;

      If d_qty_rtn = 0 Then Return 1; end if;

      D_QTY := D_QTY_RTN;
      DW_EU.QTY := D_QTY;

    End if;

    return 0;

  end wf_edit;

  PROCEDURE WF_NEW_PICKLIST_HEADER(IL_PICKLIST IN OUT NOCOPY NUMBER, IS_LOCATION IN OUT NOCOPY VARCHAR2, IL_WO IN OUT NOCOPY NUMBER, IS_TASK_CARD_HEADER IN OUT NOCOPY VARCHAR2,
                                   IDT_SCHEDULE_START_DATE IN OUT NOCOPY DATE, IL_REQUIRE_HOUR IN OUT NOCOPY number, IL_REQUIRE_MINUTE IN OUT NOCOPY NUMBER,
                                   IS_DELIVERY_LOCATION IN OUT NOCOPY VARCHAR2, IS_PRIORITY IN OUT NOCOPY VARCHAR2, IS_SITE IN OUT NOCOPY VARCHAR2, IS_TASK_CARD_PN IN OUT NOCOPY VARCHAR2,
                                   is_task_card_pn_sn IN OUT NOCOPY VARCHAR2, 
                                   IS_DEFECT IN OUT NOCOPY VARCHAR2,IS_DEFECT_TYPE IN OUT NOCOPY VARCHAR2,IL_DEFECT_ITEM IN OUT NOCOPY number,
                                   is_ac IN OUT NOCOPY VARCHAR2, gs_user IN OUT NOCOPY VARCHAR2)
  as
  BEGIN
    il_picklist := PKG_APPLICATION_FUNCTION.config_number('PICKLIST');

    NEW_PICKLIST_HEADER(IL_PICKLIST, IS_LOCATION, IL_WO, IS_TASK_CARD_HEADER, IDT_SCHEDULE_START_DATE,IL_REQUIRE_HOUR,
                        IL_REQUIRE_MINUTE, IS_DELIVERY_LOCATION, IS_PRIORITY, IS_SITE,IS_TASK_CARD_PN,IS_TASK_CARD_PN_SN,
                         IS_DEFECT ,IS_DEFECT_TYPE ,IL_DEFECT_ITEM ,
                        IS_AC,GS_USER);

    PICKLIST_HEADER_AUDIT(IL_PICKLIST, 'NEW', GS_USER);
  end WF_NEW_PICKLIST_HEADER;

  FUNCTION WF_CHECK_INCOMPLETE(l_batch in out nocopy number, dw_pn_inventory_avl in out nocopy PKG_TYPE_STRUCTURES.dw_INVENTORY_TRAN_AVL, MS_PN in out nocopy PKG_TYPE_STRUCTURES.ST_PN) RETURN boolean
  AS
    B_INCOMPLETE BOOLEAN := false;
    L_INCOMPLETE_ROW NUMBER;
    S_PN_FOUND VARCHAR2(100);
    S_PN VARCHAR2(100);
    S_SN VARCHAR2(100);
    D_QTY_AVAILABLE NUMBER;
    B_CONTINUE BOOLEAN := FALSE;
    b_exit boolean := false;
  begin

    l_incomplete_row := 0;

    if dw_pn_inventory_avl is not null and dw_pn_inventory_avl.count > 0 then
      FOR L_CROW IN DW_PN_INVENTORY_AVL.FIRST..DW_PN_INVENTORY_AVL.LAST
      loop
        if not b_exit then
          B_CONTINUE := FALSE;

          --avl_1
          IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) IS NULL THEN
              d_qty_available := dw_pn_inventory_avl(l_crow).qty_available;
          ELSE
            IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) <> 'MANAGE' THEN
              d_qty_available := dw_pn_inventory_avl(l_crow).qty_available;
            ELSE
              IF NVL(TRIM(MS_PN.S_OWNER), ' ') = NVL (TRIM(DW_PN_INVENTORY_AVL(l_crow).OWNER), ' ') THEN
                d_qty_available := dw_pn_inventory_avl(l_crow).qty_available;
              ELSE
                d_qty_available := 0;
              end if;
            end if;
          END IF;

          If d_qty_available = 0 Then b_Continue := true; end if;

          IF NOT B_CONTINUE THEN
            S_PN := DW_PN_INVENTORY_AVL(L_CROW).PN;
            s_sn := dw_pn_inventory_avl(l_crow).sn;

            b_incomplete := false;

            IF TRIM(S_SN) IS NOT NULL THEN
              S_PN_FOUND := NVL(pkg_function_inventory.CHECK_NLA_LOOP(S_PN),' ');
              IF NVL(S_PN_FOUND,' ') <> ' ' THEN
                B_INCOMPLETE := TRUE;
              ELSIF pkg_function_inventory.CHECK_INCOMPLETE_ASSEMBLY(S_PN, S_SN) = 1 THEN
                B_INCOMPLETE := TRUE;
              END IF;
            End If;

            IF NOT B_INCOMPLETE THEN 
              L_BATCH := DW_PN_INVENTORY_AVL(L_CROW).batch;
              b_Exit := true;
            ELSIF L_INCOMPLETE_ROW = 0  THEN
              l_incomplete_row := l_crow;
            END IF;
          END IF;
        end if;
      end loop;
    end if;

    If nvl(l_batch, 0) = 0 and l_incomplete_row > 0 Then l_batch := dw_pn_inventory_avl(l_incomplete_row).batch; end if;

    RETURN B_INCOMPLETE;

  end WF_CHECK_INCOMPLETE;

  FUNCTION GF_INV_LEVEL_CHECK_REORDER(S_TRANSACTION VARCHAR2, S_PN VARCHAR2) RETURN VARCHAR2
  AS
    S_CHECKOUT_REORDER VARCHAR2(100);
    S_ISSUE_REORDER VARCHAR2(100);
    S_TRANSFER_ORDER_REORDER VARCHAR2(100);
    S_STEP_TRANSFER_REORDER VARCHAR2(100);
    S_SCRAP_REORDER VARCHAR2(100);
  BEGIN

    SELECT "SYSTEM_TRAN_CODE"."CHECKOUT_REORDER",
           "SYSTEM_TRAN_CODE"."ISSUE_REORDER",
           "SYSTEM_TRAN_CODE"."TRANSFER_ORDER_REORDER",
           "SYSTEM_TRAN_CODE"."STEP_TRANSFER_REORDER",
          "SYSTEM_TRAN_CODE"."SCRAP_REORDER"
    INTO  s_checkout_reorder,
          s_issue_reorder,
          s_transfer_order_reorder,
          s_step_transfer_reorder,
          s_scrap_reorder
    FROM   "PN_MASTER",   
           "PN_INTERCHANGEABLE",		  		    
             "SYSTEM_TRAN_CODE"  
    WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) AND  
          ( "PN_MASTER"."CATEGORY" = "SYSTEM_TRAN_CODE"."SYSTEM_CODE" ) AND
          ( "SYSTEM_TRAN_CODE"."SYSTEM_TRANSACTION" = 'PNCATEGORY' ) AND
          ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn)	;

    CASE S_TRANSACTION
      WHEN 'CHECK-OUT' then
        RETURN S_CHECKOUT_REORDER;
      WHEN 'ISSUE' then
        RETURN S_ISSUE_REORDER;
      when 'TRANSFER-ORDER' then
        RETURN S_TRANSFER_ORDER_REORDER;
      when 'STEP-TRANSFER' then
        RETURN S_STEP_TRANSFER_REORDER;
      WHEN 'SCRAP' then
        RETURN S_SCRAP_REORDER;
      ELSE
        null;
    end case;

    return 'YES';
  END GF_INV_LEVEL_CHECK_REORDER;

  PROCEDURE GF_SAVE_WO_TC_PN_ARRAY(T_DW_SEL WO_TC_PN_ARRAY)
  AS
  BEGIN
    IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
      FOR I IN T_DW_SEL.FIRST..T_DW_SEL.LAST
      LOOP
        IF NVL(T_DW_SEL(I).N_WO, 0) > 0
        AND T_DW_SEL(I).S_TASK_CARD IS NOT NULL
        AND T_DW_SEL(I).S_PN IS NOT NULL
        AND T_DW_SEL(I).S_TASK_CARD_PN IS NOT NULL
        AND T_DW_SEL(I).S_TASK_CARD_PN_SN IS NOT NULL
        AND T_DW_SEL(i).s_AC IS NOT NULL then

          DECLARE
            N_COUNT NUMBER := 0;
          BEGIN
            SELECT COUNT(*)
            INTO N_COUNT
            FROM WO_TASK_CARD_PN
            WHERE WO = T_DW_SEL(i).N_WO
            AND   TASK_CARD = T_DW_SEL(I).S_TASK_CARD
            AND   PN = T_DW_SEL(I).S_PN
            AND   TASK_CARD_PN = T_DW_SEL(I).S_TASK_CARD_PN
            AND   TASK_CARD_PN_SN = T_DW_SEL(I).S_TASK_CARD_PN_SN
            AND   AC = T_DW_SEL(i).s_AC;

            IF N_COUNT > 0 THEN
              UPDATE WO_TASK_CARD_PN
              set wo = T_DW_SEL(i).n_wo,
                  task_card = T_DW_SEL(i).s_task_card,
                  pn = T_DW_SEL(i).s_pn,
                  qty = T_DW_SEL(i).n_qty,
                  qty_reserved = T_DW_SEL(i).n_qty_reserved,
                  MODIFIED_DATE = T_DW_SEL(I).DT_MODIFIED_DATE
              where WO = T_DW_SEL(i).N_WO
              AND   TASK_CARD = T_DW_SEL(I).S_TASK_CARD
              AND   PN = T_DW_SEL(I).S_PN
              AND   TASK_CARD_PN = T_DW_SEL(I).S_TASK_CARD_PN
              AND   TASK_CARD_PN_SN = T_DW_SEL(I).S_TASK_CARD_PN_SN
              AND   AC = T_DW_SEL(i).s_AC;
            ELSE
              INSERT INTO WO_TASK_CARD_PN
              ( wo,
                task_card,
                pn,
                qty,
                QTY_RESERVED,
                MODIFIED_DATE )
              VALUES
              ( T_DW_SEL(i).n_wo,
                T_DW_SEL(i).s_task_card,
                T_DW_SEL(i).s_pn,
                T_DW_SEL(i).n_qty,
                T_DW_SEL(I).N_QTY_RESERVED,
                T_DW_SEL(I).DT_MODIFIED_DATE );
            END IF;

          end;
        end if;
      end loop;
    end if;
  end GF_SAVE_WO_TC_PN_ARRAY;



PROCEDURE GF_SAVE_DEFECT_PN_ARRAY(T_DW_SEL defect_pn_array)
  AS
  BEGIN
    IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
      FOR I IN T_DW_SEL.FIRST..T_DW_SEL.LAST
      LOOP
        IF  T_DW_SEL(I).S_DEFECT IS NOT NULL
        AND T_DW_SEL(I).S_DEFECT_TYPE IS NOT NULL
        AND T_DW_SEL(I).L_DEFECT_ITEM IS NOT NULL and T_DW_SEL(I).L_DEFECT_ITEM > 0
        AND T_DW_SEL(I).S_PN IS NOT NULL
       then

          DECLARE
            N_COUNT NUMBER := 0;
          BEGIN
            SELECT COUNT(*)
            INTO N_COUNT
            FROM DEFECT_REPORT_PN
            WHERE DEFECT = T_DW_SEL(I).S_DEFECT           
            AND  DEFECT_TYPE = T_DW_SEL(I).S_DEFECT_TYPE
            AND   DEFECT_ITEM = T_DW_SEL(I).L_DEFECT_ITEM 
             AND   PN = T_DW_SEL(I).S_PN ;

            IF N_COUNT > 0 THEN
              UPDATE DEFECT_REPORT_PN
              set  qty = T_DW_SEL(i).n_qty,
                  qty_reserved = T_DW_SEL(i).n_qty_reserved,
                  MODIFIED_DATE = T_DW_SEL(I).DT_MODIFIED_DATE
               WHERE DEFECT = T_DW_SEL(I).S_DEFECT           
                AND  DEFECT_TYPE = T_DW_SEL(I).S_DEFECT_TYPE
                AND   DEFECT_ITEM = T_DW_SEL(I).L_DEFECT_ITEM 
                AND   PN = T_DW_SEL(I).S_PN ;
--            ELSE
--              INSERT INTO DEFECT_REPORT_PN
--              ( wo,
--                task_card,
--                pn,
--                qty,
--                QTY_RESERVED,
--                MODIFIED_DATE )
--              VALUES
--              ( T_DW_SEL(i).n_wo,
--                T_DW_SEL(i).s_task_card,
--                T_DW_SEL(i).s_pn,
--                T_DW_SEL(i).n_qty,
--                T_DW_SEL(I).N_QTY_RESERVED,
--                T_DW_SEL(I).DT_MODIFIED_DATE );
           END IF;

          end;
        end if;
      end loop;
    end if;
  end GF_SAVE_DEFECT_PN_ARRAY;


  procedure GF_SAVE_TT_PICKLIST_DISTRIB(T_DW_EU PKG_TYPE_STRUCTURES.TT_PICKLIST_DISTRIBUTION)
  as
  BEGIN
    IF T_DW_EU IS NOT NULL AND T_DW_EU.COUNT > 0 THEN
      for i in T_DW_EU.first..T_DW_EU.last
      LOOP
        IF TRIM(T_DW_EU(I).TRANSACTION) IS NOT NULL 
        AND TRIM(T_DW_EU(I).PICKLIST) IS NOT NULL 
        AND TRIM(T_DW_EU(I).PICKLIST_LINE) IS NOT NULL
        AND TRIM(T_DW_EU(I).DISTRIBUTION_LINE) IS NOt NULL THEN
          declare
            N_COUNT NUMBER := 0;
          BEGIN
            SELECT COUNT(*)
            INTO N_COUNT
            FROM PICKLIST_DISTRIBUTION
            WHERE TRANSACTION = T_DW_EU(I).TRANSACTION
            AND   PICKLIST = T_DW_EU(I).PICKLIST
            AND   PICKLIST_LINE = T_DW_EU(I).PICKLIST_LINE
            AND   DISTRIBUTION_LINE = T_DW_EU(I).DISTRIBUTION_LINE;

            IF N_COUNT > 0 THEN
              UPDATE PICKLIST_DISTRIBUTION
              set TRANSACTION = T_DW_EU(i).TRANSACTION,
                  PICKLIST = T_DW_EU(i).PICKLIST,
                  PICKLIST_LINE = T_DW_EU(i).PICKLIST_LINE,
                  PN = T_DW_EU(i).PN,
                  QTY = T_DW_EU(i).QTY,
                  BATCH = T_DW_EU(i).BATCH,
                  CONDITION = T_DW_EU(i).CONDITION,
                  SN = T_DW_EU(i).SN,
                  DISTRIBUTION_LINE = T_DW_EU(i).DISTRIBUTION_LINE,
                  QTY_PICKED = T_DW_EU(i).QTY_PICKED,
                  NOTES = T_DW_EU(i).NOTES,
                  CREATED_BY = T_DW_EU(i).CREATED_BY,
                  CREATED_DATE = T_DW_EU(i).CREATED_DATE,
                  MODIFIED_BY = T_DW_EU(i).MODIFIED_BY,
                  MODIFIED_DATE = T_DW_EU(i).MODIFIED_DATE,
                  ORDER_LINE = T_DW_EU(i).ORDER_LINE,
                  STATUS = T_DW_EU(i).STATUS,
                  ORIGINAL_PICKLIST = T_DW_EU(i).ORIGINAL_PICKLIST,
                  TASK_CARD = T_DW_EU(i).TASK_CARD,
                  REQUISITION = T_DW_EU(i).REQUISITION,
                  REQUISITION_LINE = T_DW_EU(I).REQUISITION_LINE
              where TRANSACTION = T_DW_EU(I).TRANSACTION
              AND   PICKLIST = T_DW_EU(I).PICKLIST
              AND   PICKLIST_LINE = T_DW_EU(I).PICKLIST_LINE
              AND   DISTRIBUTION_LINE = T_DW_EU(I).DISTRIBUTION_LINE;

            else

              INSERT INTO PICKLIST_DISTRIBUTION
              ( TRANSACTION,
                PICKLIST,
                PICKLIST_LINE,
                PN,
                QTY,
                BATCH,
                CONDITION,
                SN,
                DISTRIBUTION_LINE,
                QTY_PICKED,
                NOTES,
                CREATED_BY,
                CREATED_DATE,
                MODIFIED_BY,
                MODIFIED_DATE,
                ORDER_LINE,
                STATUS,
                ORIGINAL_PICKLIST,
                TASK_CARD,
                REQUISITION,
                REQUISITION_LINE )
              VALUES
              ( T_DW_EU(i).TRANSACTION,
                T_DW_EU(i).PICKLIST,
                T_DW_EU(i).PICKLIST_LINE,
                T_DW_EU(i).PN,
                T_DW_EU(i).QTY,
                T_DW_EU(i).BATCH,
                T_DW_EU(i).CONDITION,
                T_DW_EU(i).SN,
                T_DW_EU(i).DISTRIBUTION_LINE,
                T_DW_EU(i).QTY_PICKED,
                T_DW_EU(i).NOTES,
                T_DW_EU(i).CREATED_BY,
                T_DW_EU(i).CREATED_DATE,
                T_DW_EU(i).MODIFIED_BY,
                T_DW_EU(i).MODIFIED_DATE,
                T_DW_EU(i).ORDER_LINE,
                T_DW_EU(i).STATUS,
                T_DW_EU(i).ORIGINAL_PICKLIST,
                T_DW_EU(i).TASK_CARD,
                T_DW_EU(I).REQUISITION,
                T_DW_EU(I).REQUISITION_LINE );

            end if;

          end;
        end if;
      end loop;
    end if;
  END GF_SAVE_TT_PICKLIST_DISTRIB;

  PROCEDURE GF_SAVE_DW_INVENTORY_TRAN_AVL(DW_PN_INVENTORY_AVL  IN OUT NOCOPY PKG_TYPE_STRUCTURES.DW_INVENTORY_TRAN_AVL)
  AS
  BEGIN
    IF DW_PN_INVENTORY_AVL IS NOT NULL AND DW_PN_INVENTORY_AVL.COUNT > 0 THEN
      FOR I IN DW_PN_INVENTORY_AVL.FIRST..DW_PN_INVENTORY_AVL.LAST
      LOOP
        IF NVL(DW_PN_INVENTORY_AVL(I).BATCH, 0) > 0 THEN
          DECLARE
            N_COUNT NUMBER := 0;
          BEGIN
            SELECT COUNT(*)
            INTO N_COUNT
            FROM PN_INVENTORY_DETAIL
            where batch = DW_PN_INVENTORY_AVL(I).BATCH;

            IF N_COUNT > 0 THEN
              UPDATE PN_INVENTORY_DETAIL
              set GOODS_RCVD_BATCH = DW_PN_INVENTORY_AVL(I).GOODS_RCVD_BATCH,
                  VENDOR_LOT = DW_PN_INVENTORY_AVL(I).VENDOR_LOT,
                  PN = DW_PN_INVENTORY_AVL(I).PN,
                  SN = DW_PN_INVENTORY_AVL(I).SN,
                  NHA_PN = DW_PN_INVENTORY_AVL(I).NHA_PN,
                  NHA_SN = DW_PN_INVENTORY_AVL(I).NHA_SN,
                  CONDITION = DW_PN_INVENTORY_AVL(I).CONDITION,
                  OWNER = DW_PN_INVENTORY_AVL(I).OWNER,
                  UNIT_COST = DW_PN_INVENTORY_AVL(I).UNIT_COST,
                  CURRENCY = DW_PN_INVENTORY_AVL(I).CURRENCY,
                  APPROVED_CERTIFICATE = DW_PN_INVENTORY_AVL(I).APPROVED_CERTIFICATE,
                  RI_BY = DW_PN_INVENTORY_AVL(I).RI_BY,
                  RI_DATE = DW_PN_INVENTORY_AVL(I).RI_DATE,
                  INSTALLED_AC = DW_PN_INVENTORY_AVL(I).INSTALLED_AC,
                  INSTALLED_POSITION = DW_PN_INVENTORY_AVL(I).INSTALLED_POSITION,
                  INSTALLED_DATE = DW_PN_INVENTORY_AVL(I).INSTALLED_DATE,
                  INSTALLED_HOUR = DW_PN_INVENTORY_AVL(I).INSTALLED_HOUR,
                  INSTALLED_MINUTE = DW_PN_INVENTORY_AVL(I).INSTALLED_MINUTE,
                  LOCATION = DW_PN_INVENTORY_AVL(I).LOCATION,
                  BIN = DW_PN_INVENTORY_AVL(I).BIN,
                  QTY_AVAILABLE = DW_PN_INVENTORY_AVL(I).QTY_AVAILABLE,
                  QTY_RESERVED = DW_PN_INVENTORY_AVL(I).QTY_RESERVED,
                  QTY_IN_TRANSFER = DW_PN_INVENTORY_AVL(I).QTY_IN_TRANSFER,
                  QTY_PENDING_RI = DW_PN_INVENTORY_AVL(I).QTY_PENDING_RI,
                  QTY_US = DW_PN_INVENTORY_AVL(I).QTY_US,
                  QTY_IN_REPAIR = DW_PN_INVENTORY_AVL(I).QTY_IN_REPAIR,
                  RI_CONTROL = DW_PN_INVENTORY_AVL(I).RI_CONTROL,
                  US_CODE = DW_PN_INVENTORY_AVL(I).US_CODE,
                  SHELF_LIFE_EXPIRATION = DW_PN_INVENTORY_AVL(I).SHELF_LIFE_EXPIRATION,
                  TOOL_LIFE_EXPIRATION = DW_PN_INVENTORY_AVL(I).TOOL_LIFE_EXPIRATION,
                  LOAN_CATEGORY = DW_PN_INVENTORY_AVL(I).LOAN_CATEGORY,
                  CUTOM_DUTY_CODE = DW_PN_INVENTORY_AVL(I).CUTOM_DUTY_CODE,
                  GL_COMPANY = DW_PN_INVENTORY_AVL(I).GL_COMPANY,
                  GL_EXPENDITURE = DW_PN_INVENTORY_AVL(I).GL_EXPENDITURE,
                  GL = DW_PN_INVENTORY_AVL(I).GL,
                  GL_COST_CENTER = DW_PN_INVENTORY_AVL(I).GL_COST_CENTER,
                  NOTES = DW_PN_INVENTORY_AVL(I).NOTES,
                  CREATED_BY = DW_PN_INVENTORY_AVL(I).CREATED_BY,
                  CREATED_DATE = DW_PN_INVENTORY_AVL(I).CREATED_DATE,
                  MODIFIED_BY = DW_PN_INVENTORY_AVL(I).MODIFIED_BY,
                  MODIFIED_DATE = DW_PN_INVENTORY_AVL(I).MODIFIED_DATE,
                  PHYSICAL_COUNT_DATE = DW_PN_INVENTORY_AVL(I).PHYSICAL_COUNT_DATE,
                  KIT_NO = DW_PN_INVENTORY_AVL(I).KIT_NO,
                  CURRENCY_EXCHANGE_RATE = DW_PN_INVENTORY_AVL(I).CURRENCY_EXCHANGE_RATE,
                  QTY_IN_RENTAL = DW_PN_INVENTORY_AVL(I).QTY_IN_RENTAL,
                  SECONDARY_COST = DW_PN_INVENTORY_AVL(I).SECONDARY_COST,
                  SECONDARY_CURRENCY_EXCHANGE = DW_PN_INVENTORY_AVL(I).SECONDARY_CURRENCY_EXCHANGE,
                  BLOB_NO = DW_PN_INVENTORY_AVL(I).BLOB_NO,
                  ORIGINAL_AC = DW_PN_INVENTORY_AVL(I).ORIGINAL_AC,
                  MOD_STATUS = DW_PN_INVENTORY_AVL(I).MOD_STATUS,
                  CUSTOM_DUTY_DOCUMENT = DW_PN_INVENTORY_AVL(I).CUSTOM_DUTY_DOCUMENT,
                  PENDING = DW_PN_INVENTORY_AVL(I).PENDING,
                  PENDING_DATE = DW_PN_INVENTORY_AVL(I).PENDING_DATE,
                  APPROVED_CERTIFICATE_ORIGINAL = DW_PN_INVENTORY_AVL(I).APPROVED_CERTIFICATE_ORIGINAL,
                  SOS_DATE = DW_PN_INVENTORY_AVL(I).SOS_DATE,
                  SOS_HOUR = DW_PN_INVENTORY_AVL(I).SOS_HOUR,
                  SOS_MINUTE = DW_PN_INVENTORY_AVL(I).SOS_MINUTE,
                  TAG_BY = DW_PN_INVENTORY_AVL(I).TAG_BY,
                  TAG_DATE = DW_PN_INVENTORY_AVL(I).TAG_DATE,
                  TAG_NO = DW_PN_INVENTORY_AVL(I).TAG_NO,
                  ORIGINAL_RECORDS_BY = DW_PN_INVENTORY_AVL(I).ORIGINAL_RECORDS_BY,
                  ORGINAL_RECORDS_DATE = DW_PN_INVENTORY_AVL(I).ORGINAL_RECORDS_DATE,
                  ACCOUNTING_DOCUMENT = DW_PN_INVENTORY_AVL(I).ACCOUNTING_DOCUMENT,
                  ACCOUNTING_DOCUMENT_DATE = DW_PN_INVENTORY_AVL(I).ACCOUNTING_DOCUMENT_DATE,
                  PN_MODEL = DW_PN_INVENTORY_AVL(I).PN_MODEL,
                  PN_SOFTWARE = DW_PN_INVENTORY_AVL(I).PN_SOFTWARE,
                  FILING_SEQUENCE = DW_PN_INVENTORY_AVL(I).FILING_SEQUENCE,
                  NO_OF_TAG_PRINT = DW_PN_INVENTORY_AVL(I).NO_OF_TAG_PRINT,
                  OWNER_ORIGIN = DW_PN_INVENTORY_AVL(I).OWNER_ORIGIN,
                  NLA_POSITION = DW_PN_INVENTORY_AVL(I).NLA_POSITION,
                  INITIAL_TSI_HOURS = DW_PN_INVENTORY_AVL(I).INITIAL_TSI_HOURS,
                  INITIAL_TSI_MINUTES = DW_PN_INVENTORY_AVL(I).INITIAL_TSI_MINUTES,
                  INITIAL_TSI_CYCLES = DW_PN_INVENTORY_AVL(I).INITIAL_TSI_CYCLES,
                  INITIAL_TSI_DAYS = DW_PN_INVENTORY_AVL(I).INITIAL_TSI_DAYS,
                  TOOL_LIFE_EXPIRATION_LAST = DW_PN_INVENTORY_AVL(I).TOOL_LIFE_EXPIRATION_LAST,
                  INVENTORY_TYPE = DW_PN_INVENTORY_AVL(I).INVENTORY_TYPE,
                  DOCUMENT_NO = DW_PN_INVENTORY_AVL(I).DOCUMENT_NO,
                  SHELF_LIFE_EXPIRATION_LAST = DW_PN_INVENTORY_AVL(I).SHELF_LIFE_EXPIRATION_LAST,
                  SLOT = DW_PN_INVENTORY_AVL(I).SLOT,
                  COST_IN_KIT = DW_PN_INVENTORY_AVL(I).COST_IN_KIT,
                  REPAIR_RETURN_DATE = DW_PN_INVENTORY_AVL(I).REPAIR_RETURN_DATE,
                  HAZARDOUS_MATERIAL_AT_REMOVAl = DW_PN_INVENTORY_AVL(I).HAZARDOUS_MATERIAL_AT_REMOVAl,
                  WEIGHT = DW_PN_INVENTORY_AVL(I).WEIGHT,
                  WEIGHT_UNIT = DW_PN_INVENTORY_AVL(I).WEIGHT_UNIT,
                  MANAGED_WO = DW_PN_INVENTORY_AVL(I).MANAGED_WO,
                  PHYSICAL_COUNT_BY = DW_PN_INVENTORY_AVL(I).PHYSICAL_COUNT_BY,
                  ORIGINAL_AC_ISSUE_TO_ONLY = DW_PN_INVENTORY_AVL(I).ORIGINAL_AC_ISSUE_TO_ONLY,
                  SHELF_LIFE_EXP_EOM = DW_PN_INVENTORY_AVL(I).SHELF_LIFE_EXP_EOM,
                  TOOL_LIFE_EXP_EOM = DW_PN_INVENTORY_AVL(I).TOOL_LIFE_EXP_EOM,
                  LEGACY_BATCH = DW_PN_INVENTORY_AVL(I).LEGACY_BATCH,
                  ADJUSTMENT_CODE = DW_PN_INVENTORY_AVL(I).ADJUSTMENT_CODE
              WHERE BATCH = DW_PN_INVENTORY_AVL(I).BATCH;
            ELSE
              INSERT INTO PN_INVENTORY_DETAIL
              ( BATCH,
                GOODS_RCVD_BATCH,   
                VENDOR_LOT,   
                PN,   
                SN,   
                NHA_PN,   
                NHA_SN,   
                CONDITION,   
                OWNER,   
                UNIT_COST,   
                CURRENCY,   
                APPROVED_CERTIFICATE,   
                RI_BY,   
                RI_DATE,   
                INSTALLED_AC,   
                INSTALLED_POSITION,   
                INSTALLED_DATE,   
                INSTALLED_HOUR,   
                INSTALLED_MINUTE,   
                LOCATION,   
                BIN,   
                QTY_AVAILABLE,   
                QTY_RESERVED,   
                QTY_IN_TRANSFER,   
                QTY_PENDING_RI,   
                QTY_US,   
                QTY_IN_REPAIR,   
                RI_CONTROL,   
                US_CODE,   
                SHELF_LIFE_EXPIRATION,   
                TOOL_LIFE_EXPIRATION,   
                LOAN_CATEGORY,   
                CUTOM_DUTY_CODE,   
                GL_COMPANY,   
                GL_EXPENDITURE,   
                GL,   
                GL_COST_CENTER,   
                NOTES,   
                CREATED_BY,   
                CREATED_DATE,   
                MODIFIED_BY,   
                MODIFIED_DATE,   
                PHYSICAL_COUNT_DATE,   
                KIT_NO,   
                CURRENCY_EXCHANGE_RATE,   
                QTY_IN_RENTAL,   
                SECONDARY_COST,   
                SECONDARY_CURRENCY_EXCHANGE,   
                BLOB_NO,   
                ORIGINAL_AC,   
                MOD_STATUS,   
                CUSTOM_DUTY_DOCUMENT,   
                PENDING,   
                PENDING_DATE,   
                APPROVED_CERTIFICATE_ORIGINAL,   
                SOS_DATE,   
                SOS_HOUR,   
                SOS_MINUTE,   
                TAG_BY,   
                TAG_DATE,   
                TAG_NO,   
                ORIGINAL_RECORDS_BY,   
                ORGINAL_RECORDS_DATE,   
                ACCOUNTING_DOCUMENT,   
                ACCOUNTING_DOCUMENT_DATE,   
                PN_MODEL,   
                PN_SOFTWARE,   
                FILING_SEQUENCE,   
                NO_OF_TAG_PRINT,   
                OWNER_ORIGIN,   
                NLA_POSITION,   
                INITIAL_TSI_HOURS,   
                INITIAL_TSI_MINUTES,   
                INITIAL_TSI_CYCLES,   
                INITIAL_TSI_DAYS,   
                TOOL_LIFE_EXPIRATION_LAST,   
                INVENTORY_TYPE,   
                DOCUMENT_NO,   
                SHELF_LIFE_EXPIRATION_LAST,   
                SLOT,
                COST_IN_KIT,   
                REPAIR_RETURN_DATE,   
                HAZARDOUS_MATERIAL_AT_REMOVAl,   
                WEIGHT,   
                WEIGHT_UNIT,   
                MANAGED_WO,   
                PHYSICAL_COUNT_BY,   
                ORIGINAL_AC_ISSUE_TO_ONLY,   
                SHELF_LIFE_EXP_EOM,   
                TOOL_LIFE_EXP_EOM,   
                LEGACY_BATCH,   
                ADJUSTMENT_CODE )
              VALUES
              ( DW_PN_INVENTORY_AVL(I).BATCH,
                DW_PN_INVENTORY_AVL(I).GOODS_RCVD_BATCH,
                DW_PN_INVENTORY_AVL(I).VENDOR_LOT,
                DW_PN_INVENTORY_AVL(I).PN,
                DW_PN_INVENTORY_AVL(I).SN,
                DW_PN_INVENTORY_AVL(I).NHA_PN,
                DW_PN_INVENTORY_AVL(I).NHA_SN,
                DW_PN_INVENTORY_AVL(I).CONDITION,
                DW_PN_INVENTORY_AVL(I).OWNER,
                DW_PN_INVENTORY_AVL(I).UNIT_COST,
                DW_PN_INVENTORY_AVL(I).CURRENCY,
                DW_PN_INVENTORY_AVL(I).APPROVED_CERTIFICATE,
                DW_PN_INVENTORY_AVL(I).RI_BY,
                DW_PN_INVENTORY_AVL(I).RI_DATE,
                DW_PN_INVENTORY_AVL(I).INSTALLED_AC,
                DW_PN_INVENTORY_AVL(I).INSTALLED_POSITION,
                DW_PN_INVENTORY_AVL(I).INSTALLED_DATE,
                DW_PN_INVENTORY_AVL(I).INSTALLED_HOUR,
                DW_PN_INVENTORY_AVL(I).INSTALLED_MINUTE,
                DW_PN_INVENTORY_AVL(I).LOCATION,
                DW_PN_INVENTORY_AVL(I).BIN,
                DW_PN_INVENTORY_AVL(I).QTY_AVAILABLE,
                DW_PN_INVENTORY_AVL(I).QTY_RESERVED,
                DW_PN_INVENTORY_AVL(I).QTY_IN_TRANSFER,
                DW_PN_INVENTORY_AVL(I).QTY_PENDING_RI,
                DW_PN_INVENTORY_AVL(I).QTY_US,
                DW_PN_INVENTORY_AVL(I).QTY_IN_REPAIR,
                DW_PN_INVENTORY_AVL(I).RI_CONTROL,
                DW_PN_INVENTORY_AVL(I).US_CODE,
                DW_PN_INVENTORY_AVL(I).SHELF_LIFE_EXPIRATION,
                DW_PN_INVENTORY_AVL(I).TOOL_LIFE_EXPIRATION,
                DW_PN_INVENTORY_AVL(I).LOAN_CATEGORY,
                DW_PN_INVENTORY_AVL(I).CUTOM_DUTY_CODE,
                DW_PN_INVENTORY_AVL(I).GL_COMPANY,
                DW_PN_INVENTORY_AVL(I).GL_EXPENDITURE,
                DW_PN_INVENTORY_AVL(I).GL,
                DW_PN_INVENTORY_AVL(I).GL_COST_CENTER,
                DW_PN_INVENTORY_AVL(I).NOTES,
                DW_PN_INVENTORY_AVL(I).CREATED_BY,
                DW_PN_INVENTORY_AVL(I).CREATED_DATE,
                DW_PN_INVENTORY_AVL(I).MODIFIED_BY,
                DW_PN_INVENTORY_AVL(I).MODIFIED_DATE,
                DW_PN_INVENTORY_AVL(I).PHYSICAL_COUNT_DATE,
                DW_PN_INVENTORY_AVL(I).KIT_NO,
                DW_PN_INVENTORY_AVL(I).CURRENCY_EXCHANGE_RATE,
                DW_PN_INVENTORY_AVL(I).QTY_IN_RENTAL,
                DW_PN_INVENTORY_AVL(I).SECONDARY_COST,
                DW_PN_INVENTORY_AVL(I).SECONDARY_CURRENCY_EXCHANGE,
                DW_PN_INVENTORY_AVL(I).BLOB_NO,
                DW_PN_INVENTORY_AVL(I).ORIGINAL_AC,
                DW_PN_INVENTORY_AVL(I).MOD_STATUS,
                DW_PN_INVENTORY_AVL(I).CUSTOM_DUTY_DOCUMENT,
                DW_PN_INVENTORY_AVL(I).PENDING,
                DW_PN_INVENTORY_AVL(I).PENDING_DATE,
                DW_PN_INVENTORY_AVL(I).APPROVED_CERTIFICATE_ORIGINAL,
                DW_PN_INVENTORY_AVL(I).SOS_DATE,
                DW_PN_INVENTORY_AVL(I).SOS_HOUR,
                DW_PN_INVENTORY_AVL(I).SOS_MINUTE,
                DW_PN_INVENTORY_AVL(I).TAG_BY,
                DW_PN_INVENTORY_AVL(I).TAG_DATE,
                DW_PN_INVENTORY_AVL(I).TAG_NO,
                DW_PN_INVENTORY_AVL(I).ORIGINAL_RECORDS_BY,
                DW_PN_INVENTORY_AVL(I).ORGINAL_RECORDS_DATE,
                DW_PN_INVENTORY_AVL(I).ACCOUNTING_DOCUMENT,
                DW_PN_INVENTORY_AVL(I).ACCOUNTING_DOCUMENT_DATE,
                DW_PN_INVENTORY_AVL(I).PN_MODEL,
                DW_PN_INVENTORY_AVL(I).PN_SOFTWARE,
                DW_PN_INVENTORY_AVL(I).FILING_SEQUENCE,
                DW_PN_INVENTORY_AVL(I).NO_OF_TAG_PRINT,
                DW_PN_INVENTORY_AVL(I).OWNER_ORIGIN,
                DW_PN_INVENTORY_AVL(I).NLA_POSITION,
                DW_PN_INVENTORY_AVL(I).INITIAL_TSI_HOURS,
                DW_PN_INVENTORY_AVL(I).INITIAL_TSI_MINUTES,
                DW_PN_INVENTORY_AVL(I).INITIAL_TSI_CYCLES,
                DW_PN_INVENTORY_AVL(I).INITIAL_TSI_DAYS,
                DW_PN_INVENTORY_AVL(I).TOOL_LIFE_EXPIRATION_LAST,
                DW_PN_INVENTORY_AVL(I).INVENTORY_TYPE,
                DW_PN_INVENTORY_AVL(I).DOCUMENT_NO,
                DW_PN_INVENTORY_AVL(I).SHELF_LIFE_EXPIRATION_LAST,
                DW_PN_INVENTORY_AVL(I).SLOT,
                DW_PN_INVENTORY_AVL(I).COST_IN_KIT,
                DW_PN_INVENTORY_AVL(I).REPAIR_RETURN_DATE,
                DW_PN_INVENTORY_AVL(I).HAZARDOUS_MATERIAL_AT_REMOVAl,
                DW_PN_INVENTORY_AVL(I).WEIGHT,
                DW_PN_INVENTORY_AVL(I).WEIGHT_UNIT,
                DW_PN_INVENTORY_AVL(I).MANAGED_WO,
                DW_PN_INVENTORY_AVL(I).PHYSICAL_COUNT_BY,
                DW_PN_INVENTORY_AVL(I).ORIGINAL_AC_ISSUE_TO_ONLY,
                DW_PN_INVENTORY_AVL(I).SHELF_LIFE_EXP_EOM,
                DW_PN_INVENTORY_AVL(I).TOOL_LIFE_EXP_EOM,
                DW_PN_INVENTORY_AVL(I).LEGACY_BATCH,
                DW_PN_INVENTORY_AVL(I).ADJUSTMENT_CODE );
            end if;

          end;
        end if;
      END LOOP;
    END IF;
  END GF_SAVE_DW_INVENTORY_TRAN_AVL;

  function OF_PICKLIST_DISTRIBUTION2(DW_PN_INVENTORY_AVL IN OUT NOCOPY PKG_TYPE_STRUCTURES.DW_INVENTORY_TRAN_AVL, DW_EU IN OUT NOCOPY PICKLIST_DISTRIBUTION%ROWTYPE,
                                     DW_PICKLIST_DETAIL IN OUT NOCOPY PICKLIST_DISTRIBUTION%ROWTYPE, MS_PN IN OUT NOCOPY PKG_TYPE_STRUCTURES.ST_PN, IS_ERRFLD IN OUT NOCOPY VARCHAR2,
                                     IS_ORIGINAL in out nocopy varchar2, gs_user in out nocopy varchar2, gs_company_multi in out nocopy varchar2) return PICKLIST_DISTRIBUTION%ROWTYPE
  AS
    DT_TODAY DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    MS_PN_HISTORY PKG_TYPE_STRUCTURES.ST_PN;
    MS_PN_HISTORY_EMPTY PKG_TYPE_STRUCTURES.ST_PN;
    IS_WOPKLNLA VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPKLNLA');
    l_batch NUMBER;
    l_line NUMBER;
    l_notes NUMBER;
    l_wo NUMBER;
    L_MYBATCH NUMBER;
    TYPE T_N IS TABLE OF NUMBER;
    L_BATCHES t_n := t_n();
    L_NEW_BATCH NUMBER;
    d_qty NUMBER;
    d_qty_rtn NUMBER;
    d_qty_rsv NUMBER;
    d_qty_available NUMBER;
    D_QTY_RESERVED NUMBER;
    S_BIN_TRANSFER VARCHAR2(100);
    S_BIN VARCHAR2(100);
    S_CURRENT_BIN VARCHAR2(100);
    S_CURRENT_LOCATION VARCHAR2(100);
    s_condition VARCHAR2(100);
    s_sn VARCHAR2(100);
    s_pn VARCHAR2(100);
    s_task_card VARCHAR2(100);
    s_location_header VARCHAR2(100);
    s_build_kit_header VARCHAR2(100);
    s_task_card_pn VARCHAR2(100);
    s_task_card_sn VARCHAR2(100);
    S_USER VARCHAR2(100);
    S_INVENTORY_QUARANTINE VARCHAR2(100);
    profile_name varchar2(200);
    --t_dw_eu PKG_TYPE_STRUCTURES.tt_picklist_distribution := PKG_TYPE_STRUCTURES.tt_picklist_distribution();
    t_dw_eu PICKLIST_DISTRIBUTION%ROWTYPE;
  BEGIN

    IF NVL(MS_PN.S_WALL_PASSWORD,' ') = ' ' THEN
      s_user := gs_user;
    ELSE
      S_USER := MS_PN.S_WALL_PASSWORD;
    End If;

    SELECT "PICKLIST_HEADER"."WO",
        "PICKLIST_HEADER"."TASK_CARD",
        "PICKLIST_HEADER"."TASK_CARD_PN",
        "PICKLIST_HEADER"."TASK_CARD_SN",
        "PICKLIST_HEADER"."LOCATION",
        "PICKLIST_HEADER"."BUILD_KIT",
        NVL("PICKLIST_HEADER"."BIN_TRANSFER",'N'),
        "PICKLIST_HEADER"."BIN"
    INTO l_wo,
        s_task_card,
        s_task_card_pn,
        s_task_card_sn,
        s_location_header,
        s_build_kit_header,
        s_bin_transfer,
        s_bin
    FROM "PICKLIST_HEADER"
    WHERE "PICKLIST_HEADER"."PICKLIST" = ms_pn.n_picklist;

    SELECT NVL("LOCATION_MASTER"."INVENTORY_QUARANTINE",'N')
      INTO s_inventory_quarantine
      FROM "LOCATION_MASTER"
     WHERE "LOCATION_MASTER"."LOCATION" = s_location_header;

    IF NVL(MS_PN.n_PICKLIST_DISTRIBUTION_LINE,0) = 0 THEN
      l_line := dw_eu.picklist_line;
    ELSE
      L_LINE := MS_PN.n_PICKLIST_LINE;
    End If;

    MS_PN.n_PICKLIST_LINE := L_LINE;
    of_picklist_detail(ms_pn);

    IF NVL(MS_PN.n_PICKLIST_DISTRIBUTION_LINE, 0) = 0 THEN
      D_QTY  := DW_EU.QTY;
      L_BATCH := DW_EU.BATCH;
      S_CONDITION := DW_EU.CONDITION;
      S_SN := DW_EU.SN;
      S_PN  := DW_EU.PN;
      l_notes := dw_eu.notes;
    ELSE
      D_QTY := MS_PN.N_QTY;
      L_BATCH := MS_PN.N_BATCH;
      S_CONDITION := ' ';
      S_SN := MS_PN.S_SN;
      S_PN := MS_PN.S_PN;
      L_NOTES := MS_PN.n_NOTES;
    End If;

    S_BIN := NVL(S_BIN,' ');
    If s_bin = ' ' Then s_bin_transfer := 'N'; end if;

    MS_PN.S_PN := S_PN;
    MS_PN.S_CONDITION := S_CONDITION;
    MS_PN.S_SN := S_SN;
    MS_PN.N_BATCH := L_BATCH;
    MS_PN.N_WO := L_WO;
    ms_pn.s_effectivity := 'Y';

    IF S_BUILD_KIT_HEADER = 'YES' THEN
      MS_PN.S_LOCATION := S_LOCATION_HEADER;
      MS_PN.S_BUILD_KIT := S_BUILD_KIT_HEADER;
    End If;

    MS_PN.S_ORIGINAL_AC := 'YES';
    ms_pn.s_effectivity := 'Y';

    if ms_pn.s_order_type = 'S/O' then

      begin
        SELECT "SYSTEM_TRAN_CODE"."COMPANY"
        INTO ms_pn.s_gl_company
        FROM "CUSTOMER_ORDER_HEADER",
            "SYSTEM_TRAN_CODE"
        WHERE "SYSTEM_TRAN_CODE"."SYSTEM_CODE"          = "CUSTOMER_ORDER_HEADER"."COMPANY"
        AND "SYSTEM_TRANSACTION"                      = 'ORDERCATEGORY'
        AND "SYSTEM_TRAN_CODE"."SYSTEM_TRAN_CODE_SUB" = '          '
        AND "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER"   = MS_PN.N_SO_NUMBER;
      EXCEPTION
      WHEN OTHERS THEN
        ms_pn.s_gl_company := null;
      end;
    else

      begin
        SELECT "SYSTEM_TRAN_CODE"."COMPANY"
        INTO ms_pn.s_gl_company
        FROM "WO",
               "SYSTEM_TRAN_CODE"
        WHERE "SYSTEM_TRAN_CODE"."SYSTEM_CODE"          = "WO"."GL_COMPANY"
        AND "SYSTEM_TRANSACTION"                      = 'ORDERCATEGORY'
        AND "SYSTEM_TRAN_CODE"."SYSTEM_TRAN_CODE_SUB" = '          '
        AND "WO"."WO"                  = l_wo;
      EXCEPTION
      WHEN OTHERS THEN
        MS_PN.S_GL_COMPANY := NULL;
      end;
    end if;

    IF S_INVENTORY_QUARANTINE = 'Y' THEN
      d_qty_rtn := GF_INVENTORY_AVAiLABLE(DW_PN_INVENTORY_AVL, MS_PN, IS_ORIGINAL, gs_company_multi, true);
      null;
    ELSE
      D_QTY_RTN := GF_INVENTORY_AVAiLABLE(DW_PN_INVENTORY_AVL, MS_PN, IS_ORIGINAL, gs_company_multi);
    End If;

  --  If d_qty > d_qty_rtn Then 	d_qty := d_qty_rtn; end if;

    IF DW_PN_INVENTORY_AVL IS NOT NULL AND DW_PN_INVENTORY_AVL.COUNT > 0 THEN
      DECLARE
       B_CONTINUE BOOLEAN := FALSE;
       AVL_1 NUMBER := 0;
       US_1 NUMBER := 0;
       L_GOODS_RCVD_BATCH NUMBER;
       S_PN_DIST VARCHAR2(100);
       S_SN_DIST VARCHAR2(100);
       S_LOCATION_DIST VARCHAR2(100);
       S_BIN_DIST VARCHAR2(100);
       S_CONDITION_DIST VARCHAR2(100);
       L_IROW NUMBER;
       L_PICKLIST_DISTRIBUTION_LINE number;
      begin
        FOR l_CROW IN DW_PN_INVENTORY_AVL.FIRST..DW_PN_INVENTORY_AVL.LAST
        LOOP
          IF D_QTY > 0 THEN
            IF S_INVENTORY_QUARANTINE = 'N' THEN

              IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) IS NULL THEN
                  avl_1 := dw_pn_inventory_avl(l_crow).qty_available;
              ELSE
                IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) <> 'MANAGE' THEN
                  avl_1 := dw_pn_inventory_avl(l_crow).qty_available;
                ELSE
                  IF NVL(TRIM(MS_PN.S_OWNER), ' ') = NVL (TRIM(DW_PN_INVENTORY_AVL(l_crow).OWNER), ' ') THEN
                    avl_1 := dw_pn_inventory_avl(l_crow).qty_available;
                  ELSE
                    avl_1 := 0;
                  end if;
                END IF;
              END IF;

              IF AVL_1  = 0 THEN B_CONTINUE := TRUE; END IF;
              d_qty_available := dw_pn_inventory_avl(l_crow).qty_available;
            Else

              IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) IS NULL THEN
                  us_1 := dw_pn_inventory_avl(l_crow).qty_us;
              ELSE
                IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) <> 'MANAGE' THEN
                  us_1 := dw_pn_inventory_avl(l_crow).qty_us;
                ELSE
                  IF NVL(TRIM(MS_PN.S_OWNER), ' ') = NVL (TRIM(DW_PN_INVENTORY_AVL(l_crow).OWNER), ' ') THEN
                    us_1 := dw_pn_inventory_avl(l_crow).qty_us;
                  ELSE
                    us_1 := 0;
                  end if;
                END IF;
              END IF;

              IF US_1  = 0 THEN B_CONTINUE := TRUE; END IF;
              D_QTY_AVAILABLE := DW_PN_INVENTORY_AVL(L_CROW).qty_us;
            End If;

            IF NOT B_CONTINUE THEN

              d_qty_reserved := dw_pn_inventory_avl(l_crow).qty_reserved;

              IF TRIM(D_QTY_AVAILABLE) IS NULL THEN D_QTY_AVAILABLE := 0; END IF;
              IF TRIM(D_QTY_RESERVED) IS NULL THEN D_QTY_RESERVED := 0; END IF;
              if trim(d_qty) is null Then d_qty := 0; end if;

              L_BATCH := DW_PN_INVENTORY_AVL(L_CROW).BATCH;
              S_CURRENT_LOCATION := DW_PN_INVENTORY_AVL(L_CROW).LOCATION;
              S_CURRENT_BIN := DW_PN_INVENTORY_AVL(L_CROW).BIN;
              l_new_batch := 0;

              IF D_QTY > D_QTY_AVAILABLE THEN

                D_QTY := D_QTY - D_QTY_AVAILABLE;
                D_QTY_RESERVED := D_QTY_RESERVED + D_QTY_AVAILABLE;
                dw_pn_inventory_avl(l_crow).qty_reserved := d_qty_reserved;

                IF S_INVENTORY_QUARANTINE = 'N' THEN
                  dw_pn_inventory_avl(l_crow).qty_available := 0;
                ELSE
                  DW_PN_INVENTORY_AVL(L_CROW).qty_us := 0;
                End If;

                d_qty_rsv := d_qty_available;

                IF S_BIN_TRANSFER = 'Y' AND (S_LOCATION_HEADER = S_CURRENT_LOCATION) AND (S_CURRENT_BIN <> S_BIN) THEN
                  DW_PN_INVENTORY_AVL(L_CROW).bin := S_BIN;
                End If;

              ELSIF D_QTY_AVAILABLE > 0 THEN
                  --TEST LOG 150548 modified
                  BEGIN
                    SELECT "PROFILE"
                    INTO PROFILE_NAME
                    from PROFILE_MASTER;
                  EXCEPTION
                  WHEN OTHERS THEN
                    PROFILE_NAME := NULL;
                  END;

                IF(PROFILE_NAME = 'SWA' and IS_WOPKLNLA = 'Y')
                then
                  --D_QTY_AVAILABLE := D_QTY_AVAILABLE - D_QTY ;
                   D_QTY_AVAILABLE := D_QTY_AVAILABLE - DW_EU.qty_picked;
                  --D_QTY_RESERVED := D_QTY_RESERVED + D_QTY ;
                  D_QTY_RESERVED := D_QTY_RESERVED + DW_EU.qty_picked;
                else
                  D_QTY_AVAILABLE := D_QTY_AVAILABLE - D_QTY ;
                  D_QTY_RESERVED := D_QTY_RESERVED + D_QTY ;

                end if;
                --TEST LOG 150548 modified
                dw_pn_inventory_avl(l_crow).qty_reserved := d_qty_reserved;

                IF S_INVENTORY_QUARANTINE = 'N' THEN
                  dw_pn_inventory_avl(l_crow).qty_available := d_qty_available;
                ELSE
                  DW_PN_INVENTORY_AVL(L_CROW).QTY_US := D_QTY_AVAILABLE;
                END IF;

                D_QTY_RSV := D_QTY;
                D_QTY := 0;

                If s_bin_transfer = 'Y' and (s_location_header = s_current_location) and (s_current_bin <> s_bin) Then
                  If d_qty_available = 0 Then
                    dw_pn_inventory_avl(l_crow).bin := s_bin;
                  ELSE
                    DW_PN_INVENTORY_AVL.EXTEND;
                    DW_PN_INVENTORY_AVL(DW_PN_INVENTORY_AVL.LAST) := DW_PN_INVENTORY_AVL(L_CROW);
                    DW_PN_INVENTORY_AVL(DW_PN_INVENTORY_AVL.LAST).BIN := S_BIN;
                    L_NEW_BATCH := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('BATCH');
                    DW_PN_INVENTORY_AVL(DW_PN_INVENTORY_AVL.LAST).BATCH := L_NEW_BATCH;
                    dw_pn_inventory_avl(l_crow).qty_reserved := 0;
                    IF S_INVENTORY_QUARANTINE = 'N' THEN
                      dw_pn_inventory_avl(dw_pn_inventory_avl.last).qty_available := 0;
                    ELSE
                      dw_pn_inventory_avl(dw_pn_inventory_avl.last).qty_us := 0;
                    End If;
                  End If;
                End If;
              ELSE
                B_CONTINUE := true;
              End If;

              IF NOT B_CONTINUE THEN
                S_PN_DIST := NULL;
                s_sn_dist := null;

                if trim(l_batch) is not null then

                  SELECT "PN_INVENTORY_DETAIL"."PN",
                      "PN_INVENTORY_DETAIL"."SN",
                      "PN_INVENTORY_DETAIL"."LOCATION",
                      "PN_INVENTORY_DETAIL"."BIN",
                      "PN_INVENTORY_DETAIL"."CONDITION",
                      "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH"
                  INTO s_pn_dist,
                      s_sn_dist,
                      s_location_dist,
                      s_bin_dist,
                      s_condition_dist,
                      l_goods_rcvd_batch
                  FROM "PN_INVENTORY_DETAIL"
                  WHERE "PN_INVENTORY_DETAIL"."BATCH" = l_batch;

                end if;

                If nvl(l_new_batch,0) > 0 Then l_batch := l_new_batch; end if;

                dt_today := pkg_application_function.currentdatetime;

                --T_DW_EU.EXTEND;
                --L_IROW := T_DW_EU.LAST;
                T_DW_EU.TRANSACTION := 'DISTRIBU';
                T_DW_EU.status := 'OPEN';
                T_DW_EU.PICKLIST := MS_PN.n_PICKLIST;
                T_DW_EU.picklist_line := l_line;
                T_DW_EU.BATCH := L_BATCH;
                T_DW_EU.pn := s_pn_dist;
                T_DW_EU.sn := s_sn_dist;
                T_DW_EU.QTY := D_QTY_RSV;
                T_DW_EU.QTY_picked := 1;
                T_DW_EU.TASK_CARD := MS_PN.S_TASK_CARD;
                IF NVL(MS_PN.n_PICKLIST_DISTRIBUTION_LINE,0) = 0 THEN
                  l_picklist_distribution_line := l_irow;
                ELSE
                  L_PICKLIST_DISTRIBUTION_LINE := MS_PN.n_PICKLIST_DISTRIBUTION_LINE;
                END IF;
                T_DW_EU.distribution_line := l_picklist_distribution_line;
                T_DW_EU.modified_date := dt_today;
                T_DW_EU.modified_by := s_user;
                T_DW_EU.CREATED_DATE := DT_TODAY;
                T_DW_EU.created_By := s_user;
                T_DW_EU.NOTES := L_NOTES;
                T_DW_EU.CONDITION := S_CONDITION_DIST;
--                IF trim(MS_PN.l_ORDER_LINE) is not null THEN T_DW_EU(l_irow).order_line := MS_PN.l_ORDER_LINE; end if; --TODO

                MS_PN_HISTORY := MS_PN_HISTORY_EMPTY;
                MS_PN_HISTORY.N_BATCH := L_BATCH;
                MS_PN_HISTORY.N_GOODS_RCVD_BATCH := L_GOODS_RCVD_BATCH;
                MS_PN_HISTORY.S_PN := S_PN_DIST;
                MS_PN_HISTORY.S_SN := S_SN_DIST;
                MS_PN_HISTORY.N_QTY := D_QTY_RSV;
                MS_PN_HISTORY.S_CONDITION := S_CONDITION_DIST;
                MS_PN_HISTORY.S_LOCATION := S_LOCATION_DIST;
                MS_PN_HISTORY.S_BIN := S_BIN_DIST;
                ms_pn_history.s_wall_password := ms_pn.s_wall_password;

                IF S_BIN_TRANSFER = 'Y' AND (S_LOCATION_HEADER = S_CURRENT_LOCATION) AND (S_CURRENT_BIN <> S_BIN) THEN
                  MS_PN_HISTORY.S_TRANSACTION_type := 'BIN/TRANSFER';
                  MS_PN_HISTORY.S_TO_BIN := S_BIN;
                  OF_PICKLIST_HISTORY(MS_PN_HISTORY);
                  MS_PN_HISTORY.S_BIN := S_BIN;
                End If;

                MS_PN_HISTORY.S_TRANSACTION_type := 'PICKLIST/CREATE';
                MS_PN_HISTORY.S_TO_BIN := NULL;
                MS_PN_HISTORY.S_ORDER_TYPE := 'PICKLST';
                MS_PN_HISTORY.n_PICKLIST := MS_PN.n_PICKLIST;
                MS_PN_HISTORY.n_PICKLIST_LINE := L_LINE;
                MS_PN_HISTORY.n_NOTES := L_NOTES;
                ms_pn_history.n_wo := l_wo;
                ms_pn_history.s_task_card := s_task_card;
                MS_PN_HISTORY.S_TASK_CARD_PN := S_TASK_CARD_PN;
                MS_PN_HISTORY.S_TASK_CARD_SN := S_TASK_CARD_SN;
                of_picklist_history(ms_pn_history);

                L_BATCHES.EXTEND;

                L_BATCHES(L_BATCHES.last) := l_batch;

              end if;

            end if;

          end if;
        END LOOP;

        gf_save_DW_INVENTORY_TRAN_AVL(dw_pn_inventory_avl);

        FOR L_CROW IN L_BATCHES.FIRST..L_BATCHES.LAST
        LOOP

          DECLARE
            S_LOCATION varchar2(100);
          begin
            SELECT "PN_INVENTORY_DETAIL"."PN",
                "PN_INVENTORY_DETAIL"."LOCATION"
            INTO s_pn,
                s_location
            FROM "PN_INVENTORY_DETAIL"
            WHERE "PN_INVENTORY_DETAIL"."BATCH" = l_batches(l_crow);

            IF ((NVL(MS_PN.S_TRANSACTION_TYPE,' ') <> 'ISSUE') OR GF_INV_LEVEL_CHECK_REORDER('ISSUE', S_PN) = 'YES') AND
               (NVL(MS_PN.S_TRANSACTION_TYPE,' ') <> 'NOREQUISITION') THEN
--              GF_INV_LEVEL_CHECK(S_LOCATION, S_PN); --TODO
              null;
            END IF;
          end;
        END LOOP;

      end;
    END IF;

    RETURN T_DW_EU;

  end OF_PICKLIST_DISTRIBUTION2;
  
  function OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL IN OUT NOCOPY PKG_TYPE_STRUCTURES.DW_INVENTORY_TRAN_AVL, DW_EU IN OUT NOCOPY PICKLIST_DISTRIBUTION%ROWTYPE,
                                     DW_PICKLIST_DETAIL IN OUT NOCOPY PICKLIST_DISTRIBUTION%ROWTYPE, MS_PN IN OUT NOCOPY PKG_TYPE_STRUCTURES.ST_PN, IS_ERRFLD IN OUT NOCOPY VARCHAR2,
                                     IS_ORIGINAL in out nocopy varchar2, gs_user in out nocopy varchar2, gs_company_multi in out nocopy varchar2) return PKG_TYPE_STRUCTURES.tt_picklist_distribution
  AS
    DT_TODAY DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    MS_PN_HISTORY PKG_TYPE_STRUCTURES.ST_PN;
    MS_PN_HISTORY_EMPTY PKG_TYPE_STRUCTURES.ST_PN;
    IS_WOPKLNLA VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPKLNLA');
    l_batch NUMBER;
    l_line NUMBER;
    l_notes NUMBER;
    l_wo NUMBER;
    L_MYBATCH NUMBER;
    TYPE T_N IS TABLE OF NUMBER;
    L_BATCHES t_n := t_n();
    L_NEW_BATCH NUMBER;
    d_qty NUMBER;
    d_qty_rtn NUMBER;
    d_qty_rsv NUMBER;
    d_qty_available NUMBER;
    D_QTY_RESERVED NUMBER;
    S_BIN_TRANSFER VARCHAR2(100);
    S_BIN VARCHAR2(100);
    S_CURRENT_BIN VARCHAR2(100);
    S_CURRENT_LOCATION VARCHAR2(100);
    s_condition VARCHAR2(100);
    s_sn VARCHAR2(100);
    s_pn VARCHAR2(100);
    s_task_card VARCHAR2(100);
    s_location_header VARCHAR2(100);
    s_build_kit_header VARCHAR2(100);
    s_task_card_pn VARCHAR2(100);
    s_task_card_sn VARCHAR2(100);
    S_USER VARCHAR2(100);
    S_INVENTORY_QUARANTINE VARCHAR2(100);
    profile_name varchar2(200);
    t_dw_eu PKG_TYPE_STRUCTURES.tt_picklist_distribution := PKG_TYPE_STRUCTURES.tt_picklist_distribution();
  BEGIN

    IF TRIM(DW_EU.TRANSACTION) IS NULL THEN
      DW_EU.TRANSACTION := 'REQUIRE';
    end if;

    IF TRIM(DW_EU.DISTRIBUTION_LINE) IS NULL THEN
      DW_EU.distribution_line := 0;
    end if;

    IF TRIM(DW_EU.qty_picked) IS NULL THEN
      DW_EU.qty_picked := 1;
    end if;

    if TRIM(DW_EU.STATUS) IS NULL THEN
      DW_EU.STATUS := 'OPEN';
    end if;

    T_DW_EU.EXTEND;
    T_DW_EU(T_DW_EU.last) := dw_eu;

    IF NVL(MS_PN.S_WALL_PASSWORD,' ') = ' ' THEN
      s_user := gs_user;
    ELSE
      S_USER := MS_PN.S_WALL_PASSWORD;
    End If;

    SELECT "PICKLIST_HEADER"."WO",   
        "PICKLIST_HEADER"."TASK_CARD",
        "PICKLIST_HEADER"."TASK_CARD_PN",
        "PICKLIST_HEADER"."TASK_CARD_SN",			
        "PICKLIST_HEADER"."LOCATION",   
        "PICKLIST_HEADER"."BUILD_KIT",
        NVL("PICKLIST_HEADER"."BIN_TRANSFER",'N'),
        "PICKLIST_HEADER"."BIN"
    INTO l_wo,   
        s_task_card,
        s_task_card_pn,
        s_task_card_sn,
        s_location_header,
        s_build_kit_header,
        s_bin_transfer,
        s_bin
    FROM "PICKLIST_HEADER"  
    WHERE "PICKLIST_HEADER"."PICKLIST" = ms_pn.n_picklist;

    SELECT NVL("LOCATION_MASTER"."INVENTORY_QUARANTINE",'N')  
      INTO s_inventory_quarantine  
      FROM "LOCATION_MASTER"  
     WHERE "LOCATION_MASTER"."LOCATION" = s_location_header;

    IF NVL(MS_PN.n_PICKLIST_DISTRIBUTION_LINE,0) = 0 THEN
      l_line := dw_eu.picklist_line;
    ELSE
      L_LINE := MS_PN.n_PICKLIST_LINE;
    End If;

    MS_PN.n_PICKLIST_LINE := L_LINE;
    of_picklist_detail(ms_pn);

    IF NVL(MS_PN.n_PICKLIST_DISTRIBUTION_LINE, 0) = 0 THEN
      D_QTY  := DW_EU.QTY;
      L_BATCH := DW_EU.BATCH;
      S_CONDITION := DW_EU.CONDITION;
      S_SN := DW_EU.SN;
      S_PN  := DW_EU.PN;
      l_notes := dw_eu.notes;
    ELSE
      D_QTY := MS_PN.N_QTY;
      L_BATCH := MS_PN.N_BATCH;
      S_CONDITION := ' ';
      S_SN := MS_PN.S_SN;
      S_PN := MS_PN.S_PN;
      L_NOTES := MS_PN.n_NOTES;
    End If;

    S_BIN := NVL(S_BIN,' ');
    If s_bin = ' ' Then s_bin_transfer := 'N'; end if;

    MS_PN.S_PN := S_PN;
    MS_PN.S_CONDITION := S_CONDITION;
    MS_PN.S_SN := S_SN;
    MS_PN.N_BATCH := L_BATCH;
    MS_PN.N_WO := L_WO;
    ms_pn.s_effectivity := 'Y';

    IF S_BUILD_KIT_HEADER = 'YES' THEN
      MS_PN.S_LOCATION := S_LOCATION_HEADER;
      MS_PN.S_BUILD_KIT := S_BUILD_KIT_HEADER;
    End If;

    MS_PN.S_ORIGINAL_AC := 'YES';
    ms_pn.s_effectivity := 'Y';

    if ms_pn.s_order_type = 'S/O' then

      begin
        SELECT "SYSTEM_TRAN_CODE"."COMPANY"
        INTO ms_pn.s_gl_company
        FROM "CUSTOMER_ORDER_HEADER",
            "SYSTEM_TRAN_CODE"
        WHERE "SYSTEM_TRAN_CODE"."SYSTEM_CODE"          = "CUSTOMER_ORDER_HEADER"."COMPANY"
        AND "SYSTEM_TRANSACTION"                      = 'ORDERCATEGORY'
        AND "SYSTEM_TRAN_CODE"."SYSTEM_TRAN_CODE_SUB" = '          '
        AND "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER"   = MS_PN.N_SO_NUMBER;
      EXCEPTION
      WHEN OTHERS THEN
        ms_pn.s_gl_company := null;
      end;
    else

      begin
        SELECT "SYSTEM_TRAN_CODE"."COMPANY"
        INTO ms_pn.s_gl_company
        FROM "WO",
               "SYSTEM_TRAN_CODE"
        WHERE "SYSTEM_TRAN_CODE"."SYSTEM_CODE"          = "WO"."GL_COMPANY"
        AND "SYSTEM_TRANSACTION"                      = 'ORDERCATEGORY'
        AND "SYSTEM_TRAN_CODE"."SYSTEM_TRAN_CODE_SUB" = '          '
        AND "WO"."WO"                  = l_wo;
      EXCEPTION
      WHEN OTHERS THEN
        MS_PN.S_GL_COMPANY := NULL;
      end;
    end if;

    IF S_INVENTORY_QUARANTINE = 'Y' THEN
      d_qty_rtn := GF_INVENTORY_AVAiLABLE(DW_PN_INVENTORY_AVL, MS_PN, IS_ORIGINAL, gs_company_multi, true);
      null;
    ELSE
      D_QTY_RTN := GF_INVENTORY_AVAiLABLE(DW_PN_INVENTORY_AVL, MS_PN, IS_ORIGINAL, gs_company_multi);
    End If;

  --  If d_qty > d_qty_rtn Then 	d_qty := d_qty_rtn; end if;

    IF DW_PN_INVENTORY_AVL IS NOT NULL AND DW_PN_INVENTORY_AVL.COUNT > 0 THEN
      DECLARE
       B_CONTINUE BOOLEAN := FALSE;
       AVL_1 NUMBER := 0;
       US_1 NUMBER := 0;
       L_GOODS_RCVD_BATCH NUMBER;
       S_PN_DIST VARCHAR2(100);
       S_SN_DIST VARCHAR2(100);
       S_LOCATION_DIST VARCHAR2(100);
       S_BIN_DIST VARCHAR2(100);
       S_CONDITION_DIST VARCHAR2(100);
       L_IROW NUMBER;
       L_PICKLIST_DISTRIBUTION_LINE number;
      begin
        FOR l_CROW IN DW_PN_INVENTORY_AVL.FIRST..DW_PN_INVENTORY_AVL.LAST
        LOOP
          B_CONTINUE := FALSE;
          IF D_QTY > 0 THEN
            IF S_INVENTORY_QUARANTINE = 'N' THEN

              IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) IS NULL THEN
                  avl_1 := dw_pn_inventory_avl(l_crow).qty_available;
              ELSE
                IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) <> 'MANAGE' THEN
                  avl_1 := dw_pn_inventory_avl(l_crow).qty_available;
                ELSE
                  IF NVL(TRIM(MS_PN.S_OWNER), ' ') = NVL (TRIM(DW_PN_INVENTORY_AVL(l_crow).OWNER), ' ') THEN
                    avl_1 := dw_pn_inventory_avl(l_crow).qty_available;
                  ELSE
                    avl_1 := 0;
                  end if;
                END IF;
              END IF;

              IF AVL_1  = 0 THEN B_CONTINUE := TRUE; END IF;
              d_qty_available := dw_pn_inventory_avl(l_crow).qty_available;
            Else

              IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) IS NULL THEN
                  us_1 := dw_pn_inventory_avl(l_crow).qty_us;
              ELSE
                IF TRIM(DW_PN_INVENTORY_AVL(l_crow).LOAN_CATEGORY) <> 'MANAGE' THEN
                  us_1 := dw_pn_inventory_avl(l_crow).qty_us;
                ELSE
                  IF NVL(TRIM(MS_PN.S_OWNER), ' ') = NVL (TRIM(DW_PN_INVENTORY_AVL(l_crow).OWNER), ' ') THEN
                    us_1 := dw_pn_inventory_avl(l_crow).qty_us;
                  ELSE
                    us_1 := 0;
                  end if;
                END IF;
              END IF;

              IF US_1  = 0 THEN B_CONTINUE := TRUE; END IF;
              D_QTY_AVAILABLE := DW_PN_INVENTORY_AVL(L_CROW).qty_us;
            End If;

            IF NOT B_CONTINUE THEN

              d_qty_reserved := dw_pn_inventory_avl(l_crow).qty_reserved;

              IF TRIM(D_QTY_AVAILABLE) IS NULL THEN D_QTY_AVAILABLE := 0; END IF;
              IF TRIM(D_QTY_RESERVED) IS NULL THEN D_QTY_RESERVED := 0; END IF;
              if trim(d_qty) is null Then d_qty := 0; end if;

              L_BATCH := DW_PN_INVENTORY_AVL(L_CROW).BATCH;
              S_CURRENT_LOCATION := DW_PN_INVENTORY_AVL(L_CROW).LOCATION;
              S_CURRENT_BIN := DW_PN_INVENTORY_AVL(L_CROW).BIN;
              l_new_batch := 0;

              IF D_QTY > D_QTY_AVAILABLE THEN

                D_QTY := D_QTY - D_QTY_AVAILABLE;
                D_QTY_RESERVED := D_QTY_RESERVED + D_QTY_AVAILABLE;
                dw_pn_inventory_avl(l_crow).qty_reserved := d_qty_reserved;

                IF S_INVENTORY_QUARANTINE = 'N' THEN
                  dw_pn_inventory_avl(l_crow).qty_available := 0;
                ELSE
                  DW_PN_INVENTORY_AVL(L_CROW).qty_us := 0;
                End If;

                d_qty_rsv := d_qty_available;

                IF S_BIN_TRANSFER = 'Y' AND (S_LOCATION_HEADER = S_CURRENT_LOCATION) AND (S_CURRENT_BIN <> S_BIN) THEN
                  DW_PN_INVENTORY_AVL(L_CROW).bin := S_BIN;
                End If;

              ELSIF D_QTY_AVAILABLE > 0 THEN
                  --TEST LOG 150548 modified
                  BEGIN
                    SELECT "PROFILE"
                    INTO PROFILE_NAME 
                    from PROFILE_MASTER;
                  EXCEPTION
                  WHEN OTHERS THEN
                    PROFILE_NAME := NULL;
                  END;

                IF(PROFILE_NAME = 'SWA' and IS_WOPKLNLA = 'Y')
                then
                  --D_QTY_AVAILABLE := D_QTY_AVAILABLE - D_QTY ;
                   D_QTY_AVAILABLE := D_QTY_AVAILABLE - DW_EU.qty_picked;
                  --D_QTY_RESERVED := D_QTY_RESERVED + D_QTY ;
                  D_QTY_RESERVED := D_QTY_RESERVED + DW_EU.qty_picked;
                else
                  D_QTY_AVAILABLE := D_QTY_AVAILABLE - D_QTY ;
                  D_QTY_RESERVED := D_QTY_RESERVED + D_QTY ;

                end if;
                --TEST LOG 150548 modified
                dw_pn_inventory_avl(l_crow).qty_reserved := d_qty_reserved;

                IF S_INVENTORY_QUARANTINE = 'N' THEN
                  dw_pn_inventory_avl(l_crow).qty_available := d_qty_available;
                ELSE
                  DW_PN_INVENTORY_AVL(L_CROW).QTY_US := D_QTY_AVAILABLE;
                END IF;

                D_QTY_RSV := D_QTY;
                D_QTY := 0;

                If s_bin_transfer = 'Y' and (s_location_header = s_current_location) and (s_current_bin <> s_bin) Then
                  If d_qty_available = 0 Then
                    dw_pn_inventory_avl(l_crow).bin := s_bin;
                  ELSE
                    DW_PN_INVENTORY_AVL.EXTEND;
                    DW_PN_INVENTORY_AVL(DW_PN_INVENTORY_AVL.LAST) := DW_PN_INVENTORY_AVL(L_CROW);
                    DW_PN_INVENTORY_AVL(DW_PN_INVENTORY_AVL.LAST).BIN := S_BIN;
                    L_NEW_BATCH := PKG_APPLICATION_FUNCTION.CONFIG_NUMBER('BATCH');
                    DW_PN_INVENTORY_AVL(DW_PN_INVENTORY_AVL.LAST).BATCH := L_NEW_BATCH;
                    dw_pn_inventory_avl(l_crow).qty_reserved := 0;
                    IF S_INVENTORY_QUARANTINE = 'N' THEN
                      dw_pn_inventory_avl(dw_pn_inventory_avl.last).qty_available := 0;
                    ELSE
                      dw_pn_inventory_avl(dw_pn_inventory_avl.last).qty_us := 0;	
                    End If;
                  End If;
                End If;
              ELSE
                B_CONTINUE := true;
              End If;

              IF NOT B_CONTINUE THEN
                S_PN_DIST := NULL;
                s_sn_dist := null;	

                if trim(l_batch) is not null then

                  SELECT "PN_INVENTORY_DETAIL"."PN",
                      "PN_INVENTORY_DETAIL"."SN",
                      "PN_INVENTORY_DETAIL"."LOCATION",
                      "PN_INVENTORY_DETAIL"."BIN",  
                      "PN_INVENTORY_DETAIL"."CONDITION",
                      "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH"
                  INTO s_pn_dist, 
                      s_sn_dist,
                      s_location_dist,
                      s_bin_dist,
                      s_condition_dist,
                      l_goods_rcvd_batch
                  FROM "PN_INVENTORY_DETAIL"
                  WHERE "PN_INVENTORY_DETAIL"."BATCH" = l_batch;

                end if;

                If nvl(l_new_batch,0) > 0 Then l_batch := l_new_batch; end if;

                dt_today := pkg_application_function.currentdatetime;

                T_DW_EU.EXTEND;
                L_IROW := T_DW_EU.LAST;
                T_DW_EU(L_IROW).TRANSACTION := 'DISTRIBU';
                T_DW_EU(L_IROW).status := 'OPEN';
                T_DW_EU(L_IROW).PICKLIST := MS_PN.n_PICKLIST;
                T_DW_EU(l_irow).picklist_line := l_line;
                T_DW_EU(L_IROW).BATCH := L_BATCH;
                T_DW_EU(l_irow).pn := s_pn_dist;
                T_DW_EU(l_irow).sn := s_sn_dist;
                T_DW_EU(L_IROW).QTY := D_QTY_RSV;
                T_DW_EU(L_IROW).QTY_picked := 1;
                T_DW_EU(L_IROW).TASK_CARD := MS_PN.S_TASK_CARD;
                IF NVL(MS_PN.n_PICKLIST_DISTRIBUTION_LINE,0) = 0 THEN
                  l_picklist_distribution_line := l_irow;
                ELSE
                  L_PICKLIST_DISTRIBUTION_LINE := MS_PN.n_PICKLIST_DISTRIBUTION_LINE;
                END IF;
                T_DW_EU(l_irow).distribution_line := l_picklist_distribution_line;
                T_DW_EU(l_irow).modified_date := dt_today;
                T_DW_EU(l_irow).modified_by := s_user;
                T_DW_EU(L_IROW).CREATED_DATE := DT_TODAY;
                T_DW_EU(l_irow).created_By := s_user;
                T_DW_EU(L_IROW).NOTES := L_NOTES;
                T_DW_EU(L_IROW).CONDITION := S_CONDITION_DIST;
--                IF trim(MS_PN.l_ORDER_LINE) is not null THEN T_DW_EU(l_irow).order_line := MS_PN.l_ORDER_LINE; end if; --TODO

                MS_PN_HISTORY := MS_PN_HISTORY_EMPTY;
                MS_PN_HISTORY.N_BATCH := L_BATCH;
                MS_PN_HISTORY.N_GOODS_RCVD_BATCH := L_GOODS_RCVD_BATCH;
                MS_PN_HISTORY.S_PN := S_PN_DIST;
                MS_PN_HISTORY.S_SN := S_SN_DIST;
                MS_PN_HISTORY.N_QTY := D_QTY_RSV;
                MS_PN_HISTORY.S_CONDITION := S_CONDITION_DIST;
                MS_PN_HISTORY.S_LOCATION := S_LOCATION_DIST;
                MS_PN_HISTORY.S_BIN := S_BIN_DIST;
                ms_pn_history.s_wall_password := ms_pn.s_wall_password;

                IF S_BIN_TRANSFER = 'Y' AND (S_LOCATION_HEADER = S_CURRENT_LOCATION) AND (S_CURRENT_BIN <> S_BIN) THEN
                  MS_PN_HISTORY.S_TRANSACTION_type := 'BIN/TRANSFER';
                  MS_PN_HISTORY.S_TO_BIN := S_BIN;
                  OF_PICKLIST_HISTORY(MS_PN_HISTORY);
                  MS_PN_HISTORY.S_BIN := S_BIN;
                End If;

                MS_PN_HISTORY.S_TRANSACTION_type := 'PICKLIST/CREATE';
                MS_PN_HISTORY.S_TO_BIN := NULL;
                MS_PN_HISTORY.S_ORDER_TYPE := 'PICKLST';
                MS_PN_HISTORY.n_PICKLIST := MS_PN.n_PICKLIST;
                MS_PN_HISTORY.n_PICKLIST_LINE := L_LINE;
                MS_PN_HISTORY.n_NOTES := L_NOTES;
                ms_pn_history.n_wo := l_wo;
                ms_pn_history.s_task_card := s_task_card;
                MS_PN_HISTORY.S_TASK_CARD_PN := S_TASK_CARD_PN;
                MS_PN_HISTORY.S_TASK_CARD_SN := S_TASK_CARD_SN;
                of_picklist_history(ms_pn_history);

                L_BATCHES.EXTEND;

                L_BATCHES(L_BATCHES.last) := l_batch;

              end if;

            end if;

          end if;
        END LOOP;

        gf_save_DW_INVENTORY_TRAN_AVL(dw_pn_inventory_avl);

      if L_BATCHES.count > 0 then 
        FOR L_CROW IN L_BATCHES.FIRST..L_BATCHES.LAST
        LOOP

          DECLARE
            S_LOCATION varchar2(100);
          begin
            SELECT "PN_INVENTORY_DETAIL"."PN",
                "PN_INVENTORY_DETAIL"."LOCATION"
            INTO s_pn,
                s_location
            FROM "PN_INVENTORY_DETAIL"  
            WHERE "PN_INVENTORY_DETAIL"."BATCH" = l_batches(l_crow);

            IF ((NVL(MS_PN.S_TRANSACTION_TYPE,' ') <> 'ISSUE') OR GF_INV_LEVEL_CHECK_REORDER('ISSUE', S_PN) = 'YES') AND  
               (NVL(MS_PN.S_TRANSACTION_TYPE,' ') <> 'NOREQUISITION') THEN
--              GF_INV_LEVEL_CHECK(S_LOCATION, S_PN); --TODO
              null;
            END IF;
          end;
        END LOOP;	
        end if; 

      end;
    END IF;

    RETURN T_DW_EU;

  end OF_PICKLIST_DISTRIBUTION;

  Function eMobility_Picklist_defect(N_WO NUMBER, S_AC VARCHAR2, MS_LOCATION_SITE IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                       MS_LOCATION_SITE_REQ IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                       S_TASK_CARD VARCHAR2 DEFAULT NULL,S_TASK_CARD_PN VARCHAR2 DEFAULT NULL , S_TASK_CARD_SN VARCHAR2 DEFAULT NULL ,
                                       s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0,
                                       GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER) return number
  AS
    s_customer varchar2(100) := '';
    GS_STATUS VARCHAR2(100) := ' ';
    idt_today date := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    S_WOPICK1 VARCHAR2(100) := 'N' ; --PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPICK1');
    MS_PN PKG_TYPE_STRUCTURES.ST_PN;
    IL_WO NUMBER := N_WO;
    IS_BOCRT VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('BOCRT');
    IS_WOPURSVRQ VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPURSVRQ');
    IS_WOPKLNLA VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPKLNLA');
    is_COMPANYMULTIREQ varchar2(100);
    I_CROW NUMBER := 0;
    I_AROW NUMBER := 0;
    DT_SCHEDULE_START_DATE DATE;
    DT_TODAY DATE;
    S_SV_TASK_CARD VARCHAR2(100);
    IL_PICKLIST NUMBER := 0 ;

    T_DW_SEL WO_TC_PN_ARRAY;
    T_DW_SEL_DEFECT DEFECT_PN_ARRAY;

    is_location VARCHAR2(100);
    is_ac VARCHAR2(100);
    idt_schedule_start_date date;
    is_tpw VARCHAR2(100);
    is_priority VARCHAR2(100);
    is_site VARCHAR2(100);
    is_module VARCHAR2(100);
    IS_COMPANY VARCHAR2(100);
    S_LOCATION VARCHAR2(100);
    IDT_REQUIRE_DATE DATE;
    IL_REQUIRE_HOUR number;
    IL_REQUIRE_MINUTE number;
    IS_DELIVERY_LOCATION VARCHAR2(100);
    IS_SHORTAGE_PRINT_ONLY VARCHAR2(100);
    IS_PRIORITY_REQ VARCHAR2(100);
    IS_REQUISITION_TYPE VARCHAR2(100);
    IDT_REQUIRE_DATE_REQ DATE;
    IL_REQUIRE_HOUR_REQ NUMBER;
    IL_REQUIRE_MINUTE_REQ NUMBER;
    DW_EU PICKLIST_DISTRIBUTION%ROWTYPE;
    DW_PICKLIST_DETAIL PICKLIST_DISTRIBUTION%ROWTYPE;
    dw_pn_inventory_avl PKG_TYPE_STRUCTURES.dw_INVENTORY_TRAN_AVL;
    IS_TASK_CARD VARCHAR2(100);
    IS_TASK_CARD_HEADER VARCHAR2(100);
    IS_TASK_CARD_PN VARCHAR2(100);
    IS_TASK_CARD_PN_SN VARCHAR2(100);


    IS_DEFECT "DEFECT_REPORT"."DEFECT"%type;
    IS_DEFECT_TYPE "DEFECT_REPORT"."DEFECT_TYPE"%type;
    IL_DEFECT_ITEM "DEFECT_REPORT"."DEFECT_ITEM"%type;


    IS_AC_TC VARCHAR2(100);
    IS_EC VARCHAR2(100);
    S_NEW VARCHAR2(100);
    IS_TRAN VARCHAR2(100);
    IL_REQUISITION NUMBER;
    profile_name varchar2(200);
    is_original varchar2(32000) := ' SELECT DISTINCT "LOCATION_MASTER_ROUTINE"."MASTER_LOCATION_SEQUENCE",
                                                       "LOCATION_MASTER_ROUTINE"."MASTER_LOCATION",
                                                       NVL("PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION", sysdate + 200000) as dt_shelf_life_computed,
                                                       "PN_INVENTORY_DETAIL"."BATCH",
                                                       "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH",
                                                       "PN_INVENTORY_DETAIL"."VENDOR_LOT",
                                                       "PN_INVENTORY_DETAIL"."PN",
                                                       "PN_INVENTORY_DETAIL"."SN",
                                                       "PN_INVENTORY_DETAIL"."NHA_PN",
                                                       "PN_INVENTORY_DETAIL"."NHA_SN",
                                                       "PN_INVENTORY_DETAIL"."CONDITION",
                                                       "PN_INVENTORY_DETAIL"."OWNER",
                                                       "PN_INVENTORY_DETAIL"."UNIT_COST",
                                                       "PN_INVENTORY_DETAIL"."CURRENCY",
                                                       "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE",
                                                       "PN_INVENTORY_DETAIL"."RI_BY",
                                                       "PN_INVENTORY_DETAIL"."RI_DATE",
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_AC",
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_POSITION",
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_DATE",
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_HOUR",
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_MINUTE",
                                                       "PN_INVENTORY_DETAIL"."LOCATION",
                                                       "PN_INVENTORY_DETAIL"."BIN",
                                                       "PN_INVENTORY_DETAIL"."QTY_AVAILABLE",
                                                       "PN_INVENTORY_DETAIL"."QTY_RESERVED",
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_TRANSFER",
                                                       "PN_INVENTORY_DETAIL"."QTY_PENDING_RI",
                                                       "PN_INVENTORY_DETAIL"."QTY_US",
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_REPAIR",
                                                       "PN_INVENTORY_DETAIL"."RI_CONTROL",
                                                       "PN_INVENTORY_DETAIL"."US_CODE",
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION",
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION",
                                                       "PN_INVENTORY_DETAIL"."LOAN_CATEGORY",
                                                       "PN_INVENTORY_DETAIL"."CUTOM_DUTY_CODE",
                                                       "PN_INVENTORY_DETAIL"."GL_COMPANY",
                                                       "PN_INVENTORY_DETAIL"."GL_EXPENDITURE",
                                                       "PN_INVENTORY_DETAIL"."GL",
                                                       "PN_INVENTORY_DETAIL"."GL_COST_CENTER",
                                                       "PN_INVENTORY_DETAIL"."NOTES",
                                                       "PN_INVENTORY_DETAIL"."CREATED_BY",
                                                       "PN_INVENTORY_DETAIL"."CREATED_DATE",
                                                       "PN_INVENTORY_DETAIL"."MODIFIED_BY",
                                                       "PN_INVENTORY_DETAIL"."MODIFIED_DATE",
                                                       "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_DATE",
                                                       "PN_INVENTORY_DETAIL"."KIT_NO",
                                                       "PN_INVENTORY_DETAIL"."CURRENCY_EXCHANGE_RATE",
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_RENTAL",
                                                       "PN_INVENTORY_DETAIL"."SECONDARY_COST",
                                                       "PN_INVENTORY_DETAIL"."SECONDARY_CURRENCY_EXCHANGE",
                                                       "PN_INVENTORY_DETAIL"."BLOB_NO",
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_AC",
                                                       "PN_INVENTORY_DETAIL"."MOD_STATUS",
                                                       "PN_INVENTORY_DETAIL"."CUSTOM_DUTY_DOCUMENT",
                                                       "PN_INVENTORY_DETAIL"."PENDING",
                                                       "PN_INVENTORY_DETAIL"."PENDING_DATE",
                                                       "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE_ORIGINAL",
                                                       "PN_INVENTORY_DETAIL"."SOS_DATE",
                                                       "PN_INVENTORY_DETAIL"."SOS_HOUR",
                                                       "PN_INVENTORY_DETAIL"."SOS_MINUTE",
                                                       "PN_INVENTORY_DETAIL"."TAG_BY",
                                                       "PN_INVENTORY_DETAIL"."TAG_DATE",
                                                       "PN_INVENTORY_DETAIL"."TAG_NO",
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_RECORDS_BY",
                                                       "PN_INVENTORY_DETAIL"."ORGINAL_RECORDS_DATE",
                                                       "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT",
                                                       "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT_DATE",
                                                       "PN_INVENTORY_DETAIL"."PN_MODEL",
                                                       "PN_INVENTORY_DETAIL"."PN_SOFTWARE",
                                                       "PN_INVENTORY_DETAIL"."FILING_SEQUENCE",
                                                       "PN_INVENTORY_DETAIL"."NO_OF_TAG_PRINT",
                                                       "PN_INVENTORY_DETAIL"."OWNER_ORIGIN",
                                                       "PN_INVENTORY_DETAIL"."NLA_POSITION",
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_HOURS",
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_MINUTES",
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_CYCLES",
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_DAYS",
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION_LAST",
                                                       "PN_INVENTORY_DETAIL"."INVENTORY_TYPE",
                                                       "PN_INVENTORY_DETAIL"."DOCUMENT_NO",
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION_LAST",
                                                       "PN_INVENTORY_DETAIL"."SLOT",
                                                       "PN_INVENTORY_DETAIL"."COST_IN_KIT",
                                                       "PN_INVENTORY_DETAIL"."REPAIR_RETURN_DATE",
                                                       "PN_INVENTORY_DETAIL"."HAZARDOUS_MATERIAL_AT_REMOVAL",
                                                       "PN_INVENTORY_DETAIL"."WEIGHT",
                                                       "PN_INVENTORY_DETAIL"."WEIGHT_UNIT",
                                                       "PN_INVENTORY_DETAIL"."MANAGED_WO",
                                                       "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_BY",
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_AC_ISSUE_TO_ONLY",
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXP_EOM",
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXP_EOM",
                                                       "PN_INVENTORY_DETAIL"."LEGACY_BATCH",
                                                       "PN_INVENTORY_DETAIL"."ADJUSTMENT_CODE",
                                                       DECODE("PN_INVENTORY_DETAIL"."OWNER", :1, 1, 2) as owner_sort
                                                  FROM "PN_INVENTORY_DETAIL",
                                                       "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_A",
                                                       "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_B",
                                                       "LOCATION_MASTER_ROUTINE"
                                                 WHERE ( "PN_INTERCHANGEABLE_A"."PN" = "PN_INTERCHANGEABLE_B"."PN" ) and
                                                       ( "PN_INTERCHANGEABLE_A"."PN_INTERCHANGEABLE" = "PN_INVENTORY_DETAIL"."PN" ) and
                                                       ( "PN_INVENTORY_DETAIL"."LOCATION" = "LOCATION_MASTER_ROUTINE"."LOCATION_ROUTING" ) ';
  BEGIN
    --UE_POSTOPEN


     T_DW_SEL_DEFECT := WF_LOAD_DEFECT_PN_FOR_RESERVE(N_WO, S_AC, s_defect , s_defect_type, l_defect_item);

    DT_TODAY := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;

    if (T_DW_SEL_DEFECT is not null and T_DW_SEL_DEFECT.count > 0 )then

      begin


if n_wo > 0 then 
      SELECT "WO"."LOCATION",
          "WO"."AC",
          "WO"."SCHEDULE_START_DATE",
          "WO"."THIRD_PARTY_WO",
          "WO"."PRIORITY",
          "WO"."SITE",
          "WO"."MODULE",
          "WO"."GL_COMPANY"
      INTO is_location,
          is_ac,
          idt_schedule_start_date,
          is_tpw,
          is_priority,
          is_site,
          is_module,
          is_company
      FROM "WO"
      WHERE "WO"."WO" = n_wo;
end if ; 

        SELECT trim("RELATION_MASTER"."EMPLOYEE_CONTRACTOR")
        INTO ms_pn.s_owner
        FROM "CUSTOMER_ORDER_HEADER",
            "RELATION_MASTER"
        WHERE ( "CUSTOMER_ORDER_HEADER"."CUSTOMER" = "RELATION_MASTER"."RELATION_CODE" ) and
          ( ( "CUSTOMER_ORDER_HEADER"."ORDER_TYPE" = 'W/O' ) AND
          ( "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER" = N_WO ) );
      EXCEPTION
      WHEN OTHERS THEN
        ms_pn.s_owner := null;
      end;

      S_SV_TASK_CARD := ' ';
is_ac := s_ac; 

      --done for task control nelson
      --location
      if MS_LOCATION_SITE.S_LOCATION is null then
        MS_LOCATION_SITE.S_LOCATION := IS_LOCATION;
      else
        IS_LOCATION :=  MS_LOCATION_SITE.S_LOCATION ;
      end if;

      --site
      if MS_LOCATION_SITE.S_SITE is null then
        MS_LOCATION_SITE.S_SITE := IS_SITE;
      else
        IS_SITE := IS_SITE ;
      end if;





      --priority
       if  Ms_Location_Site.S_Priority is not null then
        is_priority := Ms_Location_Site.S_Priority ;
      end if ;

      --end done for task control nelson

      MS_LOCATION_SITE.S_TRANSACTION := 'PICKLIST';
      MS_LOCATION_SITE.S_MODULE := IS_MODULE;
      MS_LOCATION_SITE.L_WO := n_WO;



      s_location := ms_location_site.s_location;

      if trim(s_location) is not null Then

        IS_COMPANYMULTIREQ := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('COMPANYMULTIREQ');
        IDT_REQUIRE_DATE := MS_LOCATION_SITE.DT_REQUIRE_DATE;
        IL_REQUIRE_HOUR := MS_LOCATION_SITE.L_HOUR;
        IL_REQUIRE_MINUTE := MS_LOCATION_SITE.L_MINUTE;
        IS_DELIVERY_LOCATION := MS_LOCATION_SITE.S_DELIVERY_LOCATION;
        IS_SHORTAGE_PRINT_ONLY := MS_LOCATION_SITE.S_SHORTAGE_PRINT_ONLY;

        IF TRIM(S_LOCATION) IS NOT NULL THEN IS_LOCATION := S_LOCATION; END IF;
        IF TRIM(IS_DELIVERY_LOCATION) IS NULL THEN IS_DELIVERY_LOCATION := IS_LOCATION; END IF;
        IF TRIM(MS_LOCATION_SITE.S_SITE) IS NOT NULL THEN IS_SITE := MS_LOCATION_SITE.S_SITE; END IF;
        IF IDT_SCHEDULE_START_DATE < DT_TODAY THEN IDT_SCHEDULE_START_DATE := DT_TODAY; END IF;
        If trim(idt_require_date) is not null Then idt_schedule_start_date := idt_require_date; end if;

        IS_WOPURSVRQ := 'Y';
        IS_BOCRT := 'Y';
        IS_SHORTAGE_PRINT_ONLY := 'N';

        IF IS_WOPURSVRQ = 'Y' AND IS_BOCRT = 'Y' AND IS_SHORTAGE_PRINT_ONLY = 'N' THEN
          ms_location_site_req.s_location := is_location;
          MS_LOCATION_SITE_REQ.S_SITE := IS_SITE;
          ms_location_site_req.s_transaction := 'REQUISITION/PK';
          MS_LOCATION_SITE_REQ.S_MODULE := IS_MODULE;
          MS_LOCATION_SITE_REQ.L_WO := n_WO;
          IF trim(MS_LOCATION_SITE_REQ.S_LOCATION) is null THEN
            RETURN 0;
          End If;
          IS_PRIORITY_REQ := MS_LOCATION_SITE_REQ.S_PRIORITY;
          IS_REQUISITION_TYPE := MS_LOCATION_SITE_REQ.S_TYPE;
          IDT_REQUIRE_DATE_REQ := MS_LOCATION_SITE_REQ.DT_REQUIRE_DATE;
          IL_REQUIRE_HOUR_REQ := MS_LOCATION_SITE_REQ.L_HOUR;
          IL_REQUIRE_MINUTE_REQ := MS_LOCATION_SITE_REQ.L_MINUTE;
        End If;


       if (T_DW_SEL_DEFECT is not null and T_DW_SEL_DEFECT.count > 0 )then

        FOR I_CROW IN T_DW_SEL_DEFECT.FIRST..T_DW_SEL_DEFECT.LAST
        LOOP
          DECLARE
            D_QTY_RESERVED NUMBER;
            D_QTY NUMBER;
            D_REQUISITION NUMBER;
            IS_PN VARCHAR2(100);
            ID_QTY NUMBER;
            S_ETOPS_ACTION VARCHAR2(100);
            D_REQUISITION_ORDER NUMBER;
            D_ORDER_RESERVER NUMBER;
            I_RETURN NUMBER;
            II_NONEFFECTIVE NUMBER;
            DW_PN_INVENTORY_AVL_QTY NUMBER;
            DW_PN_INVENTORY_AVL_QTY1 NUMBER;
            DW_PN_INVENTORY_AVL_QTY2 NUMBER;
            IS_ERRFLD VARCHAR2(100);
            IS_ETOPS_ACTION VARCHAR2(100);
            IS_PN_DESCRIPTION VARCHAR2(32000);
            t_dw_eu PKG_TYPE_STRUCTURES.tt_picklist_distribution := PKG_TYPE_STRUCTURES.tt_picklist_distribution();
             n_batch VARCHAR2(100);
             s_sn NUMBER;
          begin
            IS_DEFECT := T_DW_SEL_DEFECT(I_CROW).s_defect;
            IF S_WOPICK1 = 'N' THEN IS_TASK_CARD_HEADER := IS_TASK_CARD; END IF;
            IS_DEFECT_TYPE := T_DW_SEL_DEFECT(I_CROW).S_defect_type;
            IL_defect_item := T_DW_SEL_DEFECT(I_CROW).l_defect_item;
            IS_AC_TC := T_DW_SEL_DEFECT(I_CROW).S_AC;
            T_DW_SEL_DEFECT(I_CROW).s_picklist_processed := 'N';




            S_NEW := 'NEW';
            S_SV_TASK_CARD := IS_TASK_CARD;
            DW_EU.picklist := IL_PICKLIST;



            IS_PN := T_DW_SEL_DEFECT(I_CROW).S_PN;
            ID_QTY := T_DW_SEL_DEFECT(I_CROW).N_QTY;
            D_QTY_RESERVED := T_DW_SEL_DEFECT(I_CROW).n_qty_reserved;

            IF PKG_APPLICATION_FUNCTION.CONFIG_FLAG('ETOPS') = 'N' THEN S_ETOPS_ACTION := GF_ETOPS_VALIDATION(IL_WO, IS_PN); END IF;

            if nvl(s_etops_action,'5') <> '1' and nvl(s_etops_action,'5') <> '2' then
              IF NVL(S_ETOPS_ACTION,'5') = '3' OR NVL(S_ETOPS_ACTION,'5') = '4' THEN
                IS_PN := DF_GET_INTERCHANGE_EFFECTIVE(IS_PN, IS_AC, IL_WO);
                MS_PN.S_ORDER_TYPE := 'S/O';
              END IF	;

              IF trim(D_QTY_RESERVED) is null THEN 	D_QTY_RESERVED := 0; end if;

              D_REQUISITION := 0;

              begin
                SELECT sum( "REQUISITION_DETAIL"."QTY_REQUIRE" )
                INTO d_requisition
                FROM "REQUISITION_HEADER",
                    "REQUISITION_DETAIL"
                WHERE ( "REQUISITION_DETAIL"."REQUISITION" = "REQUISITION_HEADER"."REQUISITION" ) and
                    (
                    ( "REQUISITION_HEADER"."DEFECT" = is_defect ) AND
                    ( "REQUISITION_HEADER"."DEFECT_TYPE" = is_defect_type ) AND
                    ( "REQUISITION_HEADER"."DEFECT_ITEM" = il_defect_item ) AND
                    ( "REQUISITION_DETAIL"."PN" = IS_PN ) AND
                    ( "REQUISITION_DETAIL"."STATUS" IN ('OPEN','CLOSED')));
              EXCEPTION
              WHEN OTHERS THEN
                d_requisition := null;
              END;

              If trim(d_requisition) is null Then d_requisition := 0; end if;

              d_requisition_order := 0;

              begin
              SELECT sum( "REQUISITION_DETAIL"."QTY_REQUIRE" )
              INTO d_requisition_order
              FROM "REQUISITION_HEADER",
                  "REQUISITION_DETAIL"
              WHERE ( "REQUISITION_DETAIL"."REQUISITION" = "REQUISITION_HEADER"."REQUISITION" ) and
                  (
                  ( "REQUISITION_HEADER"."DEFECT" = is_defect ) AND
                  ( "REQUISITION_HEADER"."DEFECT_TYPE"  = is_defect_type ) AND
                  ( "REQUISITION_HEADER"."DEFECT_ITEM" = il_defect_item ) AND
                  ( "REQUISITION_DETAIL"."PN" = is_pn ) and
                  ( "REQUISITION_DETAIL"."STATUS" = 'ORDER'));
              EXCEPTION
              WHEN OTHERS THeN
                d_requisition_order := null;
              end;

              If trim(d_requisition_order) is null Then d_requisition_order := 0; end if;

              D_ORDER_RESERVER := 0;

              begin
                SELECT sum("ORDER_DETAIL"."QTY_REQUIRE")
                INTO d_order_reserver
                FROM "ORDER_DETAIL"
                WHERE ( "ORDER_DETAIL"."PN" = is_pn ) AND
                    ( "ORDER_DETAIL"."AUTO_ISSUE" in ( 'RESERVE','ISSUE') ) AND
                    ( "ORDER_DETAIL"."DEFECT" = IS_DEFECT ) and
                    ( "ORDER_DETAIL"."DEFECT_TYPE" = IS_DEFECT_TYPE ) and
                    ( "ORDER_DETAIL"."DEFECT_ITEM" = IL_DEFECT_ITEM );
              exception
              WHEN OTHERS THEN
                D_ORDER_RESERVER := NULL;
              end;

              If trim(d_order_reserver) is null Then d_order_reserver := 0; end if;

              id_qty := id_qty - (d_qty_reserved + d_requisition + d_requisition_order + d_order_reserver);

              IF ID_QTY > 0 THEN

                n_batch:= null;
                s_sn := null;

                DW_EU := WF_NEW(IS_TRAN, IL_PICKLIST, IS_PN, IS_TASK_CARD, ID_QTY, GS_USER,n_batch,s_sn);
                I_RETURN :=0;
                ii_nonEffective := 1;

                i_return :=  WF_EDIT(DW_EU, DW_PN_INVENTORY_AVL, DW_PN_INVENTORY_AVL_QTY,
                                     dw_pn_inventory_avl_qty1, dw_pn_inventory_avl_qty2, is_errfld, IS_TPW,
                                     IS_AC, IL_WO, IS_LOCATION, IS_ETOPS_ACTION,
                                     IS_ORIGINAL, GS_COMPANY_MULTI, IS_BOCRT, IS_SHORTAGE_PRINT_ONLY,
                                     IL_REQUISITION, IS_PN, IS_PRIORITY_REQ,
                                     IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ,
                                     IS_COMPANY, IS_TASK_CARD, GS_USER, IS_EC,
                                     IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, is_defect , is_defect_type , il_defect_item ,
                                     IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                     IL_REQUIRE_HOUR_REQ, il_require_minute_req);

                ms_location_site.s_shortage_print_only := 'N';
                if ms_location_site.s_shortage_print_only = 'N' then

                  begin
                    SELECT "PN_MASTER"."PN_DESCRIPTION"
                    INTO is_pn_description
                    FROM "PN_MASTER",
                        "PN_INTERCHANGEABLE"
                    WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) AND
                        ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = is_pn ) );
                  EXCEPTION
                  WHEN OTHERS THEN
                    is_pn_description := null;
                  END;

                  If i_return = 0 then
                    If s_new = 'NEW' Then
                    S_WOPICK1:='N';
                      IF S_WOPICK1 = 'N' OR ( S_WOPICK1 = 'Y' AND IL_PICKLIST = 0 )   THEN
                        WF_NEW_PICKLIST_HEADER(IL_PICKLIST, IS_LOCATION, IL_WO, IS_TASK_CARD_HEADER,
                                               IDT_SCHEDULE_START_DATE, IL_REQUIRE_HOUR, IL_REQUIRE_MINUTE,
                                               IS_DELIVERY_LOCATION, IS_PRIORITY, IS_SITE, IS_TASK_CARD_PN,
                                               is_task_card_pn_sn, is_defect , is_defect_type, il_defect_item, is_ac, gs_user);
                      End If;

                      S_NEW := ' ';
                      DW_EU.picklist := IL_PICKLIST;
                      
                      IF TRIM(DW_EU.TRANSACTION) IS NULL THEN
                        DW_EU.TRANSACTION := 'REQUIRE';
                      end if;
                  
                      IF TRIM(DW_EU.DISTRIBUTION_LINE) IS NULL THEN
                        DW_EU.distribution_line := 0;
                      end if;
                  
                      IF TRIM(DW_EU.qty_picked) IS NULL THEN
                        DW_EU.qty_picked := 1;
                      end if;
                  
                      if TRIM(DW_EU.STATUS) IS NULL THEN
                        DW_EU.STATUS := 'OPEN';
                      end if;
                  
                      T_DW_EU.EXTEND;
                      T_DW_EU(T_DW_EU.last) := dw_eu;
                     

                    End If;

                    IF IS_WOPKLNLA = 'Y' AND NVL(DW_PN_INVENTORY_AVL(1).PN,' ') <> ' ' THEN
                      DECLARE
                        B_INCOMPLETE BOOLEAN;
                        L_BATCH NUMBER;
                        l_trow NUMBER;
                        l_row NUMBER;
                        L_SAVED_CROW NUMBER;
                        D_PICKLIST_QTY NUMBER;
                        B_CONTINUE BOOLEAN := FALSE;
                      BEGIN
                        D_PICKLIST_QTY := 0;
                        L_SAVED_CROW := 0;
                        l_trow := dw_eu.qty;

                        FOR L_CROW IN 1..L_TROW
                        loop

                          B_CONTINUE := FALSE;

                          IF L_CROW > 1 THEN
                            DW_EU.BATCH := 0;
                            I_RETURN := WF_EDIT(DW_EU, DW_PN_INVENTORY_AVL, DW_PN_INVENTORY_AVL_QTY,
                                               dw_pn_inventory_avl_qty1, dw_pn_inventory_avl_qty2, is_errfld, IS_TPW,
                                               IS_AC, IL_WO, IS_LOCATION, IS_ETOPS_ACTION,
                                               IS_ORIGINAL, GS_COMPANY_MULTI, IS_BOCRT, IS_SHORTAGE_PRINT_ONLY,
                                               IL_REQUISITION, IS_PN, IS_PRIORITY_REQ,
                                               IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ,
                                               IS_COMPANY, IS_TASK_CARD, GS_USER, IS_EC,
                                               IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, is_defect , is_defect_type , il_defect_item,
                                               IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                               IL_REQUIRE_HOUR_REQ, il_require_minute_req);
                            IF I_RETURN = 1 THEN B_CONTINUE := TRUE; END IF;
                          END IF;

                          IF NOT B_CONTINUE THEN

                            L_BATCH := 0;
                            b_incomplete := WF_CHECK_INCOMPLETE(l_batch, dw_pn_inventory_avl, MS_PN);
                            DW_EU.BATCH := L_BATCH;

                            --log 150548 modified
                            BEGIN
                              SELECT "PROFILE"
                              INTO PROFILE_NAME
                              from PROFILE_MASTER;
                            EXCEPTION
                            WHEN OTHERS THEN
                              PROFILE_NAME := NULL;
                            END;

                            IF(PROFILE_NAME = 'SWA')
                            then
                              null;
                            else
                              dw_eu.qty := 1;
                            END IF;
                            --log 150548 modified

                            IF B_INCOMPLETE  THEN
                              IF (NVL(T_DW_SEL_DEFECT(I_CROW).S_RESERVE, 'YES') <> 'DELETE') AND (I_CROW <> L_SAVED_CROW) THEN
                                IF IMESSAGEBOXINCOMPLETE = 1 THEN
  --                                wf_load_missing_nla(l_batch) --TODO
                                 L_SAVED_CROW := I_CROW;
                                End If;
                              ELSE
  --                              wf_load_missing_nla(l_batch) --TODO
                                NULL;
                              END IF;
                            End If;

                            --log 150548 modified
                            IF(PROFILE_NAME = 'SWA')
                            then
                              D_QTY := 1;
                            else
                              D_QTY := DW_EU.QTY;
                            end if;
                            --log 150548 modified

                            D_QTY_RESERVED := T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED;
                            D_QTY_RESERVED := nvl(D_QTY_RESERVED,0) + nvl( D_QTY, 0 );
                            T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED := D_QTY_RESERVED;
                            T_DW_SEL_DEFECT(I_CROW).DT_MODIFIED_DATE := DT_TODAY;
                            T_DW_SEL_DEFECT(I_CROW).S_PICKLIST_PROCESSED := 'Y';
                            MS_PN.S_LOCATION := IS_LOCATION;
                            MS_PN.S_TASK_CARD  := IS_TASK_CARD;
                            IF IS_BOCRT = 'N' THEN MS_PN.s_transaction_type := 'NOREQUISITION'; END IF;
                            MS_PN.N_PICKLIST := IL_PICKLIST;
                            --I_RETURN := DW_PN_INVENTORY_AVL.count;
                            T_DW_EU.EXTEND;
                            T_DW_EU(T_DW_EU.last) := OF_PICKLIST_DISTRIBUTION2(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);
                            --t_dw_eu := OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);
                            IF NVL(MS_PN.n_PICKLIST_DISTRIBUTION_LINE,0) = 0 THEN
                              T_DW_EU(T_DW_EU.last).distribution_line := T_DW_EU.last;
                            ELSE
                              T_DW_EU(T_DW_EU.last).distribution_line := MS_PN.n_PICKLIST_DISTRIBUTION_LINE;
                            END IF;
                
                            I_RETURN := T_DW_EU.count;
                            D_PICKLIST_QTY := nvl(D_PICKLIST_QTY,0) + 1;

                          END IF;
                        end loop;

                   -- Log159804
                     -- for L_CROW in T_DW_EU.first..T_DW_EU.last
                       -- LOOP
                        --T_DW_EU(L_CROW).QTY := D_PICKLIST_QTY;
                        --end loop;
                   -- 159804

                        DW_EU.BATCH := 0;

                        DW_EU.QTY := D_PICKLIST_QTY;

                      END;
                    Else

                      D_QTY := DW_EU.QTY;
                      D_QTY_RESERVED := nvl(D_QTY_RESERVED, 0 ) + nvl( D_QTY , 0 );
                      T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED := D_QTY_RESERVED;
                      T_DW_SEL_DEFECT(I_CROW).DT_MODIFIED_DATE := DT_TODAY;
                      T_DW_SEL_DEFECT(I_CROW).S_PICKLIST_PROCESSED := 'Y';
                      MS_PN.S_LOCATION := IS_LOCATION;
                      MS_PN.S_TASK_CARD  := IS_TASK_CARD;
                      IF IS_BOCRT = 'N' THEN MS_PN.s_transaction_type := 'NOREQUISITION'; END IF;
                      MS_PN.N_PICKLIST := IL_PICKLIST;
                      t_dw_eu := OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);

                    END IF;

                    GF_SAVE_TT_PICKLIST_DISTRIB(t_dw_eu);

                    DECLARE
                      L_PICKLIST_LINE NUMBER := DW_EU.PICKLIST_LINE;
                    BEGIN
                      PICKLIST_DISTRIBUTION_AUDIT(IL_PICKLIST, L_PICKLIST_LINE, 'NEW', GS_USER);
                      IS_TRAN := ' ';
                    end;
                  End If;
                END IF;
              End If;
            end if;
          end;
        end loop;
        end if ;

        if ms_location_site.s_shortage_print_only = 'N' then
          IF IS_WOPKLNLA = 'Y' THEN
            DECLARE
              S_DELETE varchar2(100);
            BEGIN

              IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
                FOR I_CROW in reverse t_dw_sel.first..t_dw_sel.last
                LOOP
                  s_delete := nvl(t_dw_sel(i_crow).S_reserve, 'YES');
                  IF ( S_DELETE = 'DELETE' ) OR ( S_DELETE = 'MAIN' ) THEN
                    T_DW_SEL(I_CROW) := NULL;
                  End If;
                END LOOP;
              end if;


               IF T_DW_SEL_DEFECT IS NOT NULL AND T_DW_SEL_DEFECT.COUNT > 0 THEN
                FOR I_CROW in reverse T_DW_SEL_DEFECT.first..T_DW_SEL_DEFECT.last
                LOOP
                  s_delete := nvl(T_DW_SEL_DEFECT(i_crow).S_reserve, 'YES');
                  IF ( S_DELETE = 'DELETE' ) OR ( S_DELETE = 'MAIN' ) THEN
                    T_DW_SEL_DEFECT(I_CROW) := NULL;
                  End If;
                END LOOP;
              end if;


            end;
          End If;

          --print picklist to report server for picklist use
          sendPicklistToPrintQueue(IL_PICKLIST) ;

          --send notification , TODO
         IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
          GF_SAVE_WO_TC_PN_ARRAY(T_DW_SEL);
        end if;


        IF T_DW_SEL_DEFECT IS NOT NULL AND T_DW_SEL_DEFECT.COUNT > 0 THEN
          GF_SAVE_DEFECT_PN_ARRAY(T_DW_SEL_DEFECT);
        end if;

        return IL_PICKLIST;


        end if;

      end if;
    end if;
    return 0;

  END eMobility_Picklist_defect;
  
  /*
  Function eMobility_Picklist_defect(N_WO NUMBER, S_AC VARCHAR2, MS_LOCATION_SITE IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                       MS_LOCATION_SITE_REQ IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                       S_TASK_CARD VARCHAR2 DEFAULT NULL,S_TASK_CARD_PN VARCHAR2 DEFAULT NULL , S_TASK_CARD_SN VARCHAR2 DEFAULT NULL , 
                                       s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0, 
                                       GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER) return number
  AS
    s_customer varchar2(100) := '';
    GS_STATUS VARCHAR2(100) := ' ';
    idt_today date := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    S_WOPICK1 VARCHAR2(100) := 'N' ; --PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPICK1');
    MS_PN PKG_TYPE_STRUCTURES.ST_PN;
    IL_WO NUMBER := N_WO;
    IS_BOCRT VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('BOCRT');
    IS_WOPURSVRQ VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPURSVRQ');
    IS_WOPKLNLA VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPKLNLA');
    is_COMPANYMULTIREQ varchar2(100);
    I_CROW NUMBER := 0;
    I_AROW NUMBER := 0;
    DT_SCHEDULE_START_DATE DATE;
    DT_TODAY DATE;
    S_SV_TASK_CARD VARCHAR2(100);
    IL_PICKLIST NUMBER := 0 ;

    T_DW_SEL WO_TC_PN_ARRAY;
    T_DW_SEL_DEFECT DEFECT_PN_ARRAY;

    is_location VARCHAR2(100);
    is_ac VARCHAR2(100);
    idt_schedule_start_date date;
    is_tpw VARCHAR2(100);
    is_priority VARCHAR2(100);
    is_site VARCHAR2(100);
    is_module VARCHAR2(100);
    IS_COMPANY VARCHAR2(100);
    S_LOCATION VARCHAR2(100);
    IDT_REQUIRE_DATE DATE;
    IL_REQUIRE_HOUR number;
    IL_REQUIRE_MINUTE number;
    IS_DELIVERY_LOCATION VARCHAR2(100);
    IS_SHORTAGE_PRINT_ONLY VARCHAR2(100);
    IS_PRIORITY_REQ VARCHAR2(100);
    IS_REQUISITION_TYPE VARCHAR2(100);
    IDT_REQUIRE_DATE_REQ DATE;
    IL_REQUIRE_HOUR_REQ NUMBER;
    IL_REQUIRE_MINUTE_REQ NUMBER;
    DW_EU PICKLIST_DISTRIBUTION%ROWTYPE;
    DW_PICKLIST_DETAIL PICKLIST_DISTRIBUTION%ROWTYPE;
    dw_pn_inventory_avl PKG_TYPE_STRUCTURES.dw_INVENTORY_TRAN_AVL;
    IS_TASK_CARD VARCHAR2(100);
    IS_TASK_CARD_HEADER VARCHAR2(100);
    IS_TASK_CARD_PN VARCHAR2(100);
    IS_TASK_CARD_PN_SN VARCHAR2(100);


    IS_DEFECT "DEFECT_REPORT"."DEFECT"%type;
    IS_DEFECT_TYPE "DEFECT_REPORT"."DEFECT_TYPE"%type;
    IL_DEFECT_ITEM "DEFECT_REPORT"."DEFECT_ITEM"%type;


    IS_AC_TC VARCHAR2(100);
    IS_EC VARCHAR2(100);
    S_NEW VARCHAR2(100);
    IS_TRAN VARCHAR2(100);
    IL_REQUISITION NUMBER;
    profile_name varchar2(200);
    is_original varchar2(32000) := ' SELECT DISTINCT "LOCATION_MASTER_ROUTINE"."MASTER_LOCATION_SEQUENCE",   
                                                       "LOCATION_MASTER_ROUTINE"."MASTER_LOCATION",   
                                                       NVL("PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION", sysdate + 200000) as dt_shelf_life_computed,   
                                                       "PN_INVENTORY_DETAIL"."BATCH",   
                                                       "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH",   
                                                       "PN_INVENTORY_DETAIL"."VENDOR_LOT",   
                                                       "PN_INVENTORY_DETAIL"."PN",   
                                                       "PN_INVENTORY_DETAIL"."SN",   
                                                       "PN_INVENTORY_DETAIL"."NHA_PN",   
                                                       "PN_INVENTORY_DETAIL"."NHA_SN",   
                                                       "PN_INVENTORY_DETAIL"."CONDITION",   
                                                       "PN_INVENTORY_DETAIL"."OWNER",   
                                                       "PN_INVENTORY_DETAIL"."UNIT_COST",   
                                                       "PN_INVENTORY_DETAIL"."CURRENCY",   
                                                       "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE",   
                                                       "PN_INVENTORY_DETAIL"."RI_BY",   
                                                       "PN_INVENTORY_DETAIL"."RI_DATE",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_AC",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_POSITION",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_HOUR",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_MINUTE",   
                                                       "PN_INVENTORY_DETAIL"."LOCATION",   
                                                       "PN_INVENTORY_DETAIL"."BIN",   
                                                       "PN_INVENTORY_DETAIL"."QTY_AVAILABLE",   
                                                       "PN_INVENTORY_DETAIL"."QTY_RESERVED",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_TRANSFER",   
                                                       "PN_INVENTORY_DETAIL"."QTY_PENDING_RI",   
                                                       "PN_INVENTORY_DETAIL"."QTY_US",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_REPAIR",   
                                                       "PN_INVENTORY_DETAIL"."RI_CONTROL",   
                                                       "PN_INVENTORY_DETAIL"."US_CODE",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION",   
                                                       "PN_INVENTORY_DETAIL"."LOAN_CATEGORY",   
                                                       "PN_INVENTORY_DETAIL"."CUTOM_DUTY_CODE",   
                                                       "PN_INVENTORY_DETAIL"."GL_COMPANY",   
                                                       "PN_INVENTORY_DETAIL"."GL_EXPENDITURE",   
                                                       "PN_INVENTORY_DETAIL"."GL",   
                                                       "PN_INVENTORY_DETAIL"."GL_COST_CENTER",   
                                                       "PN_INVENTORY_DETAIL"."NOTES",   
                                                       "PN_INVENTORY_DETAIL"."CREATED_BY",   
                                                       "PN_INVENTORY_DETAIL"."CREATED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."MODIFIED_BY",   
                                                       "PN_INVENTORY_DETAIL"."MODIFIED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_DATE",   
                                                       "PN_INVENTORY_DETAIL"."KIT_NO",   
                                                       "PN_INVENTORY_DETAIL"."CURRENCY_EXCHANGE_RATE",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_RENTAL",   
                                                       "PN_INVENTORY_DETAIL"."SECONDARY_COST",   
                                                       "PN_INVENTORY_DETAIL"."SECONDARY_CURRENCY_EXCHANGE",   
                                                       "PN_INVENTORY_DETAIL"."BLOB_NO",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_AC",   
                                                       "PN_INVENTORY_DETAIL"."MOD_STATUS",   
                                                       "PN_INVENTORY_DETAIL"."CUSTOM_DUTY_DOCUMENT",   
                                                       "PN_INVENTORY_DETAIL"."PENDING",   
                                                       "PN_INVENTORY_DETAIL"."PENDING_DATE",   
                                                       "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE_ORIGINAL",   
                                                       "PN_INVENTORY_DETAIL"."SOS_DATE",   
                                                       "PN_INVENTORY_DETAIL"."SOS_HOUR",   
                                                       "PN_INVENTORY_DETAIL"."SOS_MINUTE",   
                                                       "PN_INVENTORY_DETAIL"."TAG_BY",   
                                                       "PN_INVENTORY_DETAIL"."TAG_DATE",   
                                                       "PN_INVENTORY_DETAIL"."TAG_NO",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_RECORDS_BY",   
                                                       "PN_INVENTORY_DETAIL"."ORGINAL_RECORDS_DATE",   
                                                       "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT",   
                                                       "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT_DATE",   
                                                       "PN_INVENTORY_DETAIL"."PN_MODEL",   
                                                       "PN_INVENTORY_DETAIL"."PN_SOFTWARE",   
                                                       "PN_INVENTORY_DETAIL"."FILING_SEQUENCE",   
                                                       "PN_INVENTORY_DETAIL"."NO_OF_TAG_PRINT",   
                                                       "PN_INVENTORY_DETAIL"."OWNER_ORIGIN",   
                                                       "PN_INVENTORY_DETAIL"."NLA_POSITION",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_HOURS",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_MINUTES",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_CYCLES",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_DAYS",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION_LAST",   
                                                       "PN_INVENTORY_DETAIL"."INVENTORY_TYPE",   
                                                       "PN_INVENTORY_DETAIL"."DOCUMENT_NO",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION_LAST",   
                                                       "PN_INVENTORY_DETAIL"."SLOT",   
                                                       "PN_INVENTORY_DETAIL"."COST_IN_KIT",   
                                                       "PN_INVENTORY_DETAIL"."REPAIR_RETURN_DATE",   
                                                       "PN_INVENTORY_DETAIL"."HAZARDOUS_MATERIAL_AT_REMOVAL",   
                                                       "PN_INVENTORY_DETAIL"."WEIGHT",   
                                                       "PN_INVENTORY_DETAIL"."WEIGHT_UNIT",   
                                                       "PN_INVENTORY_DETAIL"."MANAGED_WO",   
                                                       "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_BY",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_AC_ISSUE_TO_ONLY",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXP_EOM",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXP_EOM",   
                                                       "PN_INVENTORY_DETAIL"."LEGACY_BATCH",   
                                                       "PN_INVENTORY_DETAIL"."ADJUSTMENT_CODE",   
                                                       DECODE("PN_INVENTORY_DETAIL"."OWNER", :1, 1, 2) as owner_sort  
                                                  FROM "PN_INVENTORY_DETAIL",   
                                                       "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_A",   
                                                       "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_B",   
                                                       "LOCATION_MASTER_ROUTINE"  
                                                 WHERE ( "PN_INTERCHANGEABLE_A"."PN" = "PN_INTERCHANGEABLE_B"."PN" ) and  
                                                       ( "PN_INTERCHANGEABLE_A"."PN_INTERCHANGEABLE" = "PN_INVENTORY_DETAIL"."PN" ) and  
                                                       ( "PN_INVENTORY_DETAIL"."LOCATION" = "LOCATION_MASTER_ROUTINE"."LOCATION_ROUTING" ) ';
  BEGIN
    --UE_POSTOPEN


     T_DW_SEL_DEFECT := WF_LOAD_DEFECT_PN_FOR_RESERVE(N_WO, S_AC, s_defect , s_defect_type, l_defect_item);

    DT_TODAY := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;

    if (T_DW_SEL_DEFECT is not null and T_DW_SEL_DEFECT.count > 0 )then

      begin



      SELECT "WO"."LOCATION",
          "WO"."AC",  
          "WO"."SCHEDULE_START_DATE",
          "WO"."THIRD_PARTY_WO",
          "WO"."PRIORITY",
          "WO"."SITE",
          "WO"."MODULE",
          "WO"."GL_COMPANY"  
      INTO is_location,   
          is_ac,
          idt_schedule_start_date,
          is_tpw,
          is_priority,
          is_site, 
          is_module,
          is_company
      FROM "WO"  
      WHERE "WO"."WO" = n_wo;


        SELECT trim("RELATION_MASTER"."EMPLOYEE_CONTRACTOR")
        INTO ms_pn.s_owner  
        FROM "CUSTOMER_ORDER_HEADER",   
            "RELATION_MASTER"  
        WHERE ( "CUSTOMER_ORDER_HEADER"."CUSTOMER" = "RELATION_MASTER"."RELATION_CODE" ) and  
          ( ( "CUSTOMER_ORDER_HEADER"."ORDER_TYPE" = 'W/O' ) AND  
          ( "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER" = N_WO ) );
      EXCEPTION
      WHEN OTHERS THEN
        ms_pn.s_owner := null;
      end;

      S_SV_TASK_CARD := ' ';


      --done for task control nelson
      --location
      if MS_LOCATION_SITE.S_LOCATION is null then
        MS_LOCATION_SITE.S_LOCATION := IS_LOCATION;
      else
        IS_LOCATION :=  MS_LOCATION_SITE.S_LOCATION ;
      end if; 

      --site
      if MS_LOCATION_SITE.S_SITE is null then       
        MS_LOCATION_SITE.S_SITE := IS_SITE;
      else
        IS_SITE := IS_SITE ; 
      end if; 





      --priority
       if  Ms_Location_Site.S_Priority is not null then
        is_priority := Ms_Location_Site.S_Priority ;
      end if ; 

      --end done for task control nelson

      MS_LOCATION_SITE.S_TRANSACTION := 'PICKLIST';
      MS_LOCATION_SITE.S_MODULE := IS_MODULE;
      MS_LOCATION_SITE.L_WO := n_WO;  



      s_location := ms_location_site.s_location;

      if trim(s_location) is not null Then

        IS_COMPANYMULTIREQ := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('COMPANYMULTIREQ');
        IDT_REQUIRE_DATE := MS_LOCATION_SITE.DT_REQUIRE_DATE;
        IL_REQUIRE_HOUR := MS_LOCATION_SITE.L_HOUR;
        IL_REQUIRE_MINUTE := MS_LOCATION_SITE.L_MINUTE;
        IS_DELIVERY_LOCATION := MS_LOCATION_SITE.S_DELIVERY_LOCATION;
        IS_SHORTAGE_PRINT_ONLY := MS_LOCATION_SITE.S_SHORTAGE_PRINT_ONLY;

        IF TRIM(S_LOCATION) IS NOT NULL THEN IS_LOCATION := S_LOCATION; END IF;
        IF TRIM(IS_DELIVERY_LOCATION) IS NULL THEN IS_DELIVERY_LOCATION := IS_LOCATION; END IF;
        IF TRIM(MS_LOCATION_SITE.S_SITE) IS NOT NULL THEN IS_SITE := MS_LOCATION_SITE.S_SITE; END IF;
        IF IDT_SCHEDULE_START_DATE < DT_TODAY THEN IDT_SCHEDULE_START_DATE := DT_TODAY; END IF;
        If trim(idt_require_date) is not null Then idt_schedule_start_date := idt_require_date; end if;

        IS_WOPURSVRQ := 'Y';
        IS_BOCRT := 'Y';
        IS_SHORTAGE_PRINT_ONLY := 'N';

        IF IS_WOPURSVRQ = 'Y' AND IS_BOCRT = 'Y' AND IS_SHORTAGE_PRINT_ONLY = 'N' THEN
          ms_location_site_req.s_location := is_location;
          MS_LOCATION_SITE_REQ.S_SITE := IS_SITE;
          ms_location_site_req.s_transaction := 'REQUISITION/PK';
          MS_LOCATION_SITE_REQ.S_MODULE := IS_MODULE;
          MS_LOCATION_SITE_REQ.L_WO := n_WO;
          IF trim(MS_LOCATION_SITE_REQ.S_LOCATION) is null THEN 
            RETURN 0;
          End If;
          IS_PRIORITY_REQ := MS_LOCATION_SITE_REQ.S_PRIORITY;
          IS_REQUISITION_TYPE := MS_LOCATION_SITE_REQ.S_TYPE;
          IDT_REQUIRE_DATE_REQ := MS_LOCATION_SITE_REQ.DT_REQUIRE_DATE;
          IL_REQUIRE_HOUR_REQ := MS_LOCATION_SITE_REQ.L_HOUR;
          IL_REQUIRE_MINUTE_REQ := MS_LOCATION_SITE_REQ.L_MINUTE;
        End If;


       if (T_DW_SEL_DEFECT is not null and T_DW_SEL_DEFECT.count > 0 )then

        FOR I_CROW IN T_DW_SEL_DEFECT.FIRST..T_DW_SEL_DEFECT.LAST
        LOOP
          DECLARE
            D_QTY_RESERVED NUMBER;
            D_QTY NUMBER;
            D_REQUISITION NUMBER;
            IS_PN VARCHAR2(100);
            ID_QTY NUMBER;
            S_ETOPS_ACTION VARCHAR2(100);
            D_REQUISITION_ORDER NUMBER;
            D_ORDER_RESERVER NUMBER;
            I_RETURN NUMBER;
            II_NONEFFECTIVE NUMBER;
            DW_PN_INVENTORY_AVL_QTY NUMBER;
            DW_PN_INVENTORY_AVL_QTY1 NUMBER;
            DW_PN_INVENTORY_AVL_QTY2 NUMBER;
            IS_ERRFLD VARCHAR2(100);
            IS_ETOPS_ACTION VARCHAR2(100);
            IS_PN_DESCRIPTION VARCHAR2(32000);
            t_dw_eu PKG_TYPE_STRUCTURES.tt_picklist_distribution := PKG_TYPE_STRUCTURES.tt_picklist_distribution();
             n_batch VARCHAR2(100);
             s_sn NUMBER;
          begin
            IS_DEFECT := T_DW_SEL_DEFECT(I_CROW).s_defect;
            IF S_WOPICK1 = 'N' THEN IS_TASK_CARD_HEADER := IS_TASK_CARD; END IF;
            IS_DEFECT_TYPE := T_DW_SEL_DEFECT(I_CROW).S_defect_type;
            IL_defect_item := T_DW_SEL_DEFECT(I_CROW).l_defect_item;
            IS_AC_TC := T_DW_SEL_DEFECT(I_CROW).S_AC;
            T_DW_SEL_DEFECT(I_CROW).s_picklist_processed := 'N';




            S_NEW := 'NEW';
            S_SV_TASK_CARD := IS_TASK_CARD;
            DW_EU.picklist := IL_PICKLIST;



            IS_PN := T_DW_SEL_DEFECT(I_CROW).S_PN;
            ID_QTY := T_DW_SEL_DEFECT(I_CROW).N_QTY;
            D_QTY_RESERVED := T_DW_SEL_DEFECT(I_CROW).n_qty_reserved;

            IF PKG_APPLICATION_FUNCTION.CONFIG_FLAG('ETOPS') = 'N' THEN S_ETOPS_ACTION := GF_ETOPS_VALIDATION(IL_WO, IS_PN); END IF;

            if nvl(s_etops_action,'5') <> '1' and nvl(s_etops_action,'5') <> '2' then
              IF NVL(S_ETOPS_ACTION,'5') = '3' OR NVL(S_ETOPS_ACTION,'5') = '4' THEN 
                IS_PN := DF_GET_INTERCHANGE_EFFECTIVE(IS_PN, IS_AC, IL_WO);
                MS_PN.S_ORDER_TYPE := 'S/O';
              END IF	;

              IF trim(D_QTY_RESERVED) is null THEN 	D_QTY_RESERVED := 0; end if;

              D_REQUISITION := 0;

              begin
                SELECT sum( "REQUISITION_DETAIL"."QTY_REQUIRE" )  
                INTO d_requisition  
                FROM "REQUISITION_HEADER",   
                    "REQUISITION_DETAIL"  
                WHERE ( "REQUISITION_DETAIL"."REQUISITION" = "REQUISITION_HEADER"."REQUISITION" ) and  
                    (  
                    ( "REQUISITION_HEADER"."DEFECT" = is_defect ) AND 
                    ( "REQUISITION_HEADER"."DEFECT_TYPE" = is_defect_type ) AND
                    ( "REQUISITION_HEADER"."DEFECT_ITEM" = il_defect_item ) AND
                    ( "REQUISITION_DETAIL"."PN" = IS_PN ) AND
                    ( "REQUISITION_DETAIL"."STATUS" IN ('OPEN','CLOSED')));
              EXCEPTION
              WHEN OTHERS THEN
                d_requisition := null;
              END;

              If trim(d_requisition) is null Then d_requisition := 0; end if;

              d_requisition_order := 0;

              begin
              SELECT sum( "REQUISITION_DETAIL"."QTY_REQUIRE" )  
              INTO d_requisition_order  
              FROM "REQUISITION_HEADER",   
                  "REQUISITION_DETAIL"  
              WHERE ( "REQUISITION_DETAIL"."REQUISITION" = "REQUISITION_HEADER"."REQUISITION" ) and  
                  ( 
                  ( "REQUISITION_HEADER"."DEFECT" = is_defect ) AND  
                  ( "REQUISITION_HEADER"."DEFECT_TYPE"  = is_defect_type ) AND
                  ( "REQUISITION_HEADER"."DEFECT_ITEM" = il_defect_item ) AND
                  ( "REQUISITION_DETAIL"."PN" = is_pn ) and
                  ( "REQUISITION_DETAIL"."STATUS" = 'ORDER'));
              EXCEPTION
              WHEN OTHERS THeN
                d_requisition_order := null;
              end;

              If trim(d_requisition_order) is null Then d_requisition_order := 0; end if;

              D_ORDER_RESERVER := 0;

              begin
                SELECT sum("ORDER_DETAIL"."QTY_REQUIRE")  
                INTO d_order_reserver  
                FROM "ORDER_DETAIL"  
                WHERE ( "ORDER_DETAIL"."PN" = is_pn ) AND  
                    ( "ORDER_DETAIL"."AUTO_ISSUE" in ( 'RESERVE','ISSUE') ) AND                     
                    ( "ORDER_DETAIL"."DEFECT" = IS_DEFECT ) and
                    ( "ORDER_DETAIL"."DEFECT_TYPE" = IS_DEFECT_TYPE ) and 
                    ( "ORDER_DETAIL"."DEFECT_ITEM" = IL_DEFECT_ITEM );
              exception
              WHEN OTHERS THEN
                D_ORDER_RESERVER := NULL;
              end;

              If trim(d_order_reserver) is null Then d_order_reserver := 0; end if;

              id_qty := id_qty - (d_qty_reserved + d_requisition + d_requisition_order + d_order_reserver);

              IF ID_QTY > 0 THEN

                n_batch:= null;
                s_sn := null;

                DW_EU := WF_NEW(IS_TRAN, IL_PICKLIST, IS_PN, IS_TASK_CARD, ID_QTY, GS_USER,n_batch,s_sn);
                I_RETURN :=0;
                ii_nonEffective := 1;

                i_return :=  WF_EDIT(DW_EU, DW_PN_INVENTORY_AVL, DW_PN_INVENTORY_AVL_QTY,
                                     dw_pn_inventory_avl_qty1, dw_pn_inventory_avl_qty2, is_errfld, IS_TPW,
                                     IS_AC, IL_WO, IS_LOCATION, IS_ETOPS_ACTION,
                                     IS_ORIGINAL, GS_COMPANY_MULTI, IS_BOCRT, IS_SHORTAGE_PRINT_ONLY,
                                     IL_REQUISITION, IS_PN, IS_PRIORITY_REQ,
                                     IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ,
                                     IS_COMPANY, IS_TASK_CARD, GS_USER, IS_EC,
                                     IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, is_defect , is_defect_type , il_defect_item ,
                                     IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                     IL_REQUIRE_HOUR_REQ, il_require_minute_req);

                ms_location_site.s_shortage_print_only := 'N';                     
                if ms_location_site.s_shortage_print_only = 'N' then

                  begin
                    SELECT "PN_MASTER"."PN_DESCRIPTION"   
                    INTO is_pn_description   
                    FROM "PN_MASTER",   
                        "PN_INTERCHANGEABLE"  
                    WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) AND  
                        ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = is_pn ) );
                  EXCEPTION
                  WHEN OTHERS THEN 
                    is_pn_description := null;
                  END;

                  If i_return = 0 then
                    If s_new = 'NEW' Then
                    S_WOPICK1:='N';
                      IF S_WOPICK1 = 'N' OR ( S_WOPICK1 = 'Y' AND IL_PICKLIST = 0 )   THEN
                        WF_NEW_PICKLIST_HEADER(IL_PICKLIST, IS_LOCATION, IL_WO, IS_TASK_CARD_HEADER,
                                               IDT_SCHEDULE_START_DATE, IL_REQUIRE_HOUR, IL_REQUIRE_MINUTE,
                                               IS_DELIVERY_LOCATION, IS_PRIORITY, IS_SITE, IS_TASK_CARD_PN,
                                               is_task_card_pn_sn, is_defect , is_defect_type, il_defect_item, is_ac, gs_user);
                      End If;

                      S_NEW := ' ';
                      DW_EU.picklist := IL_PICKLIST;

                    End If;

                    IF IS_WOPKLNLA = 'Y' AND NVL(DW_PN_INVENTORY_AVL(1).PN,' ') <> ' ' THEN
                      DECLARE
                        B_INCOMPLETE BOOLEAN;
                        L_BATCH NUMBER;
                        l_trow NUMBER;
                        l_row NUMBER;
                        L_SAVED_CROW NUMBER;
                        D_PICKLIST_QTY NUMBER;
                        B_CONTINUE BOOLEAN := FALSE;
                      BEGIN
                        D_PICKLIST_QTY := 0;
                        L_SAVED_CROW := 0;
                        l_trow := dw_eu.qty; 

                        FOR L_CROW IN 1..L_TROW
                        loop

                          B_CONTINUE := FALSE;

                          IF L_CROW > 1 THEN
                            DW_EU.BATCH := 0;
                            I_RETURN := WF_EDIT(DW_EU, DW_PN_INVENTORY_AVL, DW_PN_INVENTORY_AVL_QTY,
                                               dw_pn_inventory_avl_qty1, dw_pn_inventory_avl_qty2, is_errfld, IS_TPW,
                                               IS_AC, IL_WO, IS_LOCATION, IS_ETOPS_ACTION,
                                               IS_ORIGINAL, GS_COMPANY_MULTI, IS_BOCRT, IS_SHORTAGE_PRINT_ONLY,
                                               IL_REQUISITION, IS_PN, IS_PRIORITY_REQ,
                                               IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ,
                                               IS_COMPANY, IS_TASK_CARD, GS_USER, IS_EC,
                                               IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, is_defect , is_defect_type , il_defect_item,
                                               IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                               IL_REQUIRE_HOUR_REQ, il_require_minute_req);
                            IF I_RETURN = 1 THEN B_CONTINUE := TRUE; END IF;
                          END IF;

                          IF NOT B_CONTINUE THEN

                            L_BATCH := 0;
                            b_incomplete := WF_CHECK_INCOMPLETE(l_batch, dw_pn_inventory_avl, MS_PN);
                            DW_EU.BATCH := L_BATCH;

                            --log 150548 modified
                            BEGIN
                              SELECT "PROFILE"
                              INTO PROFILE_NAME 
                              from PROFILE_MASTER;
                            EXCEPTION
                            WHEN OTHERS THEN
                              PROFILE_NAME := NULL;
                            END;

                            IF(PROFILE_NAME = 'SWA')
                            then
                              null;
                            else
                              dw_eu.qty := 1;
                            END IF;
                            --log 150548 modified

                            IF B_INCOMPLETE  THEN
                              IF (NVL(T_DW_SEL_DEFECT(I_CROW).S_RESERVE, 'YES') <> 'DELETE') AND (I_CROW <> L_SAVED_CROW) THEN
                                IF IMESSAGEBOXINCOMPLETE = 1 THEN
  --                                wf_load_missing_nla(l_batch) --TODO
                                 L_SAVED_CROW := I_CROW;
                                End If;
                              ELSE
  --                              wf_load_missing_nla(l_batch) --TODO
                                NULL;
                              END IF;
                            End If;

                            --log 150548 modified
                            IF(PROFILE_NAME = 'SWA')
                            then
                              D_QTY := 1;	
                            else
                              D_QTY := DW_EU.QTY;
                            end if;
                            --log 150548 modified

                            D_QTY_RESERVED := T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED;
                            D_QTY_RESERVED := nvl(D_QTY_RESERVED,0) + nvl( D_QTY, 0 );
                            T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED := D_QTY_RESERVED;
                            T_DW_SEL_DEFECT(I_CROW).DT_MODIFIED_DATE := DT_TODAY;
                            T_DW_SEL_DEFECT(I_CROW).S_PICKLIST_PROCESSED := 'Y'; 
                            MS_PN.S_LOCATION := IS_LOCATION;
                            MS_PN.S_TASK_CARD  := IS_TASK_CARD;
                            IF IS_BOCRT = 'N' THEN MS_PN.s_transaction_type := 'NOREQUISITION'; END IF;
                            MS_PN.N_PICKLIST := IL_PICKLIST;
                            t_dw_eu := OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);
                            D_PICKLIST_QTY := nvl(D_PICKLIST_QTY,0) + 1;

                          END IF;
                        end loop;

                   -- Log159804
                      for L_CROW in T_DW_EU.first..T_DW_EU.last
                        LOOP
                        T_DW_EU(L_CROW).QTY := D_PICKLIST_QTY;
                        end loop;
                   -- 159804

                        DW_EU.BATCH := 0;

                        DW_EU.QTY := D_PICKLIST_QTY;

                      END;
                    Else	

                      D_QTY := DW_EU.QTY;
                      D_QTY_RESERVED := nvl(D_QTY_RESERVED, 0 ) + nvl( D_QTY , 0 );
                      T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED := D_QTY_RESERVED;
                      T_DW_SEL_DEFECT(I_CROW).DT_MODIFIED_DATE := DT_TODAY;
                      T_DW_SEL_DEFECT(I_CROW).S_PICKLIST_PROCESSED := 'Y';  
                      MS_PN.S_LOCATION := IS_LOCATION;
                      MS_PN.S_TASK_CARD  := IS_TASK_CARD;
                      IF IS_BOCRT = 'N' THEN MS_PN.s_transaction_type := 'NOREQUISITION'; END IF;
                      MS_PN.N_PICKLIST := IL_PICKLIST;
                      t_dw_eu := OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);

                    END IF;

                    GF_SAVE_TT_PICKLIST_DISTRIB(t_dw_eu);

                    DECLARE
                      L_PICKLIST_LINE NUMBER := DW_EU.PICKLIST_LINE;
                    BEGIN
                      PICKLIST_DISTRIBUTION_AUDIT(IL_PICKLIST, L_PICKLIST_LINE, 'NEW', GS_USER);
                      IS_TRAN := ' ';
                    end;
                  End If;
                END IF;
              End If;
            end if;
          end;
        end loop;
        end if ;

        if ms_location_site.s_shortage_print_only = 'N' then
          IF IS_WOPKLNLA = 'Y' THEN
            DECLARE
              S_DELETE varchar2(100);
            BEGIN

              IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
                FOR I_CROW in reverse t_dw_sel.first..t_dw_sel.last
                LOOP
                  s_delete := nvl(t_dw_sel(i_crow).S_reserve, 'YES');
                  IF ( S_DELETE = 'DELETE' ) OR ( S_DELETE = 'MAIN' ) THEN
                    T_DW_SEL(I_CROW) := NULL;
                  End If;
                END LOOP;
              end if;


               IF T_DW_SEL_DEFECT IS NOT NULL AND T_DW_SEL_DEFECT.COUNT > 0 THEN
                FOR I_CROW in reverse T_DW_SEL_DEFECT.first..T_DW_SEL_DEFECT.last
                LOOP
                  s_delete := nvl(T_DW_SEL_DEFECT(i_crow).S_reserve, 'YES');
                  IF ( S_DELETE = 'DELETE' ) OR ( S_DELETE = 'MAIN' ) THEN
                    T_DW_SEL_DEFECT(I_CROW) := NULL;
                  End If;
                END LOOP;
              end if;


            end;
          End If;

          --print picklist to report server for picklist use
          sendPicklistToPrintQueue(IL_PICKLIST) ;

          --send notification , TODO
         IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
          GF_SAVE_WO_TC_PN_ARRAY(T_DW_SEL);
        end if;  


        IF T_DW_SEL_DEFECT IS NOT NULL AND T_DW_SEL_DEFECT.COUNT > 0 THEN
          GF_SAVE_DEFECT_PN_ARRAY(T_DW_SEL_DEFECT);
        end if;

        return IL_PICKLIST;


        end if;

      end if;
    end if;
    return 0;

  END eMobility_Picklist_defect;
  */
  
  Function eMobility_Picklist_ac(n_id number, N_WO NUMBER, S_AC VARCHAR2, MS_LOCATION_SITE IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                       MS_LOCATION_SITE_REQ IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                       S_TASK_CARD VARCHAR2 DEFAULT NULL,S_TASK_CARD_PN VARCHAR2 DEFAULT NULL , S_TASK_CARD_SN VARCHAR2 DEFAULT NULL , 
                                       s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0, 
                                       GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER) return number
  AS
    s_customer varchar2(100) := '';
    GS_STATUS VARCHAR2(100) := ' ';
    idt_today date := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    S_WOPICK1 VARCHAR2(100) := 'N' ; --PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPICK1');
    MS_PN PKG_TYPE_STRUCTURES.ST_PN;
    IL_WO NUMBER := N_WO;
    IS_BOCRT VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('BOCRT');
    IS_WOPURSVRQ VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPURSVRQ');
    IS_WOPKLNLA VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPKLNLA');
    is_COMPANYMULTIREQ varchar2(100);
    I_CROW NUMBER := 0;
    I_AROW NUMBER := 0;
    DT_SCHEDULE_START_DATE DATE;
    DT_TODAY DATE;
    S_SV_TASK_CARD VARCHAR2(100);
    IL_PICKLIST NUMBER := 0 ;

    T_DW_SEL WO_TC_PN_ARRAY;
    T_DW_SEL_DEFECT DEFECT_PN_ARRAY;

    is_location VARCHAR2(100);
    is_ac VARCHAR2(100);
    idt_schedule_start_date date;
    is_tpw VARCHAR2(100);
    is_priority VARCHAR2(100);
    is_site VARCHAR2(100);
    is_module VARCHAR2(100);
    IS_COMPANY VARCHAR2(100);
    S_LOCATION VARCHAR2(100);
    IDT_REQUIRE_DATE DATE;
    IL_REQUIRE_HOUR number;
    IL_REQUIRE_MINUTE number;
    IS_DELIVERY_LOCATION VARCHAR2(100);
    IS_SHORTAGE_PRINT_ONLY VARCHAR2(100);
    IS_PRIORITY_REQ VARCHAR2(100);
    IS_REQUISITION_TYPE VARCHAR2(100);
    IDT_REQUIRE_DATE_REQ DATE;
    IL_REQUIRE_HOUR_REQ NUMBER;
    IL_REQUIRE_MINUTE_REQ NUMBER;
    DW_EU PICKLIST_DISTRIBUTION%ROWTYPE;
    DW_PICKLIST_DETAIL PICKLIST_DISTRIBUTION%ROWTYPE;
    dw_pn_inventory_avl PKG_TYPE_STRUCTURES.dw_INVENTORY_TRAN_AVL;
    IS_TASK_CARD VARCHAR2(100);
    IS_TASK_CARD_HEADER VARCHAR2(100);
    IS_TASK_CARD_PN VARCHAR2(100);
    IS_TASK_CARD_PN_SN VARCHAR2(100);


    IS_DEFECT "DEFECT_REPORT"."DEFECT"%type;
    IS_DEFECT_TYPE "DEFECT_REPORT"."DEFECT_TYPE"%type;
    IL_DEFECT_ITEM "PN_INVENTORY_DETAIL"."BATCH"%type;


    IS_AC_TC VARCHAR2(100);
    IS_EC VARCHAR2(100);
    S_NEW VARCHAR2(100);
    IS_TRAN VARCHAR2(100);
    IL_REQUISITION NUMBER;
    profile_name varchar2(200);
    S_NULL VARCHAR2(10);
    L_NULL NUMBER;
    is_original varchar2(32000) := ' SELECT DISTINCT "LOCATION_MASTER_ROUTINE"."MASTER_LOCATION_SEQUENCE",   
                                                       "LOCATION_MASTER_ROUTINE"."MASTER_LOCATION",   
                                                       NVL("PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION", sysdate + 200000) as dt_shelf_life_computed,   
                                                       "PN_INVENTORY_DETAIL"."BATCH",   
                                                       "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH",   
                                                       "PN_INVENTORY_DETAIL"."VENDOR_LOT",   
                                                       "PN_INVENTORY_DETAIL"."PN",   
                                                       "PN_INVENTORY_DETAIL"."SN",   
                                                       "PN_INVENTORY_DETAIL"."NHA_PN",   
                                                       "PN_INVENTORY_DETAIL"."NHA_SN",   
                                                       "PN_INVENTORY_DETAIL"."CONDITION",   
                                                       "PN_INVENTORY_DETAIL"."OWNER",   
                                                       "PN_INVENTORY_DETAIL"."UNIT_COST",   
                                                       "PN_INVENTORY_DETAIL"."CURRENCY",   
                                                       "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE",   
                                                       "PN_INVENTORY_DETAIL"."RI_BY",   
                                                       "PN_INVENTORY_DETAIL"."RI_DATE",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_AC",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_POSITION",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_HOUR",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_MINUTE",   
                                                       "PN_INVENTORY_DETAIL"."LOCATION",   
                                                       "PN_INVENTORY_DETAIL"."BIN",   
                                                       "PN_INVENTORY_DETAIL"."QTY_AVAILABLE",   
                                                       "PN_INVENTORY_DETAIL"."QTY_RESERVED",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_TRANSFER",   
                                                       "PN_INVENTORY_DETAIL"."QTY_PENDING_RI",   
                                                       "PN_INVENTORY_DETAIL"."QTY_US",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_REPAIR",   
                                                       "PN_INVENTORY_DETAIL"."RI_CONTROL",   
                                                       "PN_INVENTORY_DETAIL"."US_CODE",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION",   
                                                       "PN_INVENTORY_DETAIL"."LOAN_CATEGORY",   
                                                       "PN_INVENTORY_DETAIL"."CUTOM_DUTY_CODE",   
                                                       "PN_INVENTORY_DETAIL"."GL_COMPANY",   
                                                       "PN_INVENTORY_DETAIL"."GL_EXPENDITURE",   
                                                       "PN_INVENTORY_DETAIL"."GL",   
                                                       "PN_INVENTORY_DETAIL"."GL_COST_CENTER",   
                                                       "PN_INVENTORY_DETAIL"."NOTES",   
                                                       "PN_INVENTORY_DETAIL"."CREATED_BY",   
                                                       "PN_INVENTORY_DETAIL"."CREATED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."MODIFIED_BY",   
                                                       "PN_INVENTORY_DETAIL"."MODIFIED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_DATE",   
                                                       "PN_INVENTORY_DETAIL"."KIT_NO",   
                                                       "PN_INVENTORY_DETAIL"."CURRENCY_EXCHANGE_RATE",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_RENTAL",   
                                                       "PN_INVENTORY_DETAIL"."SECONDARY_COST",   
                                                       "PN_INVENTORY_DETAIL"."SECONDARY_CURRENCY_EXCHANGE",   
                                                       "PN_INVENTORY_DETAIL"."BLOB_NO",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_AC",   
                                                       "PN_INVENTORY_DETAIL"."MOD_STATUS",   
                                                       "PN_INVENTORY_DETAIL"."CUSTOM_DUTY_DOCUMENT",   
                                                       "PN_INVENTORY_DETAIL"."PENDING",   
                                                       "PN_INVENTORY_DETAIL"."PENDING_DATE",   
                                                       "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE_ORIGINAL",   
                                                       "PN_INVENTORY_DETAIL"."SOS_DATE",   
                                                       "PN_INVENTORY_DETAIL"."SOS_HOUR",   
                                                       "PN_INVENTORY_DETAIL"."SOS_MINUTE",   
                                                       "PN_INVENTORY_DETAIL"."TAG_BY",   
                                                       "PN_INVENTORY_DETAIL"."TAG_DATE",   
                                                       "PN_INVENTORY_DETAIL"."TAG_NO",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_RECORDS_BY",   
                                                       "PN_INVENTORY_DETAIL"."ORGINAL_RECORDS_DATE",   
                                                       "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT",   
                                                       "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT_DATE",   
                                                       "PN_INVENTORY_DETAIL"."PN_MODEL",   
                                                       "PN_INVENTORY_DETAIL"."PN_SOFTWARE",   
                                                       "PN_INVENTORY_DETAIL"."FILING_SEQUENCE",   
                                                       "PN_INVENTORY_DETAIL"."NO_OF_TAG_PRINT",   
                                                       "PN_INVENTORY_DETAIL"."OWNER_ORIGIN",   
                                                       "PN_INVENTORY_DETAIL"."NLA_POSITION",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_HOURS",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_MINUTES",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_CYCLES",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_DAYS",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION_LAST",   
                                                       "PN_INVENTORY_DETAIL"."INVENTORY_TYPE",   
                                                       "PN_INVENTORY_DETAIL"."DOCUMENT_NO",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION_LAST",   
                                                       "PN_INVENTORY_DETAIL"."SLOT",   
                                                       "PN_INVENTORY_DETAIL"."COST_IN_KIT",   
                                                       "PN_INVENTORY_DETAIL"."REPAIR_RETURN_DATE",   
                                                       "PN_INVENTORY_DETAIL"."HAZARDOUS_MATERIAL_AT_REMOVAL",   
                                                       "PN_INVENTORY_DETAIL"."WEIGHT",   
                                                       "PN_INVENTORY_DETAIL"."WEIGHT_UNIT",   
                                                       "PN_INVENTORY_DETAIL"."MANAGED_WO",   
                                                       "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_BY",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_AC_ISSUE_TO_ONLY",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXP_EOM",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXP_EOM",   
                                                       "PN_INVENTORY_DETAIL"."LEGACY_BATCH",   
                                                       "PN_INVENTORY_DETAIL"."ADJUSTMENT_CODE",   
                                                       DECODE("PN_INVENTORY_DETAIL"."OWNER", :1, 1, 2) as owner_sort  
                                                  FROM "PN_INVENTORY_DETAIL",   
                                                       "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_A",   
                                                       "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_B",   
                                                       "LOCATION_MASTER_ROUTINE"  
                                                 WHERE ( "PN_INTERCHANGEABLE_A"."PN" = "PN_INTERCHANGEABLE_B"."PN" ) and  
                                                       ( "PN_INTERCHANGEABLE_A"."PN_INTERCHANGEABLE" = "PN_INVENTORY_DETAIL"."PN" ) and  
                                                       ( "PN_INVENTORY_DETAIL"."LOCATION" = "LOCATION_MASTER_ROUTINE"."LOCATION_ROUTING" ) ';
  BEGIN
    --UE_POSTOPEN


     T_DW_SEL_DEFECT := WF_LOAD_picklist_parts (n_id, N_WO, S_AC) ;

    DT_TODAY := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;

    if ( T_DW_SEL_DEFECT is not null and T_DW_SEL_DEFECT.count > 0)  or  (T_DW_SEL_DEFECT is not null and T_DW_SEL_DEFECT.count > 0 )then

      begin
      
      IS_SITE := MS_LOCATION_SITE_REQ.S_SITE ;


      SELECT "WO"."LOCATION",
          "WO"."AC",  
          "WO"."SCHEDULE_START_DATE",
          "WO"."THIRD_PARTY_WO",
          "WO"."PRIORITY",
          "WO"."SITE",
          "WO"."MODULE",
          "WO"."GL_COMPANY"  
      INTO is_location,   
          is_ac,
          idt_schedule_start_date,
          is_tpw,
          is_priority,
          is_site, 
          is_module,
          is_company
      FROM "WO"  
      WHERE "WO"."WO" = n_wo;


        SELECT trim("RELATION_MASTER"."EMPLOYEE_CONTRACTOR")
        INTO ms_pn.s_owner  
        FROM "CUSTOMER_ORDER_HEADER",   
            "RELATION_MASTER"  
        WHERE ( "CUSTOMER_ORDER_HEADER"."CUSTOMER" = "RELATION_MASTER"."RELATION_CODE" ) and  
          ( ( "CUSTOMER_ORDER_HEADER"."ORDER_TYPE" = 'W/O' ) AND  
          ( "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER" = N_WO ) );
      EXCEPTION
      WHEN OTHERS THEN
        ms_pn.s_owner := null;
        IS_AC := s_AC;
      end;

      S_SV_TASK_CARD := ' ';


      --done for task control nelson
      --location
      if MS_LOCATION_SITE.S_LOCATION is null then
        MS_LOCATION_SITE.S_LOCATION := IS_LOCATION;
      else
        IS_LOCATION :=  MS_LOCATION_SITE.S_LOCATION ;
      end if; 

      --site
      if MS_LOCATION_SITE.S_SITE is null then       
        MS_LOCATION_SITE.S_SITE := IS_SITE;
      else
        IS_SITE := IS_SITE ; 
      end if; 





      --priority
       if  Ms_Location_Site.S_Priority is not null then
        is_priority := Ms_Location_Site.S_Priority ;
      end if ; 

      --end done for task control nelson

      MS_LOCATION_SITE.S_TRANSACTION := 'PICKLIST';
      MS_LOCATION_SITE.S_MODULE := IS_MODULE;
      MS_LOCATION_SITE.L_WO := n_WO;  


      s_location := ms_location_site.s_location;

      if trim(s_location) is not null Then

        IS_COMPANYMULTIREQ := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('COMPANYMULTIREQ');
        IDT_REQUIRE_DATE := MS_LOCATION_SITE.DT_REQUIRE_DATE;
        IL_REQUIRE_HOUR := MS_LOCATION_SITE.L_HOUR;
        IL_REQUIRE_MINUTE := MS_LOCATION_SITE.L_MINUTE;
        IS_DELIVERY_LOCATION := MS_LOCATION_SITE.S_DELIVERY_LOCATION;
        IS_SHORTAGE_PRINT_ONLY := MS_LOCATION_SITE.S_SHORTAGE_PRINT_ONLY;

        IF TRIM(S_LOCATION) IS NOT NULL THEN IS_LOCATION := S_LOCATION; END IF;
        IF TRIM(IS_DELIVERY_LOCATION) IS NULL THEN IS_DELIVERY_LOCATION := IS_LOCATION; END IF;
        IF TRIM(MS_LOCATION_SITE.S_SITE) IS NOT NULL THEN IS_SITE := MS_LOCATION_SITE.S_SITE; END IF;
        IF IDT_SCHEDULE_START_DATE < DT_TODAY THEN IDT_SCHEDULE_START_DATE := DT_TODAY; END IF;
        If trim(idt_require_date) is not null Then idt_schedule_start_date := idt_require_date; end if;

        IS_WOPURSVRQ := 'N';
        IS_BOCRT := 'N';
        IS_SHORTAGE_PRINT_ONLY := 'N';

        IF IS_WOPURSVRQ = 'Y' AND IS_BOCRT = 'Y' AND IS_SHORTAGE_PRINT_ONLY = 'N' THEN
          ms_location_site_req.s_location := is_location;
          MS_LOCATION_SITE_REQ.S_SITE := IS_SITE;
          ms_location_site_req.s_transaction := 'REQUISITION/PK';
          MS_LOCATION_SITE_REQ.S_MODULE := IS_MODULE;
          MS_LOCATION_SITE_REQ.L_WO := n_WO;
          IF trim(MS_LOCATION_SITE_REQ.S_LOCATION) is null THEN 
            RETURN 0;
          End If;
          IS_PRIORITY_REQ := MS_LOCATION_SITE_REQ.S_PRIORITY;
          IS_REQUISITION_TYPE := MS_LOCATION_SITE_REQ.S_TYPE;
          IDT_REQUIRE_DATE_REQ := MS_LOCATION_SITE_REQ.DT_REQUIRE_DATE;
          IL_REQUIRE_HOUR_REQ := MS_LOCATION_SITE_REQ.L_HOUR;
          IL_REQUIRE_MINUTE_REQ := MS_LOCATION_SITE_REQ.L_MINUTE;
        End If;


       if (T_DW_SEL_DEFECT is not null and T_DW_SEL_DEFECT.count > 0 )then

        FOR I_CROW IN 1..T_DW_SEL_DEFECT.COUNT
        LOOP
          DECLARE
            D_QTY_RESERVED NUMBER;
            D_QTY NUMBER;
            D_REQUISITION NUMBER;
            IS_PN VARCHAR2(100);
            ID_QTY NUMBER;
            S_ETOPS_ACTION VARCHAR2(100);
            D_REQUISITION_ORDER NUMBER;
            D_ORDER_RESERVER NUMBER;
            I_RETURN NUMBER;
            II_NONEFFECTIVE NUMBER;
            DW_PN_INVENTORY_AVL_QTY NUMBER;
            DW_PN_INVENTORY_AVL_QTY1 NUMBER;
            DW_PN_INVENTORY_AVL_QTY2 NUMBER;
            IS_ERRFLD VARCHAR2(100);
            IS_ETOPS_ACTION VARCHAR2(100);
            IS_PN_DESCRIPTION VARCHAR2(32000);
            t_dw_eu PKG_TYPE_STRUCTURES.tt_picklist_distribution := PKG_TYPE_STRUCTURES.tt_picklist_distribution();
            n_batch VARCHAR2(100);
             s_sn varchar2(35 CHAR);
          begin
            IS_DEFECT := T_DW_SEL_DEFECT(I_CROW).s_defect;
            IF S_WOPICK1 = 'N' THEN IS_TASK_CARD_HEADER := IS_TASK_CARD; END IF;
            IS_DEFECT_TYPE := T_DW_SEL_DEFECT(I_CROW).S_defect_type;
            IL_defect_item := T_DW_SEL_DEFECT(I_CROW).l_defect_item;
            IS_AC_TC := T_DW_SEL_DEFECT(I_CROW).S_AC;
            T_DW_SEL_DEFECT(I_CROW).s_picklist_processed := 'N';




            S_NEW := 'NEW';
            S_SV_TASK_CARD := IS_TASK_CARD;
            DW_EU.picklist := IL_PICKLIST;

            IS_PN := T_DW_SEL_DEFECT(I_CROW).S_PN;
            ID_QTY := T_DW_SEL_DEFECT(I_CROW).N_QTY;
            D_QTY_RESERVED := T_DW_SEL_DEFECT(I_CROW).n_qty_reserved;

            IF PKG_APPLICATION_FUNCTION.CONFIG_FLAG('ETOPS') = 'N' THEN S_ETOPS_ACTION := GF_ETOPS_VALIDATION(IL_WO, IS_PN); END IF;

            if nvl(s_etops_action,'5') <> '1' and nvl(s_etops_action,'5') <> '2' then
              IF NVL(S_ETOPS_ACTION,'5') = '3' OR NVL(S_ETOPS_ACTION,'5') = '4' THEN 
                IS_PN := DF_GET_INTERCHANGE_EFFECTIVE(IS_PN, IS_AC, IL_WO);
                MS_PN.S_ORDER_TYPE := 'S/O';
              END IF	;

              IF trim(D_QTY_RESERVED) is null THEN 	D_QTY_RESERVED := 0; end if;

              D_REQUISITION := 0;


              d_requisition := null;


              If trim(d_requisition) is null Then d_requisition := 0; end if;

              d_requisition_order := 0;


              D_ORDER_RESERVER := 0;


              id_qty := id_qty - (d_qty_reserved + d_requisition + d_requisition_order + d_order_reserver);

              IF ID_QTY > 0 THEN

                s_sn  := T_DW_SEL_DEFECT(I_CROW).s_defect;
                n_batch := T_DW_SEL_DEFECT(I_CROW).l_defect_item;

                DW_EU := WF_NEW(IS_TRAN, IL_PICKLIST, IS_PN, IS_TASK_CARD, ID_QTY, GS_USER, n_batch, s_sn);
                I_RETURN :=0;
                ii_nonEffective := 1;

                i_return :=  WF_EDIT(DW_EU, DW_PN_INVENTORY_AVL, DW_PN_INVENTORY_AVL_QTY,
                                     dw_pn_inventory_avl_qty1, dw_pn_inventory_avl_qty2, is_errfld, IS_TPW,
                                     IS_AC, IL_WO, IS_LOCATION, IS_ETOPS_ACTION,
                                     IS_ORIGINAL, GS_COMPANY_MULTI, IS_BOCRT, IS_SHORTAGE_PRINT_ONLY,
                                     IL_REQUISITION, IS_PN, IS_PRIORITY_REQ,
                                     IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ,
                                     IS_COMPANY, IS_TASK_CARD, GS_USER, IS_EC,
                                     IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, NULL , NULL , NULL ,
                                     IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                     IL_REQUIRE_HOUR_REQ, il_require_minute_req);

                ms_location_site.s_shortage_print_only := 'N';                     
                if ms_location_site.s_shortage_print_only = 'N' then

                  begin
                    SELECT "PN_MASTER"."PN_DESCRIPTION"   
                    INTO is_pn_description   
                    FROM "PN_MASTER",   
                        "PN_INTERCHANGEABLE"  
                    WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) AND  
                        ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = is_pn ) );
                  EXCEPTION
                  WHEN OTHERS THEN 
                    is_pn_description := null;
                  END;

                  If i_return = 0 then
                    If s_new = 'NEW' Then
                    S_WOPICK1:='N';
                      IF S_WOPICK1 = 'N' OR ( S_WOPICK1 = 'Y' AND IL_PICKLIST = 0 )   THEN
                        S_NULL := NULL;
                        L_NULL := NULL;
                        WF_NEW_PICKLIST_HEADER(IL_PICKLIST, IS_LOCATION, IL_WO, IS_TASK_CARD_HEADER,
                                               IDT_SCHEDULE_START_DATE, IL_REQUIRE_HOUR, IL_REQUIRE_MINUTE,
                                               IS_DELIVERY_LOCATION, IS_PRIORITY, IS_SITE, IS_TASK_CARD_PN,
                                               is_task_card_pn_sn, S_NULL , S_NULL, L_NULL, is_ac, gs_user);
                      End If;

                      S_NEW := ' ';
                      DW_EU.picklist := IL_PICKLIST;

                    End If;

                    IF IS_WOPKLNLA = 'Y' AND NVL(DW_PN_INVENTORY_AVL(1).PN,' ') <> ' ' THEN
                      DECLARE
                        B_INCOMPLETE BOOLEAN;
                        L_BATCH NUMBER;
                        l_trow NUMBER;
                        l_row NUMBER;
                        L_SAVED_CROW NUMBER;
                        D_PICKLIST_QTY NUMBER;
                        B_CONTINUE BOOLEAN := FALSE;
                      BEGIN
                        D_PICKLIST_QTY := 0;
                        L_SAVED_CROW := 0;
                        l_trow := dw_eu.qty; 

                        FOR L_CROW IN 1..L_TROW
                        loop

                          B_CONTINUE := FALSE;

                          IF L_CROW > 1 THEN
                            DW_EU.BATCH := 0;
                            I_RETURN := WF_EDIT(DW_EU, DW_PN_INVENTORY_AVL, DW_PN_INVENTORY_AVL_QTY,
                                               dw_pn_inventory_avl_qty1, dw_pn_inventory_avl_qty2, is_errfld, IS_TPW,
                                               IS_AC, IL_WO, IS_LOCATION, IS_ETOPS_ACTION,
                                               IS_ORIGINAL, GS_COMPANY_MULTI, IS_BOCRT, IS_SHORTAGE_PRINT_ONLY,
                                               IL_REQUISITION, IS_PN, IS_PRIORITY_REQ,
                                               IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ,
                                               IS_COMPANY, IS_TASK_CARD, GS_USER, IS_EC,
                                               IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, null , null , null,
                                               IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                               IL_REQUIRE_HOUR_REQ, il_require_minute_req);
                            IF I_RETURN = 1 THEN B_CONTINUE := TRUE; END IF;
                          END IF;

                          IF NOT B_CONTINUE THEN

                            L_BATCH := 0;
                            b_incomplete := WF_CHECK_INCOMPLETE(l_batch, dw_pn_inventory_avl, MS_PN);
                            DW_EU.BATCH := L_BATCH;

                            --log 150548 modified
                            BEGIN
                              SELECT "PROFILE"
                              INTO PROFILE_NAME 
                              from PROFILE_MASTER;
                            EXCEPTION
                            WHEN OTHERS THEN
                              PROFILE_NAME := NULL;
                            END;

                            IF(PROFILE_NAME = 'SWA')
                            then
                              null;
                            else
                              dw_eu.qty := 1;
                            END IF;
                            --log 150548 modified

                            IF B_INCOMPLETE  THEN
                              IF (NVL(T_DW_SEL_DEFECT(I_CROW).S_RESERVE, 'YES') <> 'DELETE') AND (I_CROW <> L_SAVED_CROW) THEN
                                IF IMESSAGEBOXINCOMPLETE = 1 THEN
  --                                wf_load_missing_nla(l_batch) --TODO
                                 L_SAVED_CROW := I_CROW;
                                End If;
                              ELSE
  --                              wf_load_missing_nla(l_batch) --TODO
                                NULL;
                              END IF;
                            End If;

                            --log 150548 modified
                            IF(PROFILE_NAME = 'SWA')
                            then
                              D_QTY := 1;	
                            else
                              D_QTY := DW_EU.QTY;
                            end if;
                            --log 150548 modified

                            D_QTY_RESERVED := T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED;
                            D_QTY_RESERVED := nvl(D_QTY_RESERVED,0) + nvl( D_QTY , 0 );
                            T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED := D_QTY_RESERVED;
                            T_DW_SEL_DEFECT(I_CROW).DT_MODIFIED_DATE := DT_TODAY;
                            T_DW_SEL_DEFECT(I_CROW).S_PICKLIST_PROCESSED := 'Y'; 
                            MS_PN.S_LOCATION := IS_LOCATION;
                            MS_PN.S_TASK_CARD  := IS_TASK_CARD;

                            IF IS_BOCRT = 'N' THEN MS_PN.s_transaction_type := 'NOREQUISITION'; END IF;
                            MS_PN.N_PICKLIST := IL_PICKLIST;
                            t_dw_eu := OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);
                            D_PICKLIST_QTY := D_PICKLIST_QTY + 1;

                          END IF;
                        end loop;

                   -- Log159804
                      for L_CROW in T_DW_EU.first..T_DW_EU.last
                        LOOP
                        T_DW_EU(L_CROW).QTY := D_PICKLIST_QTY;
                        end loop;
                   -- 159804

                        DW_EU.BATCH := 0;

                        DW_EU.QTY := D_PICKLIST_QTY;

                      END;
                    Else	

                      D_QTY := DW_EU.QTY;
                      D_QTY_RESERVED := nvl(D_QTY_RESERVED , 0)  + nvl(D_QTY , 0 );
                      T_DW_SEL_DEFECT(I_CROW).N_QTY_RESERVED := D_QTY_RESERVED;
                      T_DW_SEL_DEFECT(I_CROW).DT_MODIFIED_DATE := DT_TODAY;
                      T_DW_SEL_DEFECT(I_CROW).S_PICKLIST_PROCESSED := 'Y';  
                      MS_PN.S_LOCATION := IS_LOCATION;
                      MS_PN.S_TASK_CARD  := IS_TASK_CARD;
                      IF IS_BOCRT = 'N' THEN MS_PN.s_transaction_type := 'NOREQUISITION'; END IF;
                      MS_PN.N_PICKLIST := IL_PICKLIST;
                      -- <ADDED for eMobility>
                      MS_PN.N_BATCH := T_DW_SEL_DEFECT(I_CROW).L_DEFECT_ITEM;
                      MS_PN.S_SN :=  T_DW_SEL_DEFECT(I_CROW).S_DEFECT;

                      t_dw_eu := OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);

                    END IF;

                    GF_SAVE_TT_PICKLIST_DISTRIB(t_dw_eu);

                    DECLARE
                      L_PICKLIST_LINE NUMBER := DW_EU.PICKLIST_LINE;
                    BEGIN
                      PICKLIST_DISTRIBUTION_AUDIT(IL_PICKLIST, L_PICKLIST_LINE, 'NEW', GS_USER);
                      IS_TRAN := ' ';
                    end;
                  End If;
                END IF;
              End If;
            end if;
          end;
        end loop;
        end if ;

        if ms_location_site.s_shortage_print_only = 'N' then
          IF IS_WOPKLNLA = 'Y' THEN
            DECLARE
              S_DELETE varchar2(100);
            BEGIN

              IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
                FOR I_CROW in reverse t_dw_sel.first..t_dw_sel.last
                LOOP
                  s_delete := nvl(t_dw_sel(i_crow).S_reserve, 'YES');
                  IF ( S_DELETE = 'DELETE' ) OR ( S_DELETE = 'MAIN' ) THEN
                    T_DW_SEL(I_CROW) := NULL;
                  End If;
                END LOOP;
              end if;


               IF T_DW_SEL_DEFECT IS NOT NULL AND T_DW_SEL_DEFECT.COUNT > 0 THEN
                FOR I_CROW in reverse T_DW_SEL_DEFECT.first..T_DW_SEL_DEFECT.last
                LOOP
                  s_delete := nvl(T_DW_SEL_DEFECT(i_crow).S_reserve, 'YES');
                  IF ( S_DELETE = 'DELETE' ) OR ( S_DELETE = 'MAIN' ) THEN
                    T_DW_SEL_DEFECT(I_CROW) := NULL;
                  End If;
                END LOOP;
              end if;


            end;
          End If;

          --print picklist to report server for picklist use
          sendPicklistToPrintQueue(IL_PICKLIST) ;

          --send notification , TODO


        return IL_PICKLIST;


        end if;

      end if;
    end if;

  END eMobility_Picklist_ac;

  Function W_WO_RESERV_EU_SUB_WO_LOOP(N_WO NUMBER, S_AC VARCHAR2, MS_LOCATION_SITE IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                       MS_LOCATION_SITE_REQ IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                       S_TASK_CARD VARCHAR2 DEFAULT NULL,S_TASK_CARD_PN VARCHAR2 DEFAULT NULL , S_TASK_CARD_SN VARCHAR2 DEFAULT NULL , 
                                       s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0, 
                                       GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER) return number
  AS
    s_customer varchar2(100) := '';
    GS_STATUS VARCHAR2(100) := ' ';
    idt_today date := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    S_WOPICK1 VARCHAR2(100) := 'N' ; --PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPICK1');
    MS_PN PKG_TYPE_STRUCTURES.ST_PN;
    IL_WO NUMBER := N_WO;
    IS_BOCRT VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('BOCRT');
    IS_WOPURSVRQ VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPURSVRQ');
    IS_WOPKLNLA VARCHAR2(100) := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPKLNLA');
    is_COMPANYMULTIREQ varchar2(100);
    I_CROW NUMBER := 0;
    I_AROW NUMBER := 0;
    DT_SCHEDULE_START_DATE DATE;
    DT_TODAY DATE;
    S_SV_TASK_CARD VARCHAR2(100);
    IL_PICKLIST NUMBER := 0 ;

    T_DW_SEL WO_TC_PN_ARRAY;
    T_DW_SEL_DEFECT DEFECT_PN_ARRAY;

    is_location VARCHAR2(100);
    is_ac VARCHAR2(100);
    idt_schedule_start_date date;
    is_tpw VARCHAR2(100);
    is_priority VARCHAR2(100);
    is_site VARCHAR2(100);
    is_module VARCHAR2(100);
    IS_COMPANY VARCHAR2(100);
    S_LOCATION VARCHAR2(100);
    IDT_REQUIRE_DATE DATE;
    IL_REQUIRE_HOUR number;
    IL_REQUIRE_MINUTE number;
    IS_DELIVERY_LOCATION VARCHAR2(100);
    IS_SHORTAGE_PRINT_ONLY VARCHAR2(100);
    IS_PRIORITY_REQ VARCHAR2(100);
    IS_REQUISITION_TYPE VARCHAR2(100);
    IDT_REQUIRE_DATE_REQ DATE;
    IL_REQUIRE_HOUR_REQ NUMBER;
    IL_REQUIRE_MINUTE_REQ NUMBER;
    DW_EU PICKLIST_DISTRIBUTION%ROWTYPE;
    DW_PICKLIST_DETAIL PICKLIST_DISTRIBUTION%ROWTYPE;
    dw_pn_inventory_avl PKG_TYPE_STRUCTURES.dw_INVENTORY_TRAN_AVL;
    IS_TASK_CARD VARCHAR2(100);
    IS_TASK_CARD_HEADER VARCHAR2(100);
    IS_TASK_CARD_PN VARCHAR2(100);
    IS_TASK_CARD_PN_SN VARCHAR2(100);


    IS_DEFECT "DEFECT_REPORT"."DEFECT"%type;
    IS_DEFECT_TYPE "DEFECT_REPORT"."DEFECT_TYPE"%type;
    IL_DEFECT_ITEM "DEFECT_REPORT"."DEFECT_ITEM"%type;

    IS_AC_TC VARCHAR2(100);
    IS_EC VARCHAR2(100);
    S_NEW VARCHAR2(100);
    IS_TRAN VARCHAR2(100);
    IL_REQUISITION NUMBER;
    profile_name varchar2(200);
    is_original varchar2(32000) := ' SELECT DISTINCT "LOCATION_MASTER_ROUTINE"."MASTER_LOCATION_SEQUENCE",   
                                                       "LOCATION_MASTER_ROUTINE"."MASTER_LOCATION",   
                                                       NVL("PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION", sysdate + 200000) as dt_shelf_life_computed,   
                                                       "PN_INVENTORY_DETAIL"."BATCH",   
                                                       "PN_INVENTORY_DETAIL"."GOODS_RCVD_BATCH",   
                                                       "PN_INVENTORY_DETAIL"."VENDOR_LOT",   
                                                       "PN_INVENTORY_DETAIL"."PN",   
                                                       "PN_INVENTORY_DETAIL"."SN",   
                                                       "PN_INVENTORY_DETAIL"."NHA_PN",   
                                                       "PN_INVENTORY_DETAIL"."NHA_SN",   
                                                       "PN_INVENTORY_DETAIL"."CONDITION",   
                                                       "PN_INVENTORY_DETAIL"."OWNER",   
                                                       "PN_INVENTORY_DETAIL"."UNIT_COST",   
                                                       "PN_INVENTORY_DETAIL"."CURRENCY",   
                                                       "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE",   
                                                       "PN_INVENTORY_DETAIL"."RI_BY",   
                                                       "PN_INVENTORY_DETAIL"."RI_DATE",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_AC",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_POSITION",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_HOUR",   
                                                       "PN_INVENTORY_DETAIL"."INSTALLED_MINUTE",   
                                                       "PN_INVENTORY_DETAIL"."LOCATION",   
                                                       "PN_INVENTORY_DETAIL"."BIN",   
                                                       "PN_INVENTORY_DETAIL"."QTY_AVAILABLE",   
                                                       "PN_INVENTORY_DETAIL"."QTY_RESERVED",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_TRANSFER",   
                                                       "PN_INVENTORY_DETAIL"."QTY_PENDING_RI",   
                                                       "PN_INVENTORY_DETAIL"."QTY_US",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_REPAIR",   
                                                       "PN_INVENTORY_DETAIL"."RI_CONTROL",   
                                                       "PN_INVENTORY_DETAIL"."US_CODE",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION",   
                                                       "PN_INVENTORY_DETAIL"."LOAN_CATEGORY",   
                                                       "PN_INVENTORY_DETAIL"."CUTOM_DUTY_CODE",   
                                                       "PN_INVENTORY_DETAIL"."GL_COMPANY",   
                                                       "PN_INVENTORY_DETAIL"."GL_EXPENDITURE",   
                                                       "PN_INVENTORY_DETAIL"."GL",   
                                                       "PN_INVENTORY_DETAIL"."GL_COST_CENTER",   
                                                       "PN_INVENTORY_DETAIL"."NOTES",   
                                                       "PN_INVENTORY_DETAIL"."CREATED_BY",   
                                                       "PN_INVENTORY_DETAIL"."CREATED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."MODIFIED_BY",   
                                                       "PN_INVENTORY_DETAIL"."MODIFIED_DATE",   
                                                       "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_DATE",   
                                                       "PN_INVENTORY_DETAIL"."KIT_NO",   
                                                       "PN_INVENTORY_DETAIL"."CURRENCY_EXCHANGE_RATE",   
                                                       "PN_INVENTORY_DETAIL"."QTY_IN_RENTAL",   
                                                       "PN_INVENTORY_DETAIL"."SECONDARY_COST",   
                                                       "PN_INVENTORY_DETAIL"."SECONDARY_CURRENCY_EXCHANGE",   
                                                       "PN_INVENTORY_DETAIL"."BLOB_NO",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_AC",   
                                                       "PN_INVENTORY_DETAIL"."MOD_STATUS",   
                                                       "PN_INVENTORY_DETAIL"."CUSTOM_DUTY_DOCUMENT",   
                                                       "PN_INVENTORY_DETAIL"."PENDING",   
                                                       "PN_INVENTORY_DETAIL"."PENDING_DATE",   
                                                       "PN_INVENTORY_DETAIL"."APPROVED_CERTIFICATE_ORIGINAL",   
                                                       "PN_INVENTORY_DETAIL"."SOS_DATE",   
                                                       "PN_INVENTORY_DETAIL"."SOS_HOUR",   
                                                       "PN_INVENTORY_DETAIL"."SOS_MINUTE",   
                                                       "PN_INVENTORY_DETAIL"."TAG_BY",   
                                                       "PN_INVENTORY_DETAIL"."TAG_DATE",   
                                                       "PN_INVENTORY_DETAIL"."TAG_NO",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_RECORDS_BY",   
                                                       "PN_INVENTORY_DETAIL"."ORGINAL_RECORDS_DATE",   
                                                       "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT",   
                                                       "PN_INVENTORY_DETAIL"."ACCOUNTING_DOCUMENT_DATE",   
                                                       "PN_INVENTORY_DETAIL"."PN_MODEL",   
                                                       "PN_INVENTORY_DETAIL"."PN_SOFTWARE",   
                                                       "PN_INVENTORY_DETAIL"."FILING_SEQUENCE",   
                                                       "PN_INVENTORY_DETAIL"."NO_OF_TAG_PRINT",   
                                                       "PN_INVENTORY_DETAIL"."OWNER_ORIGIN",   
                                                       "PN_INVENTORY_DETAIL"."NLA_POSITION",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_HOURS",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_MINUTES",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_CYCLES",   
                                                       "PN_INVENTORY_DETAIL"."INITIAL_TSI_DAYS",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXPIRATION_LAST",   
                                                       "PN_INVENTORY_DETAIL"."INVENTORY_TYPE",   
                                                       "PN_INVENTORY_DETAIL"."DOCUMENT_NO",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXPIRATION_LAST",   
                                                       "PN_INVENTORY_DETAIL"."SLOT",   
                                                       "PN_INVENTORY_DETAIL"."COST_IN_KIT",   
                                                       "PN_INVENTORY_DETAIL"."REPAIR_RETURN_DATE",   
                                                       "PN_INVENTORY_DETAIL"."HAZARDOUS_MATERIAL_AT_REMOVAL",   
                                                       "PN_INVENTORY_DETAIL"."WEIGHT",   
                                                       "PN_INVENTORY_DETAIL"."WEIGHT_UNIT",   
                                                       "PN_INVENTORY_DETAIL"."MANAGED_WO",   
                                                       "PN_INVENTORY_DETAIL"."PHYSICAL_COUNT_BY",   
                                                       "PN_INVENTORY_DETAIL"."ORIGINAL_AC_ISSUE_TO_ONLY",   
                                                       "PN_INVENTORY_DETAIL"."SHELF_LIFE_EXP_EOM",   
                                                       "PN_INVENTORY_DETAIL"."TOOL_LIFE_EXP_EOM",   
                                                       "PN_INVENTORY_DETAIL"."LEGACY_BATCH",   
                                                       "PN_INVENTORY_DETAIL"."ADJUSTMENT_CODE",   
                                                       DECODE("PN_INVENTORY_DETAIL"."OWNER", :1, 1, 2) as owner_sort  
                                                  FROM "PN_INVENTORY_DETAIL",   
                                                       "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_A",   
                                                       "PN_INTERCHANGEABLE" "PN_INTERCHANGEABLE_B",   
                                                       "LOCATION_MASTER_ROUTINE"  
                                                 WHERE ( "PN_INTERCHANGEABLE_A"."PN" = "PN_INTERCHANGEABLE_B"."PN" ) and  
                                                       ( "PN_INTERCHANGEABLE_A"."PN_INTERCHANGEABLE" = "PN_INVENTORY_DETAIL"."PN" ) and  
                                                       ( "PN_INVENTORY_DETAIL"."LOCATION" = "LOCATION_MASTER_ROUTINE"."LOCATION_ROUTING" ) ';
  BEGIN
    --UE_POSTOPEN


     T_DW_SEL := WF_LOAD_PN_FOR_RESERVE(N_WO, S_AC, TRIM(S_TASK_CARD) , s_task_card_pn , s_task_card_sn);
    P_USER := GS_USER;
    DT_TODAY := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    plog.debug('tdwsel.count' || T_DW_SEL.COUNT);
    if ( T_DW_SEL is not null and T_DW_SEL.count > 0)  or  (T_DW_SEL_DEFECT is not null and T_DW_SEL_DEFECT.count > 0 )then

      begin





      SELECT "WO"."LOCATION",
          "WO"."AC",  
          "WO"."SCHEDULE_START_DATE",
          "WO"."THIRD_PARTY_WO",
          "WO"."PRIORITY",
          "WO"."SITE",
          "WO"."MODULE",
          "WO"."GL_COMPANY"  
      INTO is_location,   
          is_ac,
          idt_schedule_start_date,
          is_tpw,
          is_priority,
          is_site, 
          is_module,
          is_company
      FROM "WO"  
      WHERE "WO"."WO" = n_wo;


        SELECT trim("RELATION_MASTER"."EMPLOYEE_CONTRACTOR")
        INTO ms_pn.s_owner  
        FROM "CUSTOMER_ORDER_HEADER",   
            "RELATION_MASTER"  
        WHERE ( "CUSTOMER_ORDER_HEADER"."CUSTOMER" = "RELATION_MASTER"."RELATION_CODE" ) and  
          ( ( "CUSTOMER_ORDER_HEADER"."ORDER_TYPE" = 'W/O' ) AND  
          ( "CUSTOMER_ORDER_HEADER"."ORDER_NUMBER" = N_WO ) );
      EXCEPTION
      WHEN OTHERS THEN
        ms_pn.s_owner := null;
      end;

      S_SV_TASK_CARD := ' ';


      --done for task control nelson
      --location
      if MS_LOCATION_SITE.S_LOCATION is null then
        MS_LOCATION_SITE.S_LOCATION := IS_LOCATION;
      else
        IS_LOCATION :=  MS_LOCATION_SITE.S_LOCATION ;
      end if; 

      --site
      if MS_LOCATION_SITE.S_SITE is null then       
        MS_LOCATION_SITE.S_SITE := IS_SITE;
      else
        IS_SITE := IS_SITE ; 
      end if; 





      --priority
       if  Ms_Location_Site.S_Priority is not null then
        is_priority := Ms_Location_Site.S_Priority ;
      end if ; 

      --end done for task control nelson

      MS_LOCATION_SITE.S_TRANSACTION := 'PICKLIST';
      MS_LOCATION_SITE.S_MODULE := IS_MODULE;
      MS_LOCATION_SITE.L_WO := n_WO;  



      s_location := ms_location_site.s_location;

      if trim(s_location) is not null Then

        IS_COMPANYMULTIREQ := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('COMPANYMULTIREQ');
        IDT_REQUIRE_DATE := MS_LOCATION_SITE.DT_REQUIRE_DATE;
        IL_REQUIRE_HOUR := MS_LOCATION_SITE.L_HOUR;
        IL_REQUIRE_MINUTE := MS_LOCATION_SITE.L_MINUTE;
        IS_DELIVERY_LOCATION := MS_LOCATION_SITE.S_DELIVERY_LOCATION;
        IS_SHORTAGE_PRINT_ONLY := MS_LOCATION_SITE.S_SHORTAGE_PRINT_ONLY;

        IF TRIM(S_LOCATION) IS NOT NULL THEN IS_LOCATION := S_LOCATION; END IF;
        IF TRIM(IS_DELIVERY_LOCATION) IS NULL THEN IS_DELIVERY_LOCATION := IS_LOCATION; END IF;
        IF TRIM(MS_LOCATION_SITE.S_SITE) IS NOT NULL THEN IS_SITE := MS_LOCATION_SITE.S_SITE; END IF;
        IF IDT_SCHEDULE_START_DATE < DT_TODAY THEN IDT_SCHEDULE_START_DATE := DT_TODAY; END IF;
        If trim(idt_require_date) is not null Then idt_schedule_start_date := idt_require_date; end if;

        IS_WOPURSVRQ := 'Y';
        IS_BOCRT := 'Y';
        IS_SHORTAGE_PRINT_ONLY := 'N';

        IF IS_WOPURSVRQ = 'Y' AND IS_BOCRT = 'Y' AND IS_SHORTAGE_PRINT_ONLY = 'N' THEN
          ms_location_site_req.s_location := is_location;
          MS_LOCATION_SITE_REQ.S_SITE := IS_SITE;
          ms_location_site_req.s_transaction := 'REQUISITION/PK';
          MS_LOCATION_SITE_REQ.S_MODULE := IS_MODULE;
          MS_LOCATION_SITE_REQ.L_WO := n_WO;
          IF trim(MS_LOCATION_SITE_REQ.S_LOCATION) is null THEN 
            RETURN 0;
          End If;
          IS_PRIORITY_REQ := MS_LOCATION_SITE_REQ.S_PRIORITY;
          IS_REQUISITION_TYPE := MS_LOCATION_SITE_REQ.S_TYPE;
          IDT_REQUIRE_DATE_REQ := MS_LOCATION_SITE_REQ.DT_REQUIRE_DATE;
          IL_REQUIRE_HOUR_REQ := MS_LOCATION_SITE_REQ.L_HOUR;
          IL_REQUIRE_MINUTE_REQ := MS_LOCATION_SITE_REQ.L_MINUTE;
        End If;


    if ( T_DW_SEL is not null and T_DW_SEL.count > 0) then

        FOR I_CROW IN T_DW_SEL.FIRST..T_DW_SEL.LAST
        LOOP
          DECLARE
            D_QTY_RESERVED NUMBER;
            D_QTY NUMBER;
            D_REQUISITION NUMBER;
            IS_PN VARCHAR2(100);
            ID_QTY NUMBER;
            S_ETOPS_ACTION VARCHAR2(100);
            D_REQUISITION_ORDER NUMBER;
            D_ORDER_RESERVER NUMBER;
            I_RETURN NUMBER;
            II_NONEFFECTIVE NUMBER;
            DW_PN_INVENTORY_AVL_QTY NUMBER;
            DW_PN_INVENTORY_AVL_QTY1 NUMBER;
            DW_PN_INVENTORY_AVL_QTY2 NUMBER;
            IS_ERRFLD VARCHAR2(100);
            IS_ETOPS_ACTION VARCHAR2(100);
            IS_PN_DESCRIPTION VARCHAR2(32000);
            t_dw_eu PKG_TYPE_STRUCTURES.tt_picklist_distribution := PKG_TYPE_STRUCTURES.tt_picklist_distribution();
            n_batch VARCHAR2(100);
            s_sn NUMBER;
          begin
            IS_TASK_CARD := T_DW_SEL(I_CROW).s_TASK_CARD;
            IF S_WOPICK1 = 'N' THEN IS_TASK_CARD_HEADER := IS_TASK_CARD; END IF;
            IS_TASK_CARD_PN := T_DW_SEL(I_CROW).S_TASK_CARD_PN;
            IS_TASK_CARD_PN_SN := T_DW_SEL(I_CROW).S_TASK_CARD_PN_SN;
            IS_AC_TC := T_DW_SEL(I_CROW).S_AC;
            T_DW_SEL(I_CROW).s_picklist_processed := 'N';

            begin
              SELECT "WO_TASK_CARD"."EO"  
              INTO is_ec  
              FROM "WO_TASK_CARD"  
              WHERE ( "WO_TASK_CARD"."WO" = il_wo ) AND  
                  ( "WO_TASK_CARD"."TASK_CARD" = is_task_card ) AND  
                  ( "WO_TASK_CARD"."AC" = is_ac_tc ) AND  
                  ( "WO_TASK_CARD"."PN" = is_task_card_pn ) AND  
                  ( "WO_TASK_CARD"."PN_SN" = IS_TASK_CARD_PN_SN );
            exception
            WHEN OTHERS THEN
              is_ec := null;
            end;

            IF NVL(IS_TASK_CARD,' ') <> NVL(S_SV_TASK_CARD,' ') THEN
              S_NEW := 'NEW';
              S_SV_TASK_CARD := IS_TASK_CARD;
              DW_EU.picklist := IL_PICKLIST;
            End If;


            IS_PN := T_DW_SEL(I_CROW).S_PN;
            ID_QTY := T_DW_SEL(I_CROW).N_QTY;
            D_QTY_RESERVED := T_DW_SEL(I_CROW).n_qty_reserved;

            IF PKG_APPLICATION_FUNCTION.CONFIG_FLAG('ETOPS') = 'N' THEN S_ETOPS_ACTION := GF_ETOPS_VALIDATION(IL_WO, IS_PN); END IF;

            if nvl(s_etops_action,'5') <> '1' and nvl(s_etops_action,'5') <> '2' then
              IF NVL(S_ETOPS_ACTION,'5') = '3' OR NVL(S_ETOPS_ACTION,'5') = '4' THEN 
                IS_PN := DF_GET_INTERCHANGE_EFFECTIVE(IS_PN, IS_AC, IL_WO);
                MS_PN.S_ORDER_TYPE := 'S/O';
              END IF	;

              IF trim(D_QTY_RESERVED) is null THEN 	D_QTY_RESERVED := 0; end if;

              D_REQUISITION := 0;

              begin
                SELECT sum( "REQUISITION_DETAIL"."QTY_REQUIRE" )  
                INTO d_requisition  
                FROM "REQUISITION_HEADER",   
                    "REQUISITION_DETAIL"  
                WHERE ( "REQUISITION_DETAIL"."REQUISITION" = "REQUISITION_HEADER"."REQUISITION" ) and  
                    ( ( "REQUISITION_HEADER"."WO" = il_wo ) AND  
                    ( "REQUISITION_HEADER"."TASK_CARD" = is_task_card ) AND 
                    ( NVL("REQUISITION_HEADER"."TASK_CARD_PN", LPAD(' ', 35)) = is_task_card_pn ) AND
                    ( NVL("REQUISITION_HEADER"."TASK_CARD_SN", LPAD(' ', 35)) = is_task_card_pn_sn ) AND
                    ( "REQUISITION_DETAIL"."PN" = IS_PN ) AND
                    ( "REQUISITION_DETAIL"."STATUS" IN ('OPEN','CLOSED')));
              EXCEPTION
              WHEN OTHERS THEN
                d_requisition := null;
              END;

              If trim(d_requisition) is null Then d_requisition := 0; end if;

              d_requisition_order := 0;

              begin
              SELECT sum( "REQUISITION_DETAIL"."QTY_REQUIRE" )  
              INTO d_requisition_order  
              FROM "REQUISITION_HEADER",   
                  "REQUISITION_DETAIL"  
              WHERE ( "REQUISITION_DETAIL"."REQUISITION" = "REQUISITION_HEADER"."REQUISITION" ) and  
                  ( ( "REQUISITION_HEADER"."WO" = il_wo ) AND  
                  ( "REQUISITION_HEADER"."TASK_CARD" = is_task_card ) AND  
                  ( NVL("REQUISITION_HEADER"."TASK_CARD_PN", '                         ') = is_task_card_pn ) AND
                  ( NVL("REQUISITION_HEADER"."TASK_CARD_SN", '                    ') = is_task_card_pn_sn ) AND
                  ( "REQUISITION_DETAIL"."PN" = is_pn ) and
                  ( "REQUISITION_DETAIL"."STATUS" = 'ORDER'));
              EXCEPTION
              WHEN OTHERS THeN
                d_requisition_order := null;
              end;

              If trim(d_requisition_order) is null Then d_requisition_order := 0; end if;

              D_ORDER_RESERVER := 0;

              begin
                SELECT sum("ORDER_DETAIL"."QTY_REQUIRE")  
                INTO d_order_reserver  
                FROM "ORDER_DETAIL"  
                WHERE ( "ORDER_DETAIL"."PN" = is_pn ) AND  
                    ( "ORDER_DETAIL"."AUTO_ISSUE" in ( 'RESERVE','ISSUE') ) AND  
                    ( "ORDER_DETAIL"."WO" = il_wo ) AND  
                    ( "ORDER_DETAIL"."TASK_CARD" = IS_TASK_CARD );
              exception
              WHEN OTHERS THEN
                D_ORDER_RESERVER := NULL;
              end;

              If trim(d_order_reserver) is null Then d_order_reserver := 0; end if;

              id_qty := id_qty - (d_qty_reserved + d_requisition + d_requisition_order + d_order_reserver);

              IF ID_QTY > 0 THEN

                n_batch:= null;
                s_sn := null;

                DW_EU := WF_NEW(IS_TRAN, IL_PICKLIST, IS_PN, IS_TASK_CARD, ID_QTY, GS_USER, n_batch, s_sn);
                I_RETURN :=0;
                ii_nonEffective := 1;
                plog.debug('before the edit');
                i_return :=  WF_EDIT(DW_EU, DW_PN_INVENTORY_AVL, DW_PN_INVENTORY_AVL_QTY,
                                     dw_pn_inventory_avl_qty1, dw_pn_inventory_avl_qty2, is_errfld, IS_TPW,
                                     IS_AC, IL_WO, IS_LOCATION, IS_ETOPS_ACTION,
                                     IS_ORIGINAL, GS_COMPANY_MULTI, IS_BOCRT, IS_SHORTAGE_PRINT_ONLY,
                                     IL_REQUISITION, IS_PN, IS_PRIORITY_REQ,
                                     IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ,
                                     IS_COMPANY, IS_TASK_CARD, GS_USER, IS_EC,
                                     IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, is_defect , is_defect_type , il_defect_item,
                                     IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                     IL_REQUIRE_HOUR_REQ, il_require_minute_req);
               plog.debug('after the edit');
                ms_location_site.s_shortage_print_only:= 'N';

                if ms_location_site.s_shortage_print_only = 'N' then

                  begin
                    SELECT "PN_MASTER"."PN_DESCRIPTION"   
                    INTO is_pn_description   
                    FROM "PN_MASTER",   
                        "PN_INTERCHANGEABLE"  
                    WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) AND  
                        ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = is_pn ) );
                  EXCEPTION
                  WHEN OTHERS THEN 
                    is_pn_description := null;
                  END;

                  If i_return = 0 then
                    If s_new = 'NEW' Then

                      IF S_WOPICK1 = 'N' OR ( S_WOPICK1 = 'Y' AND IL_PICKLIST = 0 )   THEN
                      plog.debug('before the wf_picklist_header');
                        WF_NEW_PICKLIST_HEADER(IL_PICKLIST, IS_LOCATION, IL_WO, IS_TASK_CARD_HEADER,
                                               IDT_SCHEDULE_START_DATE, IL_REQUIRE_HOUR, IL_REQUIRE_MINUTE,
                                               IS_DELIVERY_LOCATION, IS_PRIORITY, IS_SITE, IS_TASK_CARD_PN,
                                               is_task_card_pn_sn,is_defect, is_defect_type,il_defect_item, is_ac, gs_user);
                                               plog.debug('after wf_new_picklisT_header, il_picklist = ' || il_picklist);
                      End If;

                      S_NEW := ' ';
                      DW_EU.picklist := IL_PICKLIST;

                    End If;

                    IF IS_WOPKLNLA = 'Y' AND NVL(DW_PN_INVENTORY_AVL(1).PN,' ') <> ' ' THEN
                      DECLARE
                        B_INCOMPLETE BOOLEAN;
                        L_BATCH NUMBER;
                        l_trow NUMBER;
                        l_row NUMBER;
                        L_SAVED_CROW NUMBER;
                        D_PICKLIST_QTY NUMBER;
                        B_CONTINUE BOOLEAN := FALSE;
                      BEGIN
                        D_PICKLIST_QTY := 0;
                        L_SAVED_CROW := 0;
                        l_trow := dw_eu.qty; 

                        FOR L_CROW IN 1..L_TROW
                        loop

                          B_CONTINUE := FALSE;

                          IF L_CROW > 1 THEN
                            DW_EU.BATCH := 0;
                            I_RETURN := WF_EDIT(DW_EU, DW_PN_INVENTORY_AVL, DW_PN_INVENTORY_AVL_QTY,
                                               dw_pn_inventory_avl_qty1, dw_pn_inventory_avl_qty2, is_errfld, IS_TPW,
                                               IS_AC, IL_WO, IS_LOCATION, IS_ETOPS_ACTION,
                                               IS_ORIGINAL, GS_COMPANY_MULTI, IS_BOCRT, IS_SHORTAGE_PRINT_ONLY,
                                               IL_REQUISITION, IS_PN, IS_PRIORITY_REQ,
                                               IS_REQUISITION_TYPE, IS_COMPANYMULTIREQ,
                                               IS_COMPANY, IS_TASK_CARD, is_defect, GS_USER, IS_EC,
                                               IS_SITE, IS_TASK_CARD_PN, IS_TASK_CARD_PN_SN, is_defect_type , il_defect_item ,
                                               IDT_REQUIRE_DATE_REQ, IDT_SCHEDULE_START_DATE,
                                               IL_REQUIRE_HOUR_REQ, il_require_minute_req);
                            IF I_RETURN = 1 THEN B_CONTINUE := TRUE; END IF;
                          END IF;

                          IF NOT B_CONTINUE THEN

                            L_BATCH := 0;
                            b_incomplete := WF_CHECK_INCOMPLETE(l_batch, dw_pn_inventory_avl, MS_PN);
                            DW_EU.BATCH := L_BATCH;

                            --log 150548 modified
                            BEGIN
                              SELECT "PROFILE"
                              INTO PROFILE_NAME 
                              from PROFILE_MASTER;
                            EXCEPTION
                            WHEN OTHERS THEN
                              PROFILE_NAME := NULL;
                            END;

                            IF(PROFILE_NAME = 'SWA')
                            then
                              null;
                            else
                              dw_eu.qty := 1;
                            END IF;
                            --log 150548 modified

                            IF B_INCOMPLETE  THEN
                              IF (NVL(T_DW_SEL(I_CROW).S_RESERVE, 'YES') <> 'DELETE') AND (I_CROW <> L_SAVED_CROW) THEN
                                IF IMESSAGEBOXINCOMPLETE = 1 THEN
  --                                wf_load_missing_nla(l_batch) --TODO
                                 L_SAVED_CROW := I_CROW;
                                End If;
                              ELSE
  --                              wf_load_missing_nla(l_batch) --TODO
                                NULL;
                              END IF;
                            End If;

                            --log 150548 modified
                            IF(PROFILE_NAME = 'SWA')
                            then
                              D_QTY := 1;	
                            else
                              D_QTY := DW_EU.QTY;
                            end if;
                            --log 150548 modified

                            D_QTY_RESERVED := T_DW_SEL(I_CROW).N_QTY_RESERVED;
                            D_QTY_RESERVED := nvl(D_QTY_RESERVED,0) +nvl(D_QTY ,0);
                            T_DW_SEL(I_CROW).N_QTY_RESERVED := D_QTY_RESERVED;
                            T_DW_SEL(I_CROW).DT_MODIFIED_DATE := DT_TODAY;
                            T_DW_SEL(I_CROW).S_PICKLIST_PROCESSED := 'Y'; 
                            MS_PN.S_LOCATION := IS_LOCATION;
                            MS_PN.S_TASK_CARD  := IS_TASK_CARD;
                            IF IS_BOCRT = 'N' THEN MS_PN.s_transaction_type := 'NOREQUISITION'; END IF;
                            MS_PN.N_PICKLIST := IL_PICKLIST;
                            t_dw_eu := OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);
                            D_PICKLIST_QTY := D_PICKLIST_QTY + 1;

                          END IF;
                        end loop;

                   -- Log159804
                      for L_CROW in T_DW_EU.first..T_DW_EU.last
                        LOOP
                        T_DW_EU(L_CROW).QTY := D_PICKLIST_QTY;
                        end loop;
                   -- 159804

                        DW_EU.BATCH := 0;

                        DW_EU.QTY := D_PICKLIST_QTY;

                      END;
                    Else	

                      D_QTY := DW_EU.QTY;
                      D_QTY_RESERVED := nvl(D_QTY_RESERVED , 0)  + nvl( D_QTY , 0 );
                      T_DW_SEL(I_CROW).N_QTY_RESERVED := D_QTY_RESERVED;
                      T_DW_SEL(I_CROW).DT_MODIFIED_DATE := DT_TODAY;
                      T_DW_SEL(I_CROW).S_PICKLIST_PROCESSED := 'Y';  
                      MS_PN.S_LOCATION := IS_LOCATION;
                      MS_PN.S_TASK_CARD  := IS_TASK_CARD;
                      IF IS_BOCRT = 'N' THEN MS_PN.s_transaction_type := 'NOREQUISITION'; END IF;
                      MS_PN.N_PICKLIST := IL_PICKLIST;
                      t_dw_eu := OF_PICKLIST_DISTRIBUTION(DW_PN_INVENTORY_AVL, DW_EU, DW_PICKLIST_DETAIL, MS_PN, IS_ERRFLD, IS_ORIGINAL, gs_user, gs_company_multi);

                    END IF;

                    GF_SAVE_TT_PICKLIST_DISTRIB(t_dw_eu);

                    DECLARE
                      L_PICKLIST_LINE NUMBER := DW_EU.PICKLIST_LINE;
                    BEGIN
                      PICKLIST_DISTRIBUTION_AUDIT(IL_PICKLIST, L_PICKLIST_LINE, 'NEW', GS_USER);
                      IS_TRAN := ' ';
                    end;
                  End If;
                END IF;
              End If;
            end if;
          end;
        end loop;

      end if;  


        if ms_location_site.s_shortage_print_only = 'N' then
          IF IS_WOPKLNLA = 'Y' THEN
            DECLARE
              S_DELETE varchar2(100);
            BEGIN

              IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
                FOR I_CROW in reverse t_dw_sel.first..t_dw_sel.last
                LOOP
                  s_delete := nvl(t_dw_sel(i_crow).S_reserve, 'YES');
                  IF ( S_DELETE = 'DELETE' ) OR ( S_DELETE = 'MAIN' ) THEN
                    T_DW_SEL(I_CROW) := NULL;
                  End If;
                END LOOP;
              end if;


               IF T_DW_SEL_DEFECT IS NOT NULL AND T_DW_SEL_DEFECT.COUNT > 0 THEN
                FOR I_CROW in reverse T_DW_SEL_DEFECT.first..T_DW_SEL_DEFECT.last
                LOOP
                  s_delete := nvl(T_DW_SEL_DEFECT(i_crow).S_reserve, 'YES');
                  IF ( S_DELETE = 'DELETE' ) OR ( S_DELETE = 'MAIN' ) THEN
                    T_DW_SEL_DEFECT(I_CROW) := NULL;
                  End If;
                END LOOP;
              end if;


            end;
          End If;

          --print picklist to report server for picklist use
          sendPicklistToPrintQueue(IL_PICKLIST) ;

          --send notification , TODO
         IF T_DW_SEL IS NOT NULL AND T_DW_SEL.COUNT > 0 THEN
          GF_SAVE_WO_TC_PN_ARRAY(T_DW_SEL);
        end if;  


        IF T_DW_SEL_DEFECT IS NOT NULL AND T_DW_SEL_DEFECT.COUNT > 0 THEN
          GF_SAVE_DEFECT_PN_ARRAY(T_DW_SEL_DEFECT);
        end if;

        return IL_PICKLIST;


        end if;

      end if;
    end if;

  END W_WO_RESERV_EU_SUB_WO_LOOP;

 PROCEDURE sendPicklistToPrintQueue(
    l_picklist NUMBER)
AS
l_id number ;
BEGIN

l_id := SEQ_IOS_PRINT_JOBS.nextval ; 
  INSERT
  INTO IOS_PRINTING_JOBS
    (
      UNIQUE_ID,
      PRINT_WINDOW,
      SELECTED_PRINT,
      PRINT_TITLE,
      COMPARISON_OPERATOR,
      PRINT_STATUS,
      TRAX_USER,
      CREATED_DATE,
      START_DATE,
      FINISH_DATE,
      SAVING_PATH,
      URL_PATH , 
      PRINT_PARAMETERS , 
      OBJECT_PARAMETERS
    )
    VALUES
    (
    l_id      ,
      'w_picklist_print',
      NULL,
      'picklist print',
      NULL,
      'OPEN',
      P_USER,
     sysdate,
    null,
     null,
     null,
     null , 
     to_char(l_picklist) , 
    -- utl_raw.cast_to_raw( to_char( l_picklist ) )
    null
    );

    pkg_window_printing_jobs.add_ios_job(l_id); 
exception when others then 
null;

END ; 

  PROCEDURE W_WO_RESERVATION_EU(N_WO NUMBER, S_AC VARCHAR2, MS_LOCATION_SITE IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE, MS_LOCATION_SITE_REQ IN OUT PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                s_task_card varchar2 default null, s_task_card_pn varchar2 default null,s_task_card_sn varchar2 default null , 
                                s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0, 
                                GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER)
  AS
  n_licklist number;
  BEGIN
    --UE_LOAD_ALL_WO
    if TRIM(S_TASK_CARD) is not null  or  TRIM(S_defect) is not null  then
       PLOG.debug('Task card or defect is not null enteringw_wo_reserv_eu_sub_wo_loop taskcard = ' || S_TASK_CARD || ' defect: ' || s_defect  );



       n_licklist := w_wo_reserv_eu_sub_wo_loop(N_WO, S_AC, MS_LOCATION_SITE, ms_location_site_req, 
                          TRIM(S_TASK_CARD),TRIM(S_TASK_CARD_PN) , TRIM(S_TASK_CARD_SN) ,
                          s_defect , s_defect_type , l_defect_item , 
                          GS_COMPANY_MULTI, GS_USER, IMESSAGEBOXINCOMPLETE);
    ELSE
      DECLARE
        cursor CUR_WO_SUB is
        SELECT "WO"."WO"
        FROM "WO"
        START WITH "WO"."WO" = n_WO
        CONNECT BY PRIOR "WO"."WO" = "WO"."NH_WO";
        TYPE TT_SUB_WO IS TABLE OF NUMBER;
        t_sub_wo TT_SUB_WO := TT_SUB_WO();
      BEGIN
        OPEN CUR_WO_SUB;
        FETCH CUR_WO_SUB BULK COLLECT INTO T_SUB_WO;
        CLOSE CUR_WO_SUB;

        IF T_SUB_WO IS NOT NULL AND T_SUB_WO.COUNT > 0 THEN
          FOR I IN T_SUB_WO.FIRST..T_SUB_WO.LAST
          LOOP
            n_licklist := w_wo_reserv_eu_sub_wo_loop(T_SUB_WO(I), S_AC, MS_LOCATION_SITE, ms_location_site_req, TRIM(S_TASK_CARD),TRIM(S_TASK_CARD_PN) , TRIM(S_TASK_CARD_SN)  ,
                    s_defect, s_defect_type , l_defect_item ,
                    GS_COMPANY_MULTI, gs_user, IMESSAGEBOXINCOMPLETE);
          end loop;
        END IF;

      end;
    end if;
  end;

PROCEDURE WF_PICKLIST_RESERVATION(N_WO NUMBER, S_AC VARCHAR2, MS_LOCATION_SITE in out PKG_TYPE_STRUCTURES.ST_LOCATION_SITE,
                                    Ms_Location_Site_Req In Out Pkg_Type_Structures.St_Location_Site, 
                                    S_Task_Card Varchar2 Default Null, S_Task_Card_pn Varchar2 Default Null, S_Task_Card_sn Varchar2 Default Null,
                                    s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0,                                    
                                    Gs_Company_Multi In Out Nocopy Varchar2,
                                    GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER)
  AS
  BEGIN
   plog.debug('Entering reservation function');
    W_WO_RESERVATION_EU(n_wo, s_Ac, MS_LOCATION_SITE, ms_location_site_req, s_task_card,S_TASK_CARD_pn , S_TASK_CARD_sn ,
                     s_defect , s_defect_type , l_defect_item ,
                GS_COMPANY_MULTI, gs_user, IMESSAGEBOXINCOMPLETE);
  end WF_PICKLIST_RESERVATION;

  PROCEDURE WF_RE_RESERVE_PART_AND_LABOR(N_WO NUMBER, S_PICKLIST_PRIORITY VARCHAR2, S_REQUISITION_TYPE VARCHAR2, S_TASK_CARD IN OUT NOCOPY VARCHAR2,
                                         GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER)
  AS
    N_REQUISITION_COUNT NUMBER;
    N_PICKLIST_COUNT NUMBER;
    R_WO WO%ROWTYPE;
    MS_LOCATION_SITE PKG_TYPE_STRUCTURES.ST_LOCATION_SITE;
    ms_location_site_req PKG_TYPE_STRUCTURES.ST_LOCATION_SITE;
  BEGIN

    BEGIN
      SELECT *
      INTO R_WO
      FROM WO
      where wo = n_wo;
    end;

    begin
      select count(ph.picklist)
      into n_picklist_count
      from picklist_header ph
      where ph.wo = n_wo;
    exception
    when no_data_found then
      n_picklist_count := 0;
    end;

    begin
      select count(rd.requisition)
      into n_requisition_count
      FROM REQUISITION_HEADER RH,
           REQUISITION_DETAIL RD
      WHERE RH.WO = N_WO
      and rd.requisition = rh.requisition
      and rd.status not in ('CANCEL');
    exception
    when no_data_found then
      N_REQUISITION_COUNT := 0;
    end;

    if n_picklist_count > 0 or n_requisition_count > 0 then

      WF_REQUISITION_CANCELATION(N_WO, S_TASK_CARD);

      WF_PICKLIST_RESERVATION_CANCEL(N_WO, S_TASK_CARD, gs_user);

      MS_LOCATION_SITE.S_LOCATION := R_WO.LOCATION;
      MS_LOCATION_SITE.S_DELIVERY_LOCATION := R_WO.LOCATION;
      MS_LOCATION_SITE.S_SITE := R_WO.SITE;
      MS_LOCATION_SITE.S_SHORTAGE_PRINT_ONLY := 'N';
      MS_LOCATION_SITE.S_PRIORITY := S_PICKLIST_PRIORITY;
      MS_LOCATION_SITE.S_TYPE := S_REQUISITION_TYPE;
      MS_LOCATION_SITE.DT_REQUIRE_DATE := R_WO.SCHEDULE_START_DATE;
      MS_LOCATION_SITE.L_HOUR := R_WO.SCHEDULE_START_HOUR;
      MS_LOCATION_SITE.L_MINUTE := r_wo.schedule_start_minute;

      ms_location_site_req.S_LOCATION := R_WO.LOCATION;
      ms_location_site_req.S_DELIVERY_LOCATION := R_WO.LOCATION;
      ms_location_site_req.S_SITE := R_WO.SITE;
      ms_location_site_req.S_SHORTAGE_PRINT_ONLY := 'N';
      ms_location_site_req.S_PRIORITY := S_PICKLIST_PRIORITY;
      ms_location_site_req.S_TYPE := S_REQUISITION_TYPE;
      ms_location_site_req.DT_REQUIRE_DATE := R_WO.SCHEDULE_START_DATE;
      ms_location_site_req.L_HOUR := R_WO.SCHEDULE_START_HOUR;
      ms_location_site_req.L_MINUTE := r_wo.schedule_start_minute;

      wf_picklist_reservation(n_wo, r_wo.ac, MS_LOCATION_SITE, ms_location_site_req, s_task_card,
      null  ,null, null,null,null,  gs_company_multi, gs_user, IMESSAGEBOXINCOMPLETE);	
    end if;
  end WF_RE_RESERVE_PART_AND_LABOR;


   function eMobility_Picklist(s_type VARCHAR2, n_id number, N_WO NUMBER, S_AC VARCHAR2, S_TASK_CARD VARCHAR2 DEFAULT NULL,S_TASK_CARD_PN VARCHAR2 DEFAULT NULL , S_TASK_CARD_SN VARCHAR2 DEFAULT NULL , 
                                       s_defect Varchar2 Default Null, s_defect_type Varchar2 Default Null, l_defect_item number Default 0, 
                                       S_LOCATION Varchar2, S_DELIVERY_LOCATION Varchar2, S_SITE Varchar2, S_PICKLIST_PRIORITY Varchar2, S_REQUISITION_TYPE Varchar2,
                                       DT_REQUIRE_DATE date, L_REQUIRE_HOUR NUMBER, L_REQUIRE_minute NUMBER,
                                       GS_COMPANY_MULTI in out nocopy varchar2, GS_USER in out nocopy VARCHAR2, IMESSAGEBOXINCOMPLETE NUMBER) return VARCHAR2
  as
  n_picklist_no number;
  MS_LOCATION_SITE PKG_TYPE_STRUCTURES.ST_LOCATION_SITE;


  begin

      MS_LOCATION_SITE.S_LOCATION := S_LOCATION;
      MS_LOCATION_SITE.S_DELIVERY_LOCATION := S_DELIVERY_LOCATION;
      MS_LOCATION_SITE.S_SITE := S_SITE;
      MS_LOCATION_SITE.S_SHORTAGE_PRINT_ONLY := 'N';
      MS_LOCATION_SITE.S_PRIORITY := S_PICKLIST_PRIORITY;
      MS_LOCATION_SITE.S_TYPE := S_REQUISITION_TYPE;
      MS_LOCATION_SITE.DT_REQUIRE_DATE := DT_REQUIRE_DATE;
      MS_LOCATION_SITE.L_HOUR := L_REQUIRE_HOUR;
      MS_LOCATION_SITE.L_MINUTE := L_REQUIRE_minute;

     plog.debug('Entering emobility picklist : ' || s_task_card || ' ,' || S_TASK_CARD_PN  || ' ,' || S_TASK_CARD_SN  || ' ,' || N_WO  || ' ,' || S_AC);

    if ( s_type = 'TASKCARD') then

      n_picklist_no := w_wo_reserv_eu_sub_wo_loop(N_WO, S_AC, MS_LOCATION_SITE, MS_LOCATION_SITE, 
                          TRIM(S_TASK_CARD),TRIM(S_TASK_CARD_PN) , TRIM(S_TASK_CARD_SN) ,
                          s_defect , s_defect_type , l_defect_item , 
                          GS_COMPANY_MULTI, GS_USER, IMESSAGEBOXINCOMPLETE);
     plog.debug('n_picklist_no' || n_picklist_no);
    elsif (s_type = 'DEFECT') then

      n_picklist_no := eMobility_Picklist_defect(N_WO, S_AC, MS_LOCATION_SITE, MS_LOCATION_SITE, 
                          TRIM(S_TASK_CARD),TRIM(S_TASK_CARD_PN) , TRIM(S_TASK_CARD_SN) ,
                          s_defect , s_defect_type , l_defect_item , 
                          GS_COMPANY_MULTI, GS_USER, IMESSAGEBOXINCOMPLETE);

    else -- Aircraft Type Shoudl Said 'AIRCRAFT'


      n_picklist_no := eMobility_Picklist_ac(n_id , N_WO, S_AC, MS_LOCATION_SITE, MS_LOCATION_SITE, 
                          TRIM(S_TASK_CARD),TRIM(S_TASK_CARD_PN) , TRIM(S_TASK_CARD_SN) ,
                          s_defect , s_defect_type , l_defect_item , 
                          GS_COMPANY_MULTI, GS_USER, IMESSAGEBOXINCOMPLETE);

    end if;    
   
    if g_type = 'R-' then
        plog.debug('RETURN : ' || g_type ||to_char(g_rNumber) );
      return g_type || to_char(g_rNumber);
    else
      plog.debug('RETURN : P-' || to_char(n_picklist_no) );
      return 'P-' || to_char(n_picklist_no);
    end if;
  end eMobility_Picklist;
  
  PROCEDURE PICKLIST_CANCEL_Defect(defect VARCHAR2, defect_type VARCHAR2, defect_item Number)
  AS
  BEGIN
    RESERV_CANCEL_SUB_DEFECT_LOOP(defect, defect_type, defect_item);
  end PICKLIST_CANCEL_Defect;
  
  	
procedure RESERV_CANCEL_SUB_DEFECT_LOOP(defect VARCHAR2, defect_type VARCHAR2, defect_item Number)
  AS
    --S_WOPICK1 VARCHAR2(100);
    t_DW_SEL_CANCEL_ARRAY DW_SEL_CANCEL_ARRAY;
    gs_user varchar2 (20 char) ;
    
  BEGIN
    --UE_POSTOPEN
    --S_WOPICK1 := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('WOPICK1');
    
    CANCEL_REQUISITION_BY_DEFECT(defect, defect_type, defect_item);
    t_DW_SEL_CANCEL_ARRAY := LOAD_PN_for_cancel_defect(defect, defect_type, defect_item);

    IF T_DW_SEL_CANCEL_ARRAY IS NOT NULL AND T_DW_SEL_CANCEL_ARRAY.COUNT > 0 THEN
      FOR I IN T_DW_SEL_CANCEL_ARRAY.FIRST..T_DW_SEL_CANCEL_ARRAY.LAST
      LOOP
        DECLARE
          L_LINE NUMBER;
          S_PN VARCHAR(100);
          s_task_card VARCHAR(100);
          defect_pn VARCHAR(100);
          S_PICKLIST_STATUS VARCHAR(100);
          D_QTY NUMBER;
          D_QTY_RESERVED NUMBER;
          DT_TODAY DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
          il_picklist number;
        BEGIN
          il_picklist := T_DW_SEL_CANCEL_ARRAY(i).n_picklist;

         /* IF S_WOPICK1 = 'Y' THEN
            s_task_card  := T_DW_SEL_CANCEL_ARRAY(i).s_task_card2;
          ELSE
            S_TASK_CARD  := T_DW_SEL_CANCEL_ARRAY(i).s_TASK_CARD;
          End If;*/

          L_LINE  := T_DW_SEL_CANCEL_ARRAY(I).N_LINE;
          D_QTY := T_DW_SEL_CANCEL_ARRAY(I).N_QTY;
          S_PN  := T_DW_SEL_CANCEL_ARRAY(I).S_PN;
          s_picklist_status := T_DW_SEL_CANCEL_ARRAY(i).s_status;

          IF S_PICKLIST_STATUS <> 'TRANSFER' THEN
            DECLARE 
              CURSOR CUR_PD IS
              SELECT *
              FROM PICKLIST_DISTRIBUTION
              WHERE TRANSACTION = 'REQUIRE'
              AND PICKLIST = IL_PICKLIST
              AND PICKLIST_LINE = L_LINE;
              TYPE TT_PICKLIST_DISTRIBUTION IS TABLE OF PICKLIST_DISTRIBUTION%ROWTYPE;
              T_PICKLIST_DISTRIBUTION TT_PICKLIST_DISTRIBUTION := TT_PICKLIST_DISTRIBUTION();
              MS_PN PKG_TYPE_STRUCTURES.ST_PN;
              N_SQLCODE NUMBER;
              l_count number := 0;
            BEGIN
              OPEN CUR_PD;
              FETCH CUR_PD BULK COLLECT INTO T_PICKLIST_DISTRIBUTION;
              CLOSE CUR_PD;

              PICKLIST_DISTRIBUTION_AUDIT(il_picklist, l_line, 'CANCEL');

              MS_PN.n_PICKLIST := IL_PICKLIST;
              ms_pn.n_picklist_line := l_line;
              of_picklist_detail(ms_pn);

              begin
                SELECT PN,   
                    QTY_RESERVED  
                 INTO defect_pn,   
                    d_qty_reserved  
                 FROM defect_report_pn
                WHERE defect_report_pn.defect = defect and defect_report_pn.defect_type = defect_type and defect_report_pn.defect_item = defect_item;

                n_sqlcode := sqlcode;
              exception
              WHEN OTHERS THEN
                N_SQLCODE := SQLCODE;

--                DECLARE
--                  s_pn_main varchar2(100);
--                BEGIN
--                  SELECT "PN_INTERCHANGEABLE"."PN"
--                  INTO s_pn_main
--                  FROM "PN_INTERCHANGEABLE"
--                  WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn;
--
--                  SELECT "WO_TASK_CARD_PN"."PN",   
--                      "WO_TASK_CARD_PN"."QTY_RESERVED"  
--                   INTO defect_pn,   
--                      d_qty_reserved  
--                   FROM "WO_TASK_CARD_PN",   
--                      "PN_INTERCHANGEABLE"  
--                  WHERE ( "WO_TASK_CARD_PN"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) and  
--                      (  "WO_TASK_CARD_PN"."WO" = n_wo ) AND  
--                      ( "WO_TASK_CARD_PN"."TASK_CARD" = s_task_card ) AND  
--                      ( "PN_INTERCHANGEABLE"."PN" = S_PN_MAIN )  AND 
--                      ("WO_TASK_CARD_PN"."QTY_RESERVED") > 0  AND ROWNUM =1;
--
--                  n_sqlcode := sqlcode;
--                EXCEPTION
--                WHEN OTHERS THEN
--                  n_sqlcode := sqlcode;
--                end;
              end;

              IF N_SQLCODE <> 100 THEN
                D_QTY_RESERVED := NVL(D_QTY_RESERVED, 0);
                D_QTY := NVL(D_QTY, 0);
                d_qty_reserved := d_qty_reserved - d_qty;

                If d_qty_reserved < 0 then d_qty_reserved := 0; end if;

                UPDATE defect_report_pn 
                SET QTY_RESERVED = d_qty_reserved,
                       MODIFIED_DATE = dt_today
                WHERE defect_report_pn.defect = defect and defect_report_pn.defect_type = defect_type and defect_report_pn.defect_item = defect_item;
              End If;

              if T_PICKLIST_DISTRIBUTION is not null and T_PICKLIST_DISTRIBUTION.count > 0 then                
                gs_user:='EMOBILITY' ; 
                 picklist_header_audit(T_PICKLIST_DISTRIBUTION(1).PICKLIST, 'CANCEL', gs_user);
                UPDATE
                "PICKLIST_HEADER"  
                set status = 'CANCEL',
                "MODIFIED_DATE" = dt_today , 
                "MODIFIED_BY" = gs_user
                WHERE PICKLIST = T_PICKLIST_DISTRIBUTION(1).PICKLIST;
              
                UPDATE
                "PICKLIST_DISTRIBUTION"  
                set status = 'CANCEL',
                "MODIFIED_DATE" = dt_today ,
                 "MODIFIED_BY" = gs_user
                WHERE TRANSACTION = T_PICKLIST_DISTRIBUTION(1).TRANSACTION
                AND   PICKLIST = T_PICKLIST_DISTRIBUTION(1).PICKLIST
                AND   PICKLIST_LINE = T_PICKLIST_DISTRIBUTION(1).PICKLIST_LINE
                and   DISTRIBUTION_LINE = T_PICKLIST_DISTRIBUTION(1).DISTRIBUTION_LINE;                
                commit;
              END IF;
            END;
          END IF;
        end;
      end loop;
    end if;

  end RESERV_CANCEL_SUB_DEFECT_LOOP;
  
  procedure CANCEL_REQUISITION_BY_DEFECT(s_defect VARCHAR2, s_defect_type VARCHAR2, l_defect_item Number) as
    dt_today date;
    s_task_card_t wo_task_card.task_card%type;
    s_return requisition_detail.uom%type;
  begin
    dt_today := pkg_application_function.currentdatetime;

    /*if (s_task_card < '0') then
      s_task_card_t := null;
    end if;*/

    for dcl_requisition in (select "REQUISITION_DETAIL"."REQUISITION",
                                   "REQUISITION_DETAIL"."REQUISITION_LINE",
                                   "REQUISITION_DETAIL"."STATUS"
                            from "REQUISITION_HEADER", "REQUISITION_DETAIL"
                            where ("REQUISITION_DETAIL"."REQUISITION" = "REQUISITION_HEADER"."REQUISITION") and
                                  ("REQUISITION_HEADER".DEFECT = s_defect) and                         
                                  ("REQUISITION_HEADER".DEFECT_TYPE = s_defect_type) and
                                  ("REQUISITION_HEADER".DEFECT_ITEM = l_defect_item)and REQUISITION_DETAIL.STATUS = 'OPEN' )
    loop
    

      
      if (dcl_requisition.status = 'OPEN') then
        -- Cancel detail line
        update "REQUISITION_DETAIL"
        set status = 'CANCEL',
            modified_by = 'EMOBILITY',
            modified_date = dt_today, 
            CANCELED_BY = 'EMOBILITY' , 
            CANCELED_DATE = dt_today
        where ("REQUISITION_DETAIL"."REQUISITION" = dcl_requisition.requisition) and
              ("REQUISITION_DETAIL"."REQUISITION_LINE" = dcl_requisition.requisition_line);

        begin
          select uom
          into s_return
          from requisition_detail
          where (requisition = dcl_requisition.requisition) and
                (status = 'OPEN');
        exception
          when NO_DATA_FOUND then
            dbms_output.put_line('uom: No Data Found');
        end;

        -- Cancel Header
        if (sqlcode = 100) then
          update requisition_header
          set status = 'CANCEL',
              modified_by = 'EMOBILITY',
              modified_date = dt_today
          where requisition = dcl_requisition.requisition;
        end if;
     
      end if;
    end loop;
  end CANCEL_REQUISITION_BY_DEFECT;
  
  FUNCTION LOAD_PN_for_cancel_defect(defect VARCHAR2, defect_type VARCHAR2, defect_item Number) RETURN DW_SEL_CANCEL_ARRAY
  AS
    S_ORIGINAL VARCHAR2(32000);
    s_and VARCHAR2(32000);
    s_file VARCHAR2(32000);
    s_fld VARCHAR2(32000);
    s_select VARCHAR2(32000);
    S_COMPARE VARCHAR2(32000);
    S_WHERE VARCHAR2(32000) := '  ';
    S_MOD VARCHAR2(32000);
    t_DW_SEL_CANCEL_ARRAY DW_SEL_CANCEL_ARRAY;
    cur_query refCursor;
  BEGIN
    s_original := 'SELECT "PICKLIST_HEADER"."WO",   
                         "PICKLIST_HEADER"."TASK_CARD",   
                         "PICKLIST_DISTRIBUTION"."PICKLIST_LINE",   
                         "PICKLIST_DISTRIBUTION"."TRANSACTION",   
                         "PICKLIST_HEADER"."PICKLIST",   
                         "PICKLIST_DISTRIBUTION"."PN",   
                         "PICKLIST_DISTRIBUTION"."QTY",   
                         "PICKLIST_HEADER"."SO",   
                         "PICKLIST_DISTRIBUTION"."ORDER_LINE",   
                         "PICKLIST_HEADER"."CREATED_BY",   
                         "PICKLIST_DISTRIBUTION"."TASK_CARD",   
                         "PICKLIST_HEADER"."STATUS"  
                    FROM "PICKLIST_HEADER",   
                         "PICKLIST_DISTRIBUTION"  
                   WHERE ( picklist_header.picklist = picklist_distribution.picklist )';
    S_COMPARE := ' = ' ;
    S_AND     := ' and ';
    S_FILE    := 'PICKLIST_HEADER';
    S_FLD     := 'defect';
    S_SELECT  := ''''||defect||'''';

    s_where :=  s_where || s_and || s_file || '.' || s_fld ||  s_compare || s_select;  

	--defcet_type
	S_AND     := ' and ';
    S_FILE    := 'PICKLIST_HEADER';
    S_FLD     := 'defect_type';
    S_SELECT  := ''''||defect_type||'''';

    s_where :=  s_where || s_and || s_file || '.' || s_fld ||  s_compare || s_select; 

	--defcet_item
	S_AND     := ' and ';
    S_FILE    := 'PICKLIST_HEADER';
    S_FLD     := 'defect_item';
    S_SELECT  := defect_item;

    s_where :=  s_where || s_and || s_file || '.' || s_fld ||  s_compare || s_select; 	

    --Status
    S_FILE    := 'PICKLIST_HEADER';
    S_FLD     := 'STATUS';
    S_SELECT  := '''OPEN''';
    s_where := s_where || s_and || ' ( ' || s_file || '.' || s_fld ||  s_compare || s_select;

    S_FILE    := 'PICKLIST_HEADER';
    S_FLD     := 'STATUS';
    S_SELECT  := '''TRANSFER''';
    s_where :=  s_where || ' or ' || s_file || '.' || s_fld ||  s_compare || s_select || ' ) ';		   



    S_FILE    := 'PICKLIST_DISTRIBUTION';
    S_FLD     := 'TRANSACTION';
    S_SELECT  := '''REQUIRE''';
    s_where :=  s_where || s_and || s_file || '.' || s_fld ||  s_compare || s_select;

    S_FILE    := 'PICKLIST_DISTRIBUTION';
    S_FLD     := 'STATUS';
    S_SELECT  := '''OPEN''';
    s_where :=  s_where || s_and || s_file || '.' || s_fld ||  s_compare || s_select;

    S_MOD := S_ORIGINAL || S_WHERE;

    OPEN CUR_QUERY FOR S_MOD;
    FETCH CUR_QUERY BULK COLLECT INTO T_DW_SEL_CANCEL_ARRAY;
    close CUR_QUERY;

    return T_DW_SEL_CANCEL_ARRAY;

  end LOAD_PN_for_cancel_defect;

function addPartToemobilityQueue(s_pn pn_master.pn%type , 
                l_batch number , 
                s_sn pn_inventory_detail.sn%type , 
                l_qty pn_inventory_detail.qty_available%type)
                      return number
is
l_result number ; 
begin

l_result := SEQ_EMOBILITY_PICKLIST.nextval ; 

insert into EMOBILITY_PICKLIST_QUEUE
(
PN ,
TANSACTION_ID, 
sn,
batch_no ,
qty
)
values
(
s_pn,
l_result ,
s_sn ,
l_batch , 
l_qty
) ;

commit ; 
 
return l_result ;  
end ; 

procedure addWoTaskPn(s_ac varchar2 , l_wo number , s_task varchar2, s_tc_pn varchar2 , s_tc_sn varchar2 , 
s_pn varchar2 ,  l_qty number , s_user varchar2 , s_reservation_type varchar2)  is

t_wotc_pn wo_task_card_pn%rowtype ;
pragma AUTONOMOUS_TRANSACTION  ; 

begin

    begin
    
    select * 
    into t_wotc_pn
    from wo_task_card_pn 
    where wo = l_wo and task_card = s_task and task_card_pn = s_tc_pn
    and task_card_pn_sn = s_tc_sn and pn = s_pn ; 
    
    if (t_wotc_pn."RESERVE" is not null and t_wotc_pn."RESERVE" = 'YES') then 
    
      if t_wotc_pn.qty is null then 
        t_wotc_pn.qty := 0; 
      end if; 
      
      update wo_task_card_pn 
      set qty =  t_wotc_pn.qty + l_qty , modified_date = sysdate , modified_by = s_user
      where wo = l_wo and task_card = s_task and task_card_pn = s_tc_pn
      and task_card_pn_sn = s_tc_sn and pn = s_pn  ;
      commit ;
      
    end if; 
     
    exception when no_data_found then 
    
      t_wotc_pn.wo := l_wo ;
      t_wotc_pn.ac := s_ac ; 
      t_wotc_pn.task_card := s_task ;
      t_wotc_pn.task_card_pn := s_tc_pn ; 
      t_wotc_pn.task_card_pn_sn := s_tc_sn ;
      
      t_wotc_pn.created_by := s_user ; 
      t_wotc_pn.modified_by := s_user ; 
      t_wotc_pn.created_date := sysdate ; 
      t_wotc_pn.modified_date := sysdate ;
      
      
      t_wotc_pn.pn := s_pn ;
      t_wotc_pn.qty:=l_qty ;
      t_wotc_pn.reserve := s_reservation_type ; 
      t_wotc_pn.spare := 'SPARE' ; 
      t_wotc_pn.PICKLIST_PROCESSED := 'NEW' ; 
      
      insert into wo_task_card_pn values t_wotc_pn ; 
      
      commit ; 
    
    end ; 

end ;


END PKG_IFACE_PICKLIST;

/ 


  CREATE OR REPLACE PACKAGE "PKG_IFACE_DEFECT_REPORTS" is

-- ------------------------------------------
-- Cursor variable
TYPE c_interface_defect_report IS REF CURSOR RETURN "INTERFACE_DEFECT_REPORT"%ROWTYPE;
TYPE refCursor IS REF CURSOR;

PROCEDURE ExportDefectXML(
        t_interface_audit in out INTERFACE_AUDIT%ROWTYPE,
        v_DefectReport   in DEFECT_REPORT%ROWTYPE);
-- ------------------------------------
PROCEDURE addDefectToDoc(doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode,
        v_DefectReport   in DEFECT_REPORT%ROWTYPE);
-- --------------------------------------
-- Get a Defect Report from Trax
procedure getDefectReport
(p_DEFECT_TYPE "INTERFACE_DEFECT_REPORT"."DEFECT_TYPE"%type,
  p_DEFECT  "INTERFACE_DEFECT_REPORT"."DEFECT"%TYPE,
  p_DEFECT_ITEM "INTERFACE_DEFECT_REPORT"."DEFECT_ITEM"%TYPE,
  p_INTERFACE_DEFECT_CUR in out c_interface_defect_report)
 -- return c_interface_defect_report
;

------------------------------------------------
--Get AC Service No
function getACServiceNo(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE)
return number;

----------------------------------------------------------------------------------------
--Get new service no
function getNewServiceNo(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE)
return number;

---------------------------------------
-- Get service no
function getServiceNo(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE)
return number;

-- ---------------------------------------
-- Get flight status
procedure setFlightStatus(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE, service_no in number, s_flight_status in varchar2)
;

-- ---------------------------------------
-- Update MDDR
procedure mddr_update(t_defect in out "INTERFACE_DEFECT_REPORT"%rowtype)
;

-- ---------------------------------------
-- Update Concession
procedure concession_update(t_defect_report in out "DEFECT_REPORT"%ROWTYPE)
;

-- ----------------------------
-- Add a defect
procedure addDefect
(t_defect in out "INTERFACE_DEFECT_REPORT"%rowtype)
;


-- ----------------------------
-- Add a defect with parameters
procedure addDefect
(p_DEFECT "INTERFACE_DEFECT_REPORT"."DEFECT"%type,
p_DEFECT_ITEM "INTERFACE_DEFECT_REPORT"."DEFECT_ITEM"%type,
p_AC "INTERFACE_DEFECT_REPORT"."AC"%type,
p_CHAPTER "INTERFACE_DEFECT_REPORT"."CHAPTER"%type,
p_SECTION "INTERFACE_DEFECT_REPORT"."SECTION"%type,
p_FLIGHT "INTERFACE_DEFECT_REPORT"."FLIGHT"%type,
p_FLIGHT_PHASE "INTERFACE_DEFECT_REPORT"."FLIGHT_PHASE"%type,
p_DEFECT_DESCRIPTION "INTERFACE_DEFECT_REPORT"."DEFECT_DESCRIPTION"%type,
p_STATION "INTERFACE_DEFECT_REPORT"."STATION"%type,
p_MODIFIED_BY "INTERFACE_DEFECT_REPORT"."MODIFIED_BY"%type,
p_MODIFIED_DATE "INTERFACE_DEFECT_REPORT"."MODIFIED_DATE"%type,
p_DEFECT_DATE "INTERFACE_DEFECT_REPORT"."REPORTED_DATE"%type,
p_MDDR "INTERFACE_DEFECT_REPORT"."MDDR"%type,
p_DEFER "INTERFACE_DEFECT_REPORT"."DEFER"%type,
p_DEFER_BY "INTERFACE_DEFECT_REPORT"."DEFER_BY"%type,
p_DEFER_TO_DATE "INTERFACE_DEFECT_REPORT"."DEFER_TO_DATE"%type,
p_DEFER_DATE "INTERFACE_DEFECT_REPORT"."DEFER_DATE"%type,
p_MEL_NUMBER "INTERFACE_DEFECT_REPORT"."MEL_NUMBER"%type,
p_DEFER_CATEGORY "INTERFACE_DEFECT_REPORT"."DEFER_CATEGORY"%type,
p_SCHEDULE_HOURS "INTERFACE_DEFECT_REPORT"."SCHEDULE_HOURS"%type,
p_SCHEDULE_CYCLES "INTERFACE_DEFECT_REPORT"."SCHEDULE_CYCLES"%type,
p_SCHEDULE_DAYS "INTERFACE_DEFECT_REPORT"."SCHEDULE_DAYS"%type,
p_DEFER_TO_NEXT_EC "INTERFACE_DEFECT_REPORT"."DEFER_TO_NEXT_EC"%type,
p_SKILL "INTERFACE_DEFECT_REPORT"."SKILL"%type,
p_MAN_HOURS "INTERFACE_DEFECT_REPORT"."MAN_HOURS"%type,
p_MAN_REQUIRED "INTERFACE_DEFECT_REPORT"."MAN_REQUIRED"%type,
p_CAPABILITY_AREA "INTERFACE_DEFECT_REPORT"."CAPABILITY_AREA"%type,
p_PLAN_DEFECT "INTERFACE_DEFECT_REPORT"."PLAN_DEFECT"%type,
p_REPEAT_NUMBER "INTERFACE_DEFECT_REPORT"."REPEAT_NUMBER"%type,
p_COMPLETED_NUMBER "INTERFACE_DEFECT_REPORT"."COMPLETED_NUMBER"%type,
p_OVERRIDE_MDDR_AUTO "INTERFACE_DEFECT_REPORT"."OVERRIDE_MDDR_AUTO"%type,
p_DISPATCHER_NOTIFIED "INTERFACE_DEFECT_REPORT"."DISPATCHER_NOTIFIED"%type,
p_DO_NOT_ALLOW_CONCESSION "INTERFACE_DEFECT_REPORT"."DO_NOT_ALLOW_CONCESSION"%type,
p_MEL_CALENDAR_DAYS_FLAG "INTERFACE_DEFECT_REPORT"."MEL_CALENDAR_DAYS_FLAG"%type,
p_DEFER_NOTES "INTERFACE_DEFECT_REPORT"."DEFER_NOTES"%type,
p_DEFECT_TYPE "INTERFACE_DEFECT_REPORT"."DEFECT_TYPE"%type,
p_MEL "INTERFACE_DEFECT_REPORT"."MEL"%type,
p_RESOLUTION_CATEGORY "INTERFACE_DEFECT_REPORT"."RESOLUTION_CATEGORY"%type,
p_RESOLVED_BY "INTERFACE_DEFECT_REPORT"."RESOLVED_BY"%type,
p_RESOLVED_DATE "INTERFACE_DEFECT_REPORT"."RESOLVED_DATE"%type,
p_RESOLUTION_DESCRIPTION "INTERFACE_DEFECT_REPORT"."RESOLUTION_DESCRIPTION"%type,
p_DIS_NOT_RESOLUTION "INTERFACE_DEFECT_REPORT"."DISPATCHER_NOTIFIED_RESOLUTION"%type,
p_RESOLVED_LOCATION "INTERFACE_DEFECT_REPORT"."RESOLVED_LOCATION"%type,
p_FAULT_CONFIRM "INTERFACE_DEFECT_REPORT"."FAULT_CONFIRM"%type,
p_REPORTED_BY "INTERFACE_DEFECT_REPORT"."REPORTED_BY"%type,
p_SDR "INTERFACE_DEFECT_REPORT"."SDR"%type,
p_DEFECT_GATE "INTERFACE_DEFECT_REPORT"."DEFECT_GATE"%type,
p_AUTO_GENERATE_DEFECT "INTERFACE_DEFECT_REPORT"."AUTO_GENERATE_DEFECT"%type,
p_INTERFACE_EXTERNAL_REFERENCE "INTERFACE_DEFECT_REPORT"."INTERFACE_EXTERNAL_REFERENCE"%type,
--36077
p_PARAGRAPH "INTERFACE_DEFECT_REPORT"."PARAGRAPH"%type,
p_DELAY "INTERFACE_DEFECT_REPORT"."DELAY"%type,
p_WO "INTERFACE_DEFECT_REPORT"."WO"%type ,
p_DEFECT_CATEGORY "INTERFACE_DEFECT_REPORT"."DEFECT_CATEGORY"%type )

;

-- ------------------------------------------
-- Validate a defect record
procedure validateDefect(t_interface_audit in out "INTERFACE_AUDIT"%ROWTYPE,
t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE,
t_defect_report in out "DEFECT_REPORT"%ROWTYPE)
;
-- ---------------------------------------
-- Update a defect record in Trax
procedure updateDefect
(t_defect in out "INTERFACE_DEFECT_REPORT"%rowtype)
;

-- ---------------------------------------
-- Add/Update a defect record to/in Trax
procedure setDefect
(t_defect in out "INTERFACE_DEFECT_REPORT"%rowtype)
;



procedure extractDefect(
  t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE,
  t_interface_data in "INTERFACE_DATA"%ROWTYPE,
  t_interface_audit in out"INTERFACE_AUDIT"%ROWTYPE
 ) ;


procedure recordErrorXML(
    c_XML_error IN OUT CLOB,
    xml_error_item IN CLOB,
    s_error_message IN VARCHAR2 ) ;

procedure reportErrorXML(
    t_interface_audit IN OUT "INTERFACE_AUDIT"%ROWTYPE,
    c_XML_error IN OUT CLOB );



--Procedure to be called to add a defect to the table
procedure add( t_interface_data in "INTERFACE_DATA"%ROWTYPE ) ;



------------------------------------------------------------------------
-- Add or Update a defect record to/in Trax
procedure setDefect
(p_DEFECT "INTERFACE_DEFECT_REPORT"."DEFECT"%type,
p_DEFECT_ITEM "INTERFACE_DEFECT_REPORT"."DEFECT_ITEM"%type,
p_AC "INTERFACE_DEFECT_REPORT"."AC"%type,
p_CHAPTER "INTERFACE_DEFECT_REPORT"."CHAPTER"%type,
p_SECTION "INTERFACE_DEFECT_REPORT"."SECTION"%type,
p_FLIGHT "INTERFACE_DEFECT_REPORT"."FLIGHT"%type,
p_FLIGHT_PHASE "INTERFACE_DEFECT_REPORT"."FLIGHT_PHASE"%type,
p_DEFECT_DESCRIPTION "INTERFACE_DEFECT_REPORT"."DEFECT_DESCRIPTION"%type,
p_STATION "INTERFACE_DEFECT_REPORT"."STATION"%type,
p_MODIFIED_BY "INTERFACE_DEFECT_REPORT"."MODIFIED_BY"%type,
p_MODIFIED_DATE "INTERFACE_DEFECT_REPORT"."MODIFIED_DATE"%type,
p_DEFECT_DATE "INTERFACE_DEFECT_REPORT"."REPORTED_DATE"%type,
p_MDDR "INTERFACE_DEFECT_REPORT"."MDDR"%type,
p_DEFER "INTERFACE_DEFECT_REPORT"."DEFER"%type,
p_DEFER_BY "INTERFACE_DEFECT_REPORT"."DEFER_BY"%type,
p_DEFER_TO_DATE "INTERFACE_DEFECT_REPORT"."DEFER_TO_DATE"%type,
p_DEFER_DATE "INTERFACE_DEFECT_REPORT"."DEFER_DATE"%type,
p_MEL_NUMBER "INTERFACE_DEFECT_REPORT"."MEL_NUMBER"%type,
p_DEFER_CATEGORY "INTERFACE_DEFECT_REPORT"."DEFER_CATEGORY"%type,
p_SCHEDULE_HOURS "INTERFACE_DEFECT_REPORT"."SCHEDULE_HOURS"%type,
p_SCHEDULE_CYCLES "INTERFACE_DEFECT_REPORT"."SCHEDULE_CYCLES"%type,
p_SCHEDULE_DAYS "INTERFACE_DEFECT_REPORT"."SCHEDULE_DAYS"%type,
p_DEFER_TO_NEXT_EC "INTERFACE_DEFECT_REPORT"."DEFER_TO_NEXT_EC"%type,
p_SKILL "INTERFACE_DEFECT_REPORT"."SKILL"%type,
p_MAN_HOURS "INTERFACE_DEFECT_REPORT"."MAN_HOURS"%type,
p_MAN_REQUIRED "INTERFACE_DEFECT_REPORT"."MAN_REQUIRED"%type,
p_CAPABILITY_AREA "INTERFACE_DEFECT_REPORT"."CAPABILITY_AREA"%type,
p_PLAN_DEFECT "INTERFACE_DEFECT_REPORT"."PLAN_DEFECT"%type,
p_REPEAT_NUMBER "INTERFACE_DEFECT_REPORT"."REPEAT_NUMBER"%type,
p_COMPLETED_NUMBER "INTERFACE_DEFECT_REPORT"."COMPLETED_NUMBER"%type,
p_OVERRIDE_MDDR_AUTO "INTERFACE_DEFECT_REPORT"."OVERRIDE_MDDR_AUTO"%type,
p_DISPATCHER_NOTIFIED "INTERFACE_DEFECT_REPORT"."DISPATCHER_NOTIFIED"%type,
p_DO_NOT_ALLOW_CONCESSION "INTERFACE_DEFECT_REPORT"."DO_NOT_ALLOW_CONCESSION"%type,
p_MEL_CALENDAR_DAYS_FLAG "INTERFACE_DEFECT_REPORT"."MEL_CALENDAR_DAYS_FLAG"%type,
p_DEFER_NOTES "INTERFACE_DEFECT_REPORT"."DEFER_NOTES"%type,
p_DEFECT_TYPE "INTERFACE_DEFECT_REPORT"."DEFECT_TYPE"%type,
p_MEL "INTERFACE_DEFECT_REPORT"."MEL"%type,
p_RESOLUTION_CATEGORY "INTERFACE_DEFECT_REPORT"."RESOLUTION_CATEGORY"%type,
p_RESOLVED_BY "INTERFACE_DEFECT_REPORT"."RESOLVED_BY"%type,
p_RESOLVED_DATE "INTERFACE_DEFECT_REPORT"."RESOLVED_DATE"%type,
p_RESOLUTION_DESCRIPTION "INTERFACE_DEFECT_REPORT"."RESOLUTION_DESCRIPTION"%type,
p_DIS_NOT_RESOLUTION "INTERFACE_DEFECT_REPORT"."DISPATCHER_NOTIFIED_RESOLUTION"%type,
p_RESOLVED_LOCATION "INTERFACE_DEFECT_REPORT"."RESOLVED_LOCATION"%type,
p_FAULT_CONFIRM "INTERFACE_DEFECT_REPORT"."FAULT_CONFIRM"%type,
p_REPORTED_BY "INTERFACE_DEFECT_REPORT"."REPORTED_BY"%type,
p_SDR "INTERFACE_DEFECT_REPORT"."SDR"%type,
p_DEFECT_GATE "INTERFACE_DEFECT_REPORT"."DEFECT_GATE"%type,
p_AUTO_GENERATE_DEFECT "INTERFACE_DEFECT_REPORT"."AUTO_GENERATE_DEFECT"%type,
p_INTERFACE_EXTERNAL_REFERENCE "INTERFACE_DEFECT_REPORT"."INTERFACE_EXTERNAL_REFERENCE"%type,
--36077
p_PARAGRAPH "INTERFACE_DEFECT_REPORT"."PARAGRAPH"%type,
p_DELAY "INTERFACE_DEFECT_REPORT"."DELAY"%type,
p_WO "INTERFACE_DEFECT_REPORT"."WO"%type,
p_DEFECT_CATEGORY "INTERFACE_DEFECT_REPORT"."DEFECT_CATEGORY"%type )
;

-- ---------------------------------------
-- Export a defect record in Trax
procedure exportDefect
(t_defect_report in out "DEFECT_REPORT"%rowtype, t_interface_audit in out "INTERFACE_AUDIT" %rowtype)
;

-- ---------------------------------------
-- Export a defect troubleshooting record in Trax
procedure exportDefectTroubleShooting
(t_drt IN OUT "INTERFACE_DEFECT_TROUBLESHOOT"%rowtype, t_interface_audit in out "INTERFACE_AUDIT" %ROWTYPE);

-- ---------------------------------------
-- Export AC in out of service header record in Trax
procedure exportACINOUT_SRV_HDR
(t_acinout in out "AC_OUT_OF_SERVICE"%rowtype,
t_interface_audit in out "INTERFACE_AUDIT" %rowtype)
;

-- ---------------------------------------
-- Export AC in out of service detail record in Trax
procedure exportACINOUT_SRV_DTL
(t_acinout in out "AC_OUT_OF_SERVICE_DETAIL"%rowtype,
t_interface_audit in out "INTERFACE_AUDIT" %rowtype)
;
-- ---------------------------------------
-- Update AC Status
procedure updateACStatus(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE, service_no number)
;
-- ---------------------------------------
-- Update AC Times
procedure updateACTimes(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE)
;

-- ---------------------------------------
-- Get flight status
function getFlightStatus(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE, service_no number)
return varchar2;

-- ----------------------------------
-- Put AC back in service
procedure PutACInService(s_ac "AC_MASTER"."AC" %type)
;

-- --------------------------------
FUNCTION get_Defect_DEFER_DUE_DATE( t_DR IN OUT DEFECT_REPORT%ROWTYPE ) RETURN DATE;

--*******************************************
-- Log 111926 - Jing Huang 2010-09-10
--*******************************************

	Function queryRecords (
	  p_status varchar2,
	  p_ac varchar2,
	  p_only_Unsent_Mel_Items varchar2,
	  p_only_Mel_Items varchar2,
	  p_sabre_Allow_Mel varchar2,
	  p_sabre_Allow_Cdl varchar2,
	  p_sabre_Allow_Gmm varchar2,
	  p_get_only_unsent_records varchar2,
	  p_defect varchar2,
	  p_only_non_mel_items varchar2,
	  p_defer_category varchar2,
    p_only_mddr_items varchar2 default 'N', 
    p_max_records number default 0,
    p_linked_mddr varchar2 default 'N'
	) return refCursor;

	Function getQueryRecords(
	  l_message_id number,
	  p_get_only_unsent_records varchar2,
    p_max_records number default 0
	) Return refCursor;

	function getTroubleShootings(
	  p_defect_type in DEFECT_REPORT.DEFECT_TYPE%TYPE,
	  p_defect in DEFECT_REPORT.DEFECT%TYPE,
	  p_defect_item in DEFECT_REPORT.DEFECT_ITEM%TYPE
	) RETURN XMLType;

	FUNCTION getDefectMELXML(
	  p_defect_mel_number in DEFECT_REPORT.MEL_NUMBER%TYPE,
    p_defect_mel_sub in DEFECT_REPORT.MEL_SUB%TYPE,
	  p_ac in DEFECT_REPORT.AC%TYPE)
	RETURN XMLType;

	Function createDefectXML(
	  p_defect_type VARCHAR2,
	  p_defect VARCHAR2,
	  p_defect_item NUMBER,
	  p_interface_transaction IN NUMBER default null,
	  p_transactionMethod IN VARCHAR2 default null,
    l_process_times in number default 0,
	  dt_forecasted_due_date in DATE default null,
	  d_due_at_ac_hours in number default null,
	  d_due_at_ac_cycles in number default null,
	  dt_defer_to_date in date default null,
    d_schedule_days in number default null,
    v_due_control in "PLANNING"."DUE_CONTROL"%TYPE default null,
    v_has_linked_mddr varchar2 default 'N')
	RETURN XMLType;

------------------------------------------------------------------------------
	----- Procedure to export a Defect to XML
	PROCEDURE ExportDefectXML(
	  t_interface_audit in out nocopy INTERFACE_AUDIT%ROWTYPE,
	  v_DefectReport   in DEFECT_REPORT%ROWTYPE,
    l_process_times in number,
    dt_forcasting_due_date in date,
    d_due_at_ac_hours in number,
    d_due_at_ac_cycles in number,
    dt_defer_to_date in date,
    d_schedule_days in number,
    v_due_control in "PLANNING"."DUE_CONTROL"%TYPE,
    p_linked_mddr varchar2 default 'N');

	Function buildDefectQuery(
	  p_status varchar2,
	  p_ac varchar2,
	  p_only_Unsent_Mel_Items varchar2,
	  p_only_Mel_Items varchar2,
	  p_sabre_Allow_Mel varchar2,
	  p_sabre_Allow_Cdl varchar2,
	  p_sabre_Allow_Gmm varchar2,
	  p_get_only_unsent_records varchar2,
	  p_defect varchar2,
	  p_only_non_mel_items varchar2,
	  p_defer_category varchar2,
    p_only_mddr_items varchar2 default 'N', 
    p_max_records number default 0
	) return varchar2 ;

	function getTransactionMethodHRZ(p_defect_report in DEFECT_REPORT%ROWTYPE, p_defect_report_prev in
	XMLType) RETURN varchar2;

	Function getXML(l_transaction number, l_transaction_item number)
	return XMLType;

	-- --------------------------------
	-- delete transactions
	procedure deleteAuditNonUnsent(messageId number);

	-- --------------------------------
	-- get interface transaction ranked l_recent descendingly
	FUNCTION getInterfaceTransaction(
		v_defect_type in "DEFECT_REPORT"."DEFECT_TYPE"%TYPE,
		v_defect in "DEFECT_REPORT"."DEFECT"%TYPE,
		l_defect_item in "DEFECT_REPORT"."DEFECT_ITEM"%TYPE,
    l_position in number,
    l_current_transaction in number) return "INTERFACE_AUDIT".TRANSACTION%TYPE;

  -- --------------------------------
	-- delete defect report interface audit records - only keep the most l_recent records
	procedure deletePreviousTransaction(
    v_defect_type in "DEFECT_REPORT"."DEFECT_TYPE"%TYPE,
    v_defect in "DEFECT_REPORT"."DEFECT"%TYPE,
    v_defect_item in "DEFECT_REPORT"."DEFECT_ITEM"%TYPE,
    l_recent in number,
    l_current_transaction in number);

  -- --------------------------------
	-- get Defect Due At times
  /*
  procedure getDefectDueAt(
    v_defect_type in "PLANNING"."DEFECT_TYPE"%TYPE,
    v_defect in "PLANNING"."DEFECT"%TYPE,
    l_defect_item in "PLANNING"."DEFECT_ITEM"%TYPE,
    dt_forcasted_due_date out nocopy date,
    d_due_at_ac_hours out nocopy number,
    d_due_at_ac_cycles out nocopy number,
    dt_due_at_date out nocopy date);
  */
  procedure getDefectDueAt(
    v_defect_type in "PLANNING"."DEFECT_TYPE"%TYPE,
    v_defect in "PLANNING"."DEFECT"%TYPE,
    l_defect_item in "PLANNING"."DEFECT_ITEM"%TYPE,
    dt_forcasted_due_date out nocopy date,
    d_due_at_ac_hours out nocopy number,
    d_due_at_ac_cycles out nocopy number,
    dt_defer_to_date out nocopy date,
    d_schedule_days out nocopy number,
    v_due_control out nocopy "PLANNING"."DUE_CONTROL"%TYPE
    );

  -- --------------------------------
	-- get defect xml message at the position l_position descendingly
  Function getDefectXML(
    v_defect_type DEFECT_REPORT.DEFECT_TYPE%TYPE,
    v_defect DEFECT_REPORT.DEFECT%TYPE,
    l_defect_item DEFECT_REPORT.DEFECT_ITEM%TYPE,
    l_position number,
    l_current_transaction number)
	return XMLType;

  -- --------------------------------
  -- get concession xmls
  function getConcessions(
	  p_defect_type in DEFECT_REPORT.DEFECT_TYPE%TYPE,
	  p_defect in DEFECT_REPORT.DEFECT%TYPE,
	  p_defect_item in DEFECT_REPORT.DEFECT_ITEM%TYPE
	) RETURN XMLType;


--*******************************************
-- End Log 111926
--*******************************************

  --Get the list of all defects linked by mddr
function getLinkedMddrDefectsXml( p_defect_type "DEFECT_REPORT"."DEFECT_TYPE"%TYPE, 
                                    p_defect "DEFECT_REPORT"."DEFECT"%TYPE,
                                    p_defect_item "DEFECT_REPORT"."DEFECT_ITEM"%TYPE,
                                    p_mddr "DEFECT_REPORT"."MDDR"%TYPE,
                                    b_has_linked_mddr varchar2 default 'N')return xmltype;



PROCEDURE setAuditDefectReport
(
  xmlDefect varchar2 ,
  transaction_type VARCHAR2 , 
  s_employeeId varchar2
);
   
   
   
end pkg_iface_defect_reports
;


/

create or replace PACKAGE BODY "PKG_IFACE_DEFECT_REPORTS" as

 s_error_message VARCHAR2(1000);

  -- --------------------------------
	-- private methods
	-- --------------------------------

	-- --------------------------------
	-- unmark Defect Report if there are unsent trouble shooting items
	procedure unmarkByDefectTroubleShooting;


	-- --------------------------------
	-- unmark defect report if there are unsent concessions
	procedure unmarkDefectFromConcession;

-- ------------------------------------
PROCEDURE addDefectToDoc(doc in out xmldom.DOMDocument, root_node in out xmldom.DOMNode,
        v_DefectReport   in DEFECT_REPORT%ROWTYPE)
is
	root_elmt xmldom.DOMElement;
	item_node xmldom.DOMNode;
	item_text xmldom.DOMText;
	item_elmt xmldom.DOMElement;

begin
	pkg_interface.addtextelement(doc,root_node,'defect_Type',v_DefectReport."DEFECT_TYPE");
	pkg_interface.addtextelement(doc,root_node,'defect',v_DefectReport."DEFECT");
	pkg_interface.addtextelement(doc,root_node,'defect_Item',v_DefectReport."DEFECT_ITEM");
	pkg_interface.addtextelement(doc,root_node,'defect_Description',v_DefectReport."DEFECT_DESCRIPTION");
	pkg_interface.addtextelement(doc,root_node,'AC',v_DefectReport."AC");
	pkg_interface.addtextelement(doc,root_node,'chapter',v_DefectReport."CHAPTER");
	pkg_interface.addtextelement(doc,root_node,'section',v_DefectReport."SECTION");
	pkg_interface.addtextelement(doc,root_node,'flight',v_DefectReport."FLIGHT");
	pkg_interface.addtextelement(doc,root_node,'flight_Phase',v_DefectReport."FLIGHT_PHASE");
	pkg_interface.addtextelement(doc,root_node,'defer_To_Date',PKG_INTERFACE.GETXMLDATESTRING(v_DefectReport."DEFER_TO_DATE"));
	pkg_interface.addtextelement(doc,root_node,'station',v_DefectReport."STATION");
	pkg_interface.addtextelement(doc,root_node,'defer_Date',PKG_INTERFACE.GETXMLDATESTRING( pkg_application_function.GETCOMBINEDDATE( v_DefectReport."DEFER_DATE", v_DefectReport."DEFER_HOUR", v_DefectReport."DEFER_MINUTE")));
	pkg_interface.addtextelement(doc,root_node,'modified_By',v_DefectReport."MODIFIED_BY");
	pkg_interface.addtextelement(doc,root_node,'MDDR',v_DefectReport."MDDR");
	pkg_interface.addtextelement(doc,root_node,'defer',v_DefectReport."DEFER");
	pkg_interface.addtextelement(doc,root_node,'defer_By',v_DefectReport."DEFER_BY");
	pkg_interface.addtextelement(doc,root_node,'MEL_Number',v_DefectReport."MEL_NUMBER");
	pkg_interface.addtextelement(doc,root_node,'defer_Category',v_DefectReport."DEFER_CATEGORY");
	pkg_interface.addtextelement(doc,root_node,'schedule_Hours',v_DefectReport."SCHEDULE_HOURS");
	pkg_interface.addtextelement(doc,root_node,'schedule_Cycles',v_DefectReport."SCHEDULE_CYCLES");
	pkg_interface.addtextelement(doc,root_node,'schedule_Days',v_DefectReport."SCHEDULE_DAYS");
	pkg_interface.addtextelement(doc,root_node,'defer_To_Next_EC',v_DefectReport."DEFER_TO_NEXT_EC");
	pkg_interface.addtextelement(doc,root_node,'skill',v_DefectReport."SKILL");
	pkg_interface.addNumberelement(doc,root_node,'man_Hours',v_DefectReport."MAN_HOURS");
	pkg_interface.addtextelement(doc,root_node,'man_Required',v_DefectReport."MAN_REQUIRED");
	pkg_interface.addtextelement(doc,root_node,'capability_Area',v_DefectReport."CAPABILITY_AREA");
	pkg_interface.addtextelement(doc,root_node,'repeat_Number',v_DefectReport."REPEAT_NUMBER");
	pkg_interface.addtextelement(doc,root_node,'completed_Number',v_DefectReport."COMPLETED_NUMBER");
	pkg_interface.addtextelement(doc,root_node,'dispatcher_Notified',v_DefectReport."DISPATCHER_NOTIFIED");
	pkg_interface.addtextelement(doc,root_node,'do_Not_Allow_Concession',v_DefectReport."NOT_DO_ALLOW_CONCESSION");
	pkg_interface.addtextelement(doc,root_node,'mel_Calendar_Days_Flag',v_DefectReport."MEL_CALENDAR_DAYS_FLAG");
	pkg_interface.addtextelement(doc,root_node,'defer_Notes',v_DefectReport."DEFER_NOTES");
	pkg_interface.addtextelement(doc,root_node,'MEL',v_DefectReport."MEL");
	pkg_interface.addtextelement(doc,root_node,'resolution_Category',v_DefectReport."RESOLUTION_CATEGORY");
	pkg_interface.addtextelement(doc,root_node,'resolved_By',v_DefectReport."RESOLVED_BY");
	pkg_interface.addtextelement(doc,root_node,'resolved_Date',PKG_INTERFACE.GETXMLDATESTRING(v_DefectReport."RESOLVED_DATE"));
	pkg_interface.addtextelement(doc,root_node,'resolution_Description',v_DefectReport."RESOLUTION_DESCRIPTION");
	pkg_interface.addtextelement(doc,root_node,'dispatcher_Notified_Resolution',v_DefectReport."DISPATCHER_NOTIFIED_RESOLUTION");
	pkg_interface.addtextelement(doc,root_node,'resolved_Location',v_DefectReport."RESOLVED_LOCATION");
	pkg_interface.addtextelement(doc,root_node,'fault_Confirm',v_DefectReport."FAULT_CONFIRM");
	pkg_interface.addtextelement(doc,root_node,'reported_By',v_DefectReport."REPORTED_BY");
	pkg_interface.addtextelement(doc,root_node,'SDR',v_DefectReport."SDR");
	pkg_interface.addtextelement(doc,root_node,'defect_Gate',v_DefectReport."DEFECT_GATE");
	pkg_interface.addtextelement(doc,root_node,'internal_Capability',SUBSTR(v_DefectReport."INTERNAL_CAPABILITY",1,1)); --CHANGE YES => Y AND NO => N
	pkg_interface.addtextelement(doc,root_node,'reported_Date',PKG_INTERFACE.GETXMLDATESTRING(v_DefectReport."REPORTED_DATE"));
	pkg_interface.addtextelement(doc,root_node,'cador_Damage',SUBSTR(v_DefectReport."CADOR_DAMAGE",1,1)); --CHANGE YES => Y AND NO => N
  pkg_interface.addtextelement(doc,root_node,'mel_Sub', v_DefectReport."MEL_SUB");  -- Log 84840

	-- Child node (FROM DEFECT_MEL_MASTER)
	DECLARE
		v_defect_mel_master DEFECT_MEL_MASTER%ROWTYPE;
	    t_dmmi "DEFECT_MEL_MASTER_ITEMS"%ROWTYPE;
	    l_dmmi_count number;
	    cursor c_dmmi is
	    SELECT *
	    FROM "DEFECT_MEL_MASTER_ITEMS" D
	    WHERE D."AC_TYPE"   = v_defect_mel_master."AC_TYPE"
	    AND D."AC_SERIES"   = v_defect_mel_master."AC_SERIES"
	    AND D."MEL_NUMBER"  = v_defect_mel_master."MEL_NUMBER"
	    AND D."MEL_SUB"     = v_defect_mel_master."MEL_SUB"
	    ;
BEGIN
		SELECT	*
		INTO	v_defect_mel_master
		FROM	DEFECT_MEL_MASTER
		WHERE	1 = 1
      AND AC_TYPE     = (SELECT AC_TYPE from AC_MASTER where AC = v_DefectReport."AC" )
			AND	AC_SERIES   = (SELECT AC_SERIES from AC_MASTER where AC = v_DefectReport."AC" )
			AND	MEL_NUMBER  = v_DefectReport."MEL_NUMBER"
      AND MEL_SUB     = v_DefectReport."MEL_SUB";     -- Log 84840

		item_elmt := xmldom.createElement(doc, 'Defect_Rep_Outgoing_MEL_Master');
		item_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

		pkg_interface.addtextelement(doc,item_node,'AC_Type',v_defect_mel_master."AC_TYPE");
		pkg_interface.addtextelement(doc,item_node,'AC_Series',v_defect_mel_master."AC_SERIES");
    pkg_interface.addtextelement(doc,item_node,'MEL_Number',v_defect_mel_master."MEL_NUMBER");
    pkg_interface.addtextelement(doc,item_node,'send_Alert',v_defect_mel_master."SEND_ALERT");
    pkg_interface.addtextelement(doc,item_node,'warning_Create',v_defect_mel_master."WARNING_CREATE");
    pkg_interface.addtextelement(doc,item_node,'warning_Resolve',v_defect_mel_master."WARNING_RESOLVE");
		pkg_interface.addtextelement(doc,item_node,'MEL_Sub',v_defect_mel_master."MEL_SUB");
		pkg_interface.addtextelement(doc,item_node,'description',v_defect_mel_master."DESCRIPTION");
		pkg_interface.addtextelement(doc,item_node,'MEL',v_defect_mel_master."MEL");
		pkg_interface.addtextelement(doc,item_node,'restriction_Operation',v_defect_mel_master."RESTRICATION_OPERATION");
		pkg_interface.addtextelement(doc,item_node,'restriction_Maintenance',v_defect_mel_master."RESTRICATION_MAINTENANCE");
		pkg_interface.addtextelement(doc,item_node,'MEL_Hours',v_defect_mel_master."MEL_HOURS");
		pkg_interface.addtextelement(doc,item_node,'MEL_Cycles',v_defect_mel_master."MEL_CYCLES");
		pkg_interface.addtextelement(doc,item_node,'MEL_Days',v_defect_mel_master."MEL_DAYS");
    pkg_interface.addtextelement(doc,item_node,'modified_By',v_defect_mel_master."MODIFIED_BY");
    pkg_interface.addtextelement(doc,item_node,'MEL_Calendar_Days_Flag',SUBSTR(v_defect_mel_master."MEL_CALENDAR_DAYS_FLAG",1,1));
		pkg_interface.addtextelement(doc,item_node,'created_By', v_defect_mel_master."CREATED_BY");
		pkg_interface.addtextelement(doc,item_node,'created_Date',PKG_INTERFACE.GETXMLDATESTRING(v_defect_mel_master."CREATED_DATE"));
    pkg_interface.addtextelement(doc,item_node,'cat',v_defect_mel_master."MEL");
		pkg_interface.addtextelement(doc,item_node,'cat_rating', v_defect_mel_master."CAT_RATING");
		if v_defect_mel_master."RVSM" = 'Y' then
      pkg_interface.addtextelement(doc,item_node,'rvsm', 'true');
    else
      pkg_interface.addtextelement(doc,item_node,'rvsm', 'false');
    end if;
		-- Get MEL Items
    item_elmt := xmldom.createElement(doc, 'MEL_Master_Items');
		item_node := xmldom.appendChild(item_node, xmldom.makeNode(item_elmt));
		open c_dmmi;
		loop
			fetch c_dmmi into t_dmmi;
			exit when c_dmmi%notfound;
			item_elmt := xmldom.createElement(doc, 'MEL_Master_Item');
			item_node := xmldom.appendChild(item_node, xmldom.makeNode(item_elmt));
			pkg_interface.addNumberelement(doc,item_node,'mel_Master_Item_Number', t_dmmi."ITEM");
			pkg_interface.addTextelement(doc,item_node,'remarks', t_dmmi."REMARKS");
			item_node := xmldom.getparentNode(item_node);
		end loop;
                --pkg_interface.addtextelement(doc,item_node,'restriction_ETOPS',v_defect_mel_master."RESTRICATION_ETOPS");
		item_node := xmldom.getparentNode(item_node);
    pkg_interface.addtextelement(doc,item_node,'restriction_ETOPS',v_defect_mel_master."RESTRICATION_ETOPS");
    EXCEPTION
		WHEN OTHERS THEN
			NULL;
	END;


	declare
		t_wo "WO"%ROWTYPE;
	BEGIN
		SELECT *
		INTO t_wo
		FROM "WO" W
		WHERE 1=1
		AND W."WO" = v_DefectReport."WO"
		;
		item_elmt := xmldom.createElement(doc, 'Work_Order_Outgoing_Element');
		item_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));
		pkg_iface_production_wo.Add_WO_Header_To_Doc(doc, item_node, t_wo);
	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		null;
	end;

	declare
		t_ac_master "AC_MASTER"%ROWTYPE;
	begin
		SELECT * INTO t_ac_master
		FROM "AC_MASTER" A
		WHERE A."AC" = v_DefectReport."AC"
		;
		pkg_interface.addtextelement(doc,root_node,'ac_Type', t_ac_master."AC_TYPE");
		pkg_interface.addtextelement(doc,root_node,'ac_Series', t_ac_master."AC_SERIES");
	EXCEPTION
	WHEN NO_DATA_FOUND THEN
		NULL;
	END;
        pkg_interface.addtextelement(doc,root_node,'ref_Seq_Num', v_DefectReport."LINKING_SEQ");
        pkg_interface.addnumberelement(doc,root_node,'sabre_Control_Number', v_DefectReport."SABRE_MESSAGE_NUMBER");
        -- Troubleshooting
        DECLARE
          N_COUNT NUMBER;
        BEGIN
          SELECT  COUNT(*)
          INTO    N_COUNT
          FROM    DEFECT_REPORT_TROUBLE_SHOOTING
          WHERE   DEFECT_TYPE = v_DefectReport."DEFECT_TYPE" AND
                  DEFECT = v_DefectReport."DEFECT" AND
                  DEFECT_ITEM = v_DefectReport."DEFECT_ITEM";

          IF N_COUNT = 0 THEN
            GOTO SKIP_TROUBLESHOOTING;
          END IF;

          item_elmt := xmldom.createElement(doc, 'troubleshootings');
          item_node := xmldom.appendChild(root_node, xmldom.makeNode(item_elmt));

          FOR CUR_TS IN (
          SELECT  *
          FROM    DEFECT_REPORT_TROUBLE_SHOOTING
          WHERE   DEFECT_TYPE = v_DefectReport."DEFECT_TYPE" AND
                  DEFECT      = v_DefectReport."DEFECT" AND
                  DEFECT_ITEM = v_DefectReport."DEFECT_ITEM"
          ORDER BY TROUBLE_SHOOTING_ITEM)
          LOOP
            item_elmt := xmldom.createElement(doc, 'troubleshooting');
            item_node := xmldom.appendChild(item_node, xmldom.makeNode(item_elmt));

            pkg_interface.addNumberElement( doc, item_node, 'item', CUR_TS."TROUBLE_SHOOTING_ITEM" );
            pkg_interface.addTextElement( doc, item_node, 'station', CUR_TS."STATION" );
            pkg_interface.addTextElement( doc, item_node, 'troubleshooting_By', CUR_TS."TROUBLE_SHOOTING_BY" );
            pkg_interface.addDateElement( doc, item_node, 'troubleshooting_Date', PKG_APPLICATION_FUNCTION.getCombinedDate(CUR_TS."TROUBLE_SHOOTING_ON",CUR_TS."TROUBLE_SHOOTING_HOUR",CUR_TS."TROUBLE_SHOOTING_MINUTE") ); -- NEEDS WORK
            pkg_interface.addTextElement( doc, item_node, 'status', CUR_TS."STATUS" );
            pkg_interface.addTextElement( doc, item_node, 'category', CUR_TS."TROUBLE_SHOOTING_CODE" );
            pkg_interface.addTextElement( doc, item_node, 'ac_Log', CUR_TS."TROUBLE_SHOOTING_DEFECT" );
            pkg_interface.addTextElement( doc, item_node, 'ac_Log_Item', CUR_TS."TROUBLE_SHOOTING_DEFECT_ITEM" );
            pkg_interface.addTextElement( doc, item_node, 'description', CUR_TS."TROUBLE_SHOOTING_TEXT" );
            pkg_interface.addTextElement( doc, item_node, 'manual', CUR_TS."CONTROL_CATEGORY" );
            pkg_interface.addTextElement( doc, item_node, 'reference', CUR_TS."REFERENCE_CODE" );
            IF NVL(CUR_TS."REQUIRED_INSPECTION_ITEM",'NO') = 'NO' THEN
              pkg_interface.addTextElement( doc, item_node, 'rii', 'false');
            ELSE
              pkg_interface.addTextElement( doc, item_node, 'rii', 'true');
            END IF;
            pkg_interface.addTextElement( doc, item_node, 'rii_By', CUR_TS."REQUIRED_INSPECTION_BY" );

            item_node := xmldom.getparentNode(item_node);
          END LOOP;

          item_node := xmldom.getparentNode(item_node);
          <<SKIP_TROUBLESHOOTING>>
          pkg_interface.addtextelement(doc,root_node,'modified_Date', PKG_INTERFACE.GETXMLDATESTRING(v_DefectReport."MODIFIED_DATE"));
          pkg_interface.addtextelement(doc,root_node,'authorized_Date', PKG_INTERFACE.GETXMLDATESTRING(v_DefectReport."AUTHORIZATION_DATE"));
          pkg_interface.addTextElement( doc, root_node, 'mis', v_DefectReport."MIS" );
          pkg_interface.addTextElement( doc, root_node, 'ifsd', v_DefectReport."I_F_S_D" );
          NULL;
        END;

end addDefectToDoc;
------------------------------------------------------------------------------
----- Procedure to export a Defect to XML
PROCEDURE ExportDefectXML(
	t_interface_audit in out INTERFACE_AUDIT%ROWTYPE,
  v_DefectReport    in DEFECT_REPORT%ROWTYPE
  )
is
  t_interface_data    INTERFACE_DATA%ROWTYPE;
  XML_CLOB            CLOB;
  HEAD_XML            XMLType;
  root_node           xmldom.DOMNode;
	doc                 xmldom.DOMDocument;
	root_elmt           xmldom.DOMElement;
	item_node           xmldom.DOMNode;
	item_text           xmldom.DOMText;
	item_elmt           xmldom.DOMElement;
  ex_defect_exception EXCEPTION;
  v_exception_msg     INTERFACE_AUDIT.EXCEPTION_DETAIL%TYPE;
BEGIN
	XML_CLOB := 'NOT NULL';
  PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'OUT', t_interface_audit."TRANSACTION_METHOD", 'TRAX_DEFECT_XML');
  t_interface_data."TRANSACTION"    := t_interface_audit."TRANSACTION";
  t_interface_data.TRANSACTION_ITEM := 1;
  doc                               := xmldom.newDOMDocument;
  root_node                         := xmldom.makeNode(doc);

--        root_elmt := xmldom.createElement(doc, 'DefectReport:Defect_Report_Outgoing_Element');
  root_elmt := xmldom.createElement(doc, 'Defect_Report_Outgoing_Element');
--        xmldom.setAttribute(root_elmt, 'xmlns:DefectReport', 'http://trax.aero/xml/DefectReport.xsd');
--        xmldom.setAttribute(root_elmt, 'xmlns:traxSys', 'http://trax.aero/xml/TraxSystem.xsd');
--        xmldom.setAttribute(root_elmt, 'xmlns:Defect_MEL_Master', 'http://trax.aero/xml/Defect_MEL_Master.xsd');
--        xmldom.setAttribute(root_elmt, 'xmlns:Production_Scheduled_WO.xsd', 'http://trax.aero/xml/Production_Scheduled_WO.xsd.xsd');
--        xmldom.setAttribute(root_elmt, 'xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
--        xmldom.setAttribute(root_elmt, 'xsi:schemaLocation', 'http://trax.aero/xml/DefectReport.xsd ../xsd/Tech_Records_Defect_Report.xsd http://trax.aero/xml/TraxSystem.xsd TraxSystem.xsd http://trax.aero/xml/Defect_MEL_Master.xsd Defect_MEL_Master.xsd  http://trax.aero/xml/Production_Scheduled_WO.xsd.xsd Production_Scheduled_WO.xsd.xsd ');
  root_node := xmldom.appendChild(root_node, xmldom.makeNode(root_elmt));

  addDefectToDoc(doc, root_node, v_DefectReport);
  pkg_interface.addtextelement(doc,root_node,'transactionMethod',t_interface_audit."TRANSACTION_METHOD");

	-- Write XML
	xmldom.writeToClob(doc, XML_CLOB);
	xmldom.freeDocument(doc);
        t_interface_data."XML_DOCUMENT" := XMLType(XML_CLOB); --XML_DOCUMENT;

        pkg_interface.insertIntoInterfaceData( t_interface_data );
        pkg_interface.transactionNeedsToBeSent(t_interface_audit."TRANSACTION");

EXCEPTION
    WHEN OTHERS THEN
        PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20111, substr(to_char(SQLCODE) || ' ' || SQLERRM,1,1000),
'N');
	    RAISE;
END ExportDefectXML;




----------------------------------------------------------------------------------------
--Get new service no
function getNewServiceNo(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE)
return number is

service_no        number;
service_no_found  number;
cAcinDate         varchar2(50);
cAcoutDate        varchar2(50);
cAcadvDate        varchar2(50);

begin

SELECT COUNT(*)
INTO service_no_found
FROM "AC_OUT_OF_SERVICE"
WHERE "AC_OUT_OF_SERVICE"."AC"            = UPPER(t_defect."AC") and
      "AC_OUT_OF_SERVICE"."FLIGHT_STATUS" = 'N' ;

if service_no_found = 0 then

   SELECT NVL(MAX("AC_OUT_OF_SERVICE"."OUT_SERVICE_NO"),0) + 1
   INTO service_no
   FROM "AC_OUT_OF_SERVICE"
   WHERE "AC_OUT_OF_SERVICE"."AC" = UPPER(t_defect."AC");

   cAcoutDate := TO_CHAR(t_defect."AC_SCHEDULE_OUT_SERVICE_DATE", 'MM/DD/RR');
   cAcinDate  := TO_CHAR(t_defect."AC_SCHEDULE_IN_SERVICE_DATE", 'MM/DD/RR');
   cAcadvDate := TO_CHAR(t_defect."AC_OUT_OF_SVR_ADVISED_DATE", 'MM/DD/RR');

--Insert to AC_OUT_OF_SERVICE
   INSERT INTO "AC_OUT_OF_SERVICE"
          ( "OUT_SERVICE_NO",
           "AC",
           "FLIGHT_STATUS",
           "OUT_OF_SERVICE_STATION",
           "AC_SCHEDULE_OUT_SERVICE_DATE",
           "AC_SCHEDULE_OUT_SERVICE_HOUR",
           "AC_SCHEDULE_OUT_SERVICE_MINUTE",
           "AC_DEFECT_TYPE_OUT_SERVICE",
           "AC_DEFECT_OUT_OF_SERIVE",
           "AC_DEFECT_ITEM_OUT_OF_SERVICE",
           "AC_OUT_OF_SVR_ADVISED_DATE",
           "AC_OUT_OF_SVR_ADVISED_HOUR",
           "AC_OUT_OF_SVR_ADVISED_MINUTE",
           "AC_SCHEDULE_IN_SERVICE_DATE",
           "AC_SCHEDULE_IN_SERVICE_HOUR",
           "AC_SCHEDULE_IN_SERVICE_MINUTE",
           "NOTES",
           "BLOB_NO",
           "DOCUMENT_NO",
           "CREATED_BY",
           "CREATED_DATE",
           "MODIFIED_BY",
           "MODIFIED_DATE" )
  VALUES ( service_no,
           t_defect."AC",
           'N',
           null,
           TO_DATE(cAcoutDate, 'MM/DD/RR'),
           TO_NUMBER(to_char(t_defect."AC_SCHEDULE_OUT_SERVICE_DATE", 'HH24' )),
           TO_NUMBER(to_char(t_defect."AC_SCHEDULE_OUT_SERVICE_DATE", 'MI' )),
           null,
           null,
           null,
           TO_DATE(cAcadvDate, 'MM/DD/RR'),
           TO_NUMBER(to_char(t_defect."AC_OUT_OF_SVR_ADVISED_DATE", 'HH24' )),
           TO_NUMBER(to_char(t_defect."AC_OUT_OF_SVR_ADVISED_DATE", 'MI' )),
           TO_DATE(cAcinDate, 'MM/DD/RR'),
           TO_NUMBER(to_char(t_defect."AC_SCHEDULE_IN_SERVICE_DATE", 'HH24' )),
           TO_NUMBER(to_char(t_defect."AC_SCHEDULE_IN_SERVICE_DATE", 'MI' )),
           null,
           null,
           null,
           'TRAX_IFACE',
           sysdate,
           'TRAX_IFACE',
           sysdate )  ;

   return service_no;

else
  SELECT "AC_OUT_OF_SERVICE"."OUT_SERVICE_NO"
  INTO service_no
  FROM "AC_OUT_OF_SERVICE"
  WHERE "AC_OUT_OF_SERVICE"."AC"            = UPPER(t_defect."AC") and
        "AC_OUT_OF_SERVICE"."FLIGHT_STATUS" = 'N' ;


  return service_no;

end if;

end getNewServiceNo;

------------------------------------------------
--Get AC Service No
function getACServiceNo(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE)
return number is

service_no       number;
service_no_found number;

begin

SELECT COUNT(*)
INTO service_no_found
FROM "AC_OUT_OF_SERVICE"
WHERE ( "AC_OUT_OF_SERVICE"."AC"            = UPPER(t_defect."AC") ) AND
      ( "AC_OUT_OF_SERVICE"."FLIGHT_STATUS" = 'N' );

   if service_no > 0 then

     SELECT "AC_OUT_OF_SERVICE"."OUT_SERVICE_NO"
     INTO service_no
     FROM "AC_OUT_OF_SERVICE"
     WHERE ( "AC_OUT_OF_SERVICE"."AC"            = UPPER(t_defect."AC") ) AND
           ( "AC_OUT_OF_SERVICE"."FLIGHT_STATUS" = 'N' );

   else
      service_no := getNewServiceNo(t_defect);
   end if;

   return service_no;

end getACServiceNo;
------------------------------------------------
--Get Service No for defect
function getServiceNo(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE)
return number is

service_no_found number;
service_no number;

begin

  SELECT COUNT(*)
    INTO service_no_found
    FROM "AC_OUT_OF_SERVICE_DETAIL"
   WHERE ("AC_OUT_OF_SERVICE_DETAIL"."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE")) AND
         ("AC_OUT_OF_SERVICE_DETAIL"."DEFECT"      = UPPER(t_defect."DEFECT"))      AND
         ("AC_OUT_OF_SERVICE_DETAIL"."DEFECT_ITEM" = t_defect."DEFECT_ITEM" )       AND
         ("AC_OUT_OF_SERVICE_DETAIL"."WO"          = 0 );

  --if a service number exists return that number
  if service_no_found > 0 then

      SELECT "AC_OUT_OF_SERVICE_DETAIL"."OUT_SERVICE_NO"
      INTO service_no
      FROM "AC_OUT_OF_SERVICE_DETAIL"
      WHERE ("AC_OUT_OF_SERVICE_DETAIL"."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE")) AND
            ("AC_OUT_OF_SERVICE_DETAIL"."DEFECT"      = UPPER(t_defect."DEFECT"))      AND
            ("AC_OUT_OF_SERVICE_DETAIL"."DEFECT_ITEM" = t_defect."DEFECT_ITEM" )       AND
            ("AC_OUT_OF_SERVICE_DETAIL"."WO"          = 0 );

      return service_no;
   else
      return -1;
   end if;

end getServiceNo;

-------------------------------------------------------
----Get the flight status
function getFlightStatus(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE, service_no number)
return varchar2 is

  t_ac_out_of_service "AC_OUT_OF_SERVICE_DETAIL"%ROWTYPE;
  flight_status_found number;

begin

SELECT count(*)
INTO flight_status_found
FROM "AC_OUT_OF_SERVICE_DETAIL" A
WHERE A."OUT_SERVICE_NO"  = service_no             AND
      A."DEFECT_TYPE"     = t_defect."DEFECT_TYPE" AND
      A."DEFECT"          = t_defect."DEFECT"      AND
      A."DEFECT_ITEM"     = t_defect."DEFECT_ITEM" AND
      A."WO"              = 0;

if flight_status_found > 0 then

   SELECT *
   INTO t_ac_out_of_service
   FROM "AC_OUT_OF_SERVICE_DETAIL" A
   WHERE A."OUT_SERVICE_NO" = service_no             AND
         A."DEFECT_TYPE"    = t_defect."DEFECT_TYPE" AND
         A."DEFECT"         = t_defect."DEFECT"      AND
         A."DEFECT_ITEM"    = t_defect."DEFECT_ITEM" AND
         A."WO"             = 0;

   return t_ac_out_of_service."FLIGHT_STATUS";

else
   return null;
end if;

end getFlightStatus;

--===========================================================================
----Update AC Times
procedure updateACTimes(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE)
is
  out_of_service_found number;
  dt_out               date;
  dt_advised           date;
  dt_est               date;

begin

-- check flight status 'N'
   SELECT COUNT(*)
   INTO out_of_service_found
   FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
   WHERE ACOUT."AC"            = t_defect."AC" AND
         ACOUT."FLIGHT_STATUS" = 'N';

   if out_of_service_found > 0 then

      SELECT MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_OUT_SERVICE_DATE", ACOUT."AC_SCHEDULE_OUT_SERVICE_HOUR", ACOUT."AC_SCHEDULE_OUT_SERVICE_MINUTE" )),
             MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_OUT_OF_SVR_ADVISED_DATE", ACOUT."AC_OUT_OF_SVR_ADVISED_HOUR", ACOUT."AC_OUT_OF_SVR_ADVISED_MINUTE" )),
             MAX(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_IN_SERVICE_DATE", ACOUT."AC_SCHEDULE_IN_SERVICE_HOUR", ACOUT."AC_SCHEDULE_IN_SERVICE_MINUTE" ))
      INTO dt_out, dt_advised, dt_est
      FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
	    WHERE (ACOUT."AC"            = UPPER(t_defect."AC")) AND
            (ACOUT."FLIGHT_STATUS" = 'N') ;


	    UPDATE "AC_MASTER" ACM
	       SET "FLIGHT_STATUS"                  = 'N',
	           "AC_SCHEDULE_OUT_SERVICE_DATE"   = dt_out,
	           "AC_SCHEDULE_OUT_SERVICE_HOUR"   =  TO_NUMBER(to_char(dt_out, 'HH24' )),
             "AC_SCHEDULE_OUT_SERVICE_MINUTE" =  TO_NUMBER(to_char(dt_out, 'MI' )),
             "AC_OUT_OF_SVR_ADVICED_DATE"     = dt_advised,
             "AC_OUT_OF_SVR_ADVICED_HOUR"     = TO_NUMBER(to_char(dt_advised, 'HH24' )),
             "AC_OUT_OF_SVR_ADVICED_MINUTE"   = TO_NUMBER(to_char(dt_advised, 'MI' )),
             "AC_SCHEDULE_IN_SERVICE_DATE"    = dt_est,
             "AC_SCHEDULE_IN_SERVICE_HOUR"    = TO_NUMBER(to_char(dt_est, 'HH24' )),
             "AC_SCHEDULE_IN_SERVICE_MINUTE"  = TO_NUMBER(to_char(dt_est, 'MI' ))
      WHERE ACM."AC" = t_defect."AC";

     return;

  end if;

--------
   SELECT COUNT(*)
   INTO out_of_service_found
   FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
   WHERE ACOUT."AC"            = t_defect."AC" AND
         ACOUT."FLIGHT_STATUS" = 'P';

   if out_of_service_found > 0 then

      SELECT MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_OUT_SERVICE_DATE", ACOUT."AC_SCHEDULE_OUT_SERVICE_HOUR", ACOUT."AC_SCHEDULE_OUT_SERVICE_MINUTE" )),
             MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_OUT_OF_SVR_ADVISED_DATE", ACOUT."AC_OUT_OF_SVR_ADVISED_HOUR", ACOUT."AC_OUT_OF_SVR_ADVISED_MINUTE" )),
             MAX(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_IN_SERVICE_DATE", ACOUT."AC_SCHEDULE_IN_SERVICE_HOUR", ACOUT."AC_SCHEDULE_IN_SERVICE_MINUTE" ))
      INTO dt_out, dt_advised, dt_est
      FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
	    WHERE ( ACOUT."AC"            = UPPER(t_defect."AC") ) AND
            ( ACOUT."FLIGHT_STATUS" = 'P' ) ;

	    UPDATE "AC_MASTER" ACM
	       SET "FLIGHT_STATUS"                  = 'P',
	           "AC_SCHEDULE_OUT_SERVICE_DATE"   = dt_out,
	           "AC_SCHEDULE_OUT_SERVICE_HOUR"   = TO_NUMBER(to_char(dt_out, 'HH24' )),
             "AC_SCHEDULE_OUT_SERVICE_MINUTE" = TO_NUMBER(to_char(dt_out, 'MI' )),
             "AC_OUT_OF_SVR_ADVICED_DATE"     = dt_advised,
             "AC_OUT_OF_SVR_ADVICED_HOUR"     = TO_NUMBER(to_char(dt_advised, 'HH24' )),
             "AC_OUT_OF_SVR_ADVICED_MINUTE"   = TO_NUMBER(to_char(dt_advised, 'MI' )) ,
             "AC_SCHEDULE_IN_SERVICE_DATE"    = dt_est,
             "AC_SCHEDULE_IN_SERVICE_HOUR"    = TO_NUMBER(to_char(dt_est, 'HH24' )) ,
             "AC_SCHEDULE_IN_SERVICE_MINUTE"  = TO_NUMBER(to_char(dt_est, 'MI' ))
      WHERE ACM."AC" = t_defect."AC";

    return;

  end if;

------------
 -- do update with flight status 'Y'

    UPDATE "AC_MASTER" ACM
	  SET "FLIGHT_STATUS"                  = 'Y',
	      "AC_SCHEDULE_OUT_SERVICE_DATE"   = null,
	      "AC_SCHEDULE_OUT_SERVICE_HOUR"   = null,
        "AC_SCHEDULE_OUT_SERVICE_MINUTE" = null,
        "AC_OUT_OF_SVR_ADVICED_DATE"     = null,
        "AC_OUT_OF_SVR_ADVICED_HOUR"     = null,
        "AC_OUT_OF_SVR_ADVICED_MINUTE"   = null ,
        "AC_SCHEDULE_IN_SERVICE_DATE"    = null,
        "AC_SCHEDULE_IN_SERVICE_HOUR"    = null ,
        "AC_SCHEDULE_IN_SERVICE_MINUTE"  = null
    WHERE ACM."AC" = t_defect."AC";

end updateACTimes;

--==============================================================================
--Update AC Status
procedure updateACStatus(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE, service_no number)

is
  out_of_service_found number;
  dt_out date;
  dt_advised date;
  dt_est date;

begin

SELECT COUNT(*)
INTO out_of_service_found
FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
WHERE (ACOUT."OUT_SERVICE_NO" = service_no ) AND
      (ACOUT."AC" = t_defect."AC" ) AND
	  	(ACOUT."FLIGHT_STATUS" = 'N' ) ;

-- check if record exists
if out_of_service_found > 0 then

       SELECT MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_OUT_SERVICE_DATE", ACOUT."AC_SCHEDULE_OUT_SERVICE_HOUR", ACOUT."AC_SCHEDULE_OUT_SERVICE_MINUTE" )),
             MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_OUT_OF_SVR_ADVISED_DATE", ACOUT."AC_OUT_OF_SVR_ADVISED_HOUR", ACOUT."AC_OUT_OF_SVR_ADVISED_MINUTE" )),
             MAX(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_IN_SERVICE_DATE", ACOUT."AC_SCHEDULE_IN_SERVICE_HOUR", ACOUT."AC_SCHEDULE_IN_SERVICE_MINUTE" ))
        INTO dt_out, dt_advised, dt_est
        FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
	      WHERE ( ACOUT."OUT_SERVICE_NO" = service_no ) AND
	        	  ( ACOUT."AC" = UPPER(t_defect."AC") ) AND
              ( ACOUT."FLIGHT_STATUS" = 'N' ) ;


  	 UPDATE "AC_OUT_OF_SERVICE" ACOUT
	     SET "FLIGHT_STATUS" = 'N',
	         "AC_SCHEDULE_OUT_SERVICE_DATE" = TO_DATE(TO_CHAR(dt_out, 'MM/DD/RR'), 'MM/DD/RR'),
	         "AC_SCHEDULE_OUT_SERVICE_HOUR" = TO_NUMBER(to_char(dt_out, 'HH24' )),
           "AC_SCHEDULE_OUT_SERVICE_MINUTE" = TO_NUMBER(to_char(dt_out, 'MI' )),
           "AC_OUT_OF_SVR_ADVISED_DATE" = TO_DATE(TO_CHAR(dt_advised, 'MM/DD/RR'), 'MM/DD/RR'),
           "AC_OUT_OF_SVR_ADVISED_HOUR" = TO_NUMBER(to_char(dt_advised, 'HH24' )),
           "AC_OUT_OF_SVR_ADVISED_MINUTE" = TO_NUMBER(to_char(dt_advised, 'MI' )) ,
           "AC_SCHEDULE_IN_SERVICE_DATE" = TO_DATE(TO_CHAR(dt_est, 'MM/DD/RR'), 'MM/DD/RR'),
           "AC_SCHEDULE_IN_SERVICE_HOUR" = TO_NUMBER(to_char(dt_est, 'HH24' )) ,
          "AC_SCHEDULE_IN_SERVICE_MINUTE" = TO_NUMBER(to_char(dt_est, 'MI' )) ,
           "MODIFIED_BY" = 'TRAX_IFACE',
           "MODIFIED_DATE" = sysdate
    WHERE ACOUT."OUT_SERVICE_NO" = service_no AND
          ACOUT."AC" = UPPER(t_defect."AC");

	  --update times in AC Master
	  updateACTimes(t_defect);

   return;

 end if;
 ----------

SELECT COUNT(*)
INTO out_of_service_found
FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
WHERE (ACOUT."OUT_SERVICE_NO" = service_no ) AND
      (ACOUT."AC" = UPPER(t_defect."AC") ) AND
	  	(ACOUT."FLIGHT_STATUS" = 'P' ) ;


-- check if record exists
if out_of_service_found > 0 then

    SELECT MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_OUT_SERVICE_DATE", ACOUT."AC_SCHEDULE_OUT_SERVICE_HOUR", ACOUT."AC_SCHEDULE_OUT_SERVICE_MINUTE" )),
           MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_OUT_OF_SVR_ADVISED_DATE", ACOUT."AC_OUT_OF_SVR_ADVISED_HOUR", ACOUT."AC_OUT_OF_SVR_ADVISED_MINUTE" )),
           MAX(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_IN_SERVICE_DATE", ACOUT."AC_SCHEDULE_IN_SERVICE_HOUR", ACOUT."AC_SCHEDULE_IN_SERVICE_MINUTE" ))
    INTO dt_out, dt_advised, dt_est
    FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
	  WHERE ( ACOUT."OUT_SERVICE_NO" = service_no ) AND
	     	  ( ACOUT."AC" = UPPER(t_defect."AC") ) AND
          ( ACOUT."FLIGHT_STATUS" = 'P' ) ;


  	 UPDATE "AC_OUT_OF_SERVICE" ACOUT
	   SET "FLIGHT_STATUS" = 'P',
	       "AC_SCHEDULE_OUT_SERVICE_DATE" = TO_DATE(TO_CHAR(dt_out, 'MM/DD/RR'), 'MM/DD/RR'),
	       "AC_SCHEDULE_OUT_SERVICE_HOUR" = TO_NUMBER(to_char(dt_out, 'HH24' )),
         "AC_SCHEDULE_OUT_SERVICE_MINUTE" = TO_NUMBER(to_char(dt_out, 'MI' )),
         "AC_OUT_OF_SVR_ADVISED_DATE" = TO_DATE(TO_CHAR(dt_advised, 'MM/DD/RR'), 'MM/DD/RR'),
         "AC_OUT_OF_SVR_ADVISED_HOUR" = TO_NUMBER(to_char(dt_advised, 'HH24' )),
         "AC_OUT_OF_SVR_ADVISED_MINUTE" = TO_NUMBER(to_char(dt_advised, 'MI' )) ,
         "AC_SCHEDULE_IN_SERVICE_DATE" = TO_DATE(TO_CHAR(dt_est, 'MM/DD/RR'), 'MM/DD/RR'),
         "AC_SCHEDULE_IN_SERVICE_HOUR" = TO_NUMBER(to_char(dt_est, 'HH24' )) ,
         "AC_SCHEDULE_IN_SERVICE_MINUTE" = TO_NUMBER(to_char(dt_est, 'MI' )) ,
         "MODIFIED_BY" = 'TRAX_IFACE',
         "MODIFIED_DATE" = sysdate
    WHERE ACOUT."OUT_SERVICE_NO" = service_no AND
          ACOUT."AC" = UPPER(t_defect."AC");

    --update times in AC Master
	  updateACTimes(t_defect);

    return;

end if;

-- otherwise look for flight status Y
      SELECT MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_OUT_SERVICE_DATE", ACOUT."AC_SCHEDULE_OUT_SERVICE_HOUR", ACOUT."AC_SCHEDULE_OUT_SERVICE_MINUTE" )),
             MIN(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_OUT_OF_SVR_ADVISED_DATE", ACOUT."AC_OUT_OF_SVR_ADVISED_HOUR", ACOUT."AC_OUT_OF_SVR_ADVISED_MINUTE" )),
             MAX(PKG_APPLICATION_FUNCTION.getCombinedDate(ACOUT."AC_SCHEDULE_IN_SERVICE_DATE", ACOUT."AC_SCHEDULE_IN_SERVICE_HOUR", ACOUT."AC_SCHEDULE_IN_SERVICE_MINUTE" ))
      INTO dt_out, dt_advised, dt_est
      FROM "AC_OUT_OF_SERVICE_DETAIL" ACOUT
	    WHERE ( ACOUT."OUT_SERVICE_NO" = service_no ) AND
	        	( ACOUT."AC" = UPPER(t_defect."AC")) AND
            ( ACOUT."FLIGHT_STATUS" = 'Y' ) ;

  	 UPDATE "AC_OUT_OF_SERVICE" ACOUT
	     SET "FLIGHT_STATUS" = 'Y',
	         "AC_SCHEDULE_OUT_SERVICE_DATE" = TO_DATE(TO_CHAR(dt_out, 'MM/DD/RR'), 'MM/DD/RR'),
	         "AC_SCHEDULE_OUT_SERVICE_HOUR" = TO_NUMBER(to_char(dt_out, 'HH24' )),
           "AC_SCHEDULE_OUT_SERVICE_MINUTE" = TO_NUMBER(to_char(dt_out, 'MI' )),
           "AC_OUT_OF_SVR_ADVISED_DATE" = TO_DATE(TO_CHAR(dt_advised, 'MM/DD/RR'), 'MM/DD/RR'),
           "AC_OUT_OF_SVR_ADVISED_HOUR" = TO_NUMBER(to_char(dt_advised, 'HH24' )),
           "AC_OUT_OF_SVR_ADVISED_MINUTE" = TO_NUMBER(to_char(dt_advised, 'MI' )) ,
           "AC_SCHEDULE_IN_SERVICE_DATE" = TO_DATE(TO_CHAR(dt_est, 'MM/DD/RR'), 'MM/DD/RR'),
           "AC_SCHEDULE_IN_SERVICE_HOUR" = TO_NUMBER(to_char(dt_est, 'HH24' )) ,
           "AC_SCHEDULE_IN_SERVICE_MINUTE" = TO_NUMBER(to_char(dt_est, 'MI' )) ,
           "MODIFIED_BY" = 'TRAX_IFACE',
           "MODIFIED_DATE" = sysdate
     WHERE ACOUT."OUT_SERVICE_NO" = service_no AND
           ACOUT."AC" = UPPER(t_defect."AC");

    --update times in AC Master
	  updateACTimes(t_defect);

end updateACStatus;
--========================================================================
----Set flight status
procedure setFlightStatus(t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE, service_no in number, s_flight_status in varchar2)
is

dt_actual_in_service date;

begin

if s_flight_status = 'Y' then

   dt_actual_in_service := sysdate;

   UPDATE "AC_OUT_OF_SERVICE_DETAIL"
   SET    "FLIGHT_STATUS" = 'Y',
          "HOLD_BOARDING" = 'N',
          "AC_OUT_OF_SERVICE_DETAIL"."AC_ACTUAL_IN_SERVICE_DATE" = TO_DATE(TO_CHAR(dt_actual_in_service, 'MM/DD/RR'), 'MM/DD/RR'),
          "AC_OUT_OF_SERVICE_DETAIL"."AC_ACTUAL_IN_SERVICE_HOUR" = TO_NUMBER(to_char(dt_actual_in_service, 'HH24' )),
          "AC_OUT_OF_SERVICE_DETAIL"."AC_ACTUAL_IN_SERVICE_MINUTE" = TO_NUMBER(to_char(dt_actual_in_service, 'MI' ))
   WHERE  "AC_OUT_OF_SERVICE_DETAIL"."OUT_SERVICE_NO" = service_no AND
          "AC_OUT_OF_SERVICE_DETAIL"."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE")  AND
          "AC_OUT_OF_SERVICE_DETAIL"."DEFECT" = UPPER(t_defect."DEFECT") AND
          "AC_OUT_OF_SERVICE_DETAIL"."DEFECT_ITEM" = t_defect."DEFECT_ITEM"  AND
          "AC_OUT_OF_SERVICE_DETAIL"."WO" = 0;

else
   UPDATE "AC_OUT_OF_SERVICE_DETAIL"
   SET    "FLIGHT_STATUS" = s_flight_status
   WHERE  "AC_OUT_OF_SERVICE_DETAIL"."OUT_SERVICE_NO" = service_no AND
          "AC_OUT_OF_SERVICE_DETAIL"."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE")  AND
          "AC_OUT_OF_SERVICE_DETAIL"."DEFECT" = UPPER(t_defect."DEFECT") AND
          "AC_OUT_OF_SERVICE_DETAIL"."DEFECT_ITEM" = t_defect."DEFECT_ITEM"  AND
          "AC_OUT_OF_SERVICE_DETAIL"."WO" = 0 ;

end if;

end setFlightStatus;


--========================================================================
----MDDR UPDATE
procedure mddr_update(t_defect in out "INTERFACE_DEFECT_REPORT"%rowtype)
is

type cur_type is ref cursor;

cur_mddr cur_type;

t_stc "SYSTEM_TRAN_CODE"%rowtype;
t_sys_tran_con "SYSTEM_TRAN_CONFIG"%rowtype;
t_defect_report  "DEFECT_REPORT"%rowtype;

l_resolved_hour number :=0;
l_resolved_minute number := 0;
service_no number;
s_flight_status varchar2(10);

begin

If t_defect."MDDR" is null Then
  return;
end if;

If t_defect."DEFER" is not null and t_defect."DEFER" > '0' Then

--Check status of "DEFER_CAT_AUTO_MDDR_CLOSING"
    t_stc."SYSTEM_TRANSACTION" := 'DEFER';
    t_stc."SYSTEM_CODE" := UPPER(t_defect."DEFER");

    begin
      "PKG_SETTINGS".settings_tran_code_edit(t_stc);
      exception
      when others then
         t_stc."DEFER_CAT_AUTO_MDDR_CLOSING" := 'YES';
    end;

    if t_stc."DEFER_CAT_AUTO_MDDR_CLOSING" is null then
        t_stc."DEFER_CAT_AUTO_MDDR_CLOSING" := 'YES';
    elsif t_stc."DEFER_CAT_AUTO_MDDR_CLOSING" = 'NO' then
       return;
    end if;

End if;

--Get all defects with matching MDDR and AC
open cur_mddr for
   SELECT *
   FROM "DEFECT_REPORT"
   WHERE ( "DEFECT_REPORT"."MDDR" = t_defect."MDDR" ) AND
         ( "DEFECT_REPORT"."AC" = UPPER(t_defect."AC") ) AND
		     ( "DEFECT_REPORT"."STATUS" = 'OPEN' );

loop

fetch cur_mddr into t_defect_report;
exit when cur_mddr%notfound;

--Resolution description
    If t_defect_report."RESOLUTION_DESCRIPTION" is null then
			  t_defect_report."RESOLUTION_DESCRIPTION" := ' (Item Resolve Under MDDR: ' || t_defect."MDDR" || ') ' || NVL(t_defect."RESOLUTION_DESCRIPTION",' ');
		Else
			  t_defect_report."RESOLUTION_DESCRIPTION" := t_defect_report."RESOLUTION_DESCRIPTION" || ' (Item Resolve Under MDDR: ' || t_defect."MDDR" || ') ' || NVL(t_defect."RESOLUTION_DESCRIPTION",' ');
		End If;

--Resolved Date
		If t_defect_report."RESOLVED_DATE" is null then
			t_defect_report."RESOLVED_DATE" := t_defect."RESOLVED_DATE";
			l_resolved_hour := TO_NUMBER(TO_CHAR(t_defect_report."RESOLVED_DATE", 'HH24' ));
			l_resolved_minute := TO_NUMBER(TO_CHAR(t_defect_report."RESOLVED_DATE", 'MM' ));
		end if;

		If t_defect_report."RESOLVED_BY" is null then
		   t_defect_report."RESOLVED_BY" :=  t_defect."RESOLVED_BY";
		end if;

		t_defect_report."REPORTED_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."REPORTED_DATE", NVL(t_defect_report."REPORTED_HOUR", 0), NVL(t_defect_report."REPOTED_MINUTE", 0));

    --Check switch 'CLMDDRDT'
    t_sys_tran_con := PKG_SYSTEM_ADMIN.GET_SYSTEM_TRAN_CONFIG_RECORD('CLMDDRDT');

	  if t_sys_tran_con."CONFIG_FLAG" = 'Y' and t_defect_report."REPORTED_DATE" > t_defect."REPORTED_DATE" then
		    null;
		else

		   If t_defect."DEFECT_TYPE" <> t_defect_report."DEFECT_TYPE" or
   		    t_defect."DEFECT_ITEM" <> t_defect_report."DEFECT_ITEM" Then

		      UPDATE "DEFECT_REPORT"
        	SET "STATUS" = 'CLOSED',
        	     "RESOLUTION_DESCRIPTION" = t_defect_report."RESOLUTION_DESCRIPTION",
				       "RESOLVED_BY" = t_defect_report."RESOLVED_BY",
				       "RESOLVED_DATE" = t_defect_report."RESOLVED_DATE",
               "RESOLVED_HOUR" = NVL(t_defect_report."RESOLVED_HOUR", 0),
               "RESOLVED_MINUTE" = NVL(t_defect_report."RESOLVED_MINUTE", 0),
               "RESOLVED_LOCATION" = t_defect."RESOLVED_LOCATION",
				       "FAULT_CONFIRM" = t_defect."FAULT_CONFIRM"
  	    	WHERE ( "DEFECT_REPORT"."DEFECT_TYPE" = t_defect_report."DEFECT_TYPE" ) AND
      	        ( "DEFECT_REPORT"."DEFECT" = t_defect_report."DEFECT" ) AND
         	      ( "DEFECT_REPORT"."DEFECT_ITEM" = t_defect_report."DEFECT_ITEM" )
		             ;

 --PUT AC BACK IN SERVICE
		 service_no := getServiceNo(t_defect);

   --if service number exists
   if service_no <> -1 then
      s_flight_status := getFlightStatus(t_defect, service_no);

      if s_flight_status is not null and (s_flight_status = 'N' or s_flight_status = 'P') then
          setFlightStatus(t_defect, service_no, 'Y');
          updateACStatus(t_defect, service_no);
      end if;
   end if;

	end if;

end if;

end loop;

end mddr_update;

------------------------------------------------------------------------------------------
  --Do Concession Update
procedure concession_update(t_defect_report in out "DEFECT_REPORT"%ROWTYPE)
as

t_concession "CONCESSION_REGISTRY"%rowtype;

concession_found number;

begin

SELECT COUNT(*)
INTO concession_found
FROM "CONCESSION_REGISTRY" CR
WHERE ( CR."DEFECT_TYPE" = t_defect_report."DEFECT_TYPE" ) AND
      ( CR."DEFECT" = t_defect_report."DEFECT" ) AND
      ( CR."DEFECT_ITEM" = t_defect_report."DEFECT_ITEM" );

--If no concession for this defect, EXIT out
If concession_found = 0 then
   return;
end if;

SELECT *
INTO t_concession
FROM "CONCESSION_REGISTRY" CR
WHERE ( CR."DEFECT_TYPE" = t_defect_report."DEFECT_TYPE" ) AND
      ( CR."DEFECT" = t_defect_report."DEFECT" ) AND
      ( CR."DEFECT_ITEM" = t_defect_report."DEFECT_ITEM" );


--Update status
If t_concession."STATUS" = 'OPEN' or t_concession."STATUS" = 'PENDING' Then

   UPDATE "CONCESSION_REGISTRY"
   SET "STATUS" = 'TERMINATED'
   WHERE "CONCESSION_REGISTRY"."CONCESSION" = t_concession."CONCESSION" ;

End if;

end concession_update;
--=======================================================================
--Puts AC back in service
procedure PutACInService(s_ac "AC_MASTER"."AC"%type)
is
t_interface_audit "INTERFACE_AUDIT"%rowtype;
t_acm "AC_MASTER"%rowtype;

s_note_msg "NOTE_PAD"."NOTES_TEXT"%type;
s_from_user "NOTE_PAD_MESSAGE"."CREATED_BY"%type;
s_to_user "NOTE_PAD_MESSAGE"."USER"%type;

ac_found number;

ex_ac_not_found exception;
ex_ac_in_service exception;


begin

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'IN','PUT', 'AC_IN_OUT_SERVICE');

  SELECT COUNT(*)
  INTO ac_found
  FROM "AC_MASTER" A
  WHERE A."AC" = UPPER(s_ac);

  if ac_found > 0 then

     SELECT *
     INTO t_acm
     FROM "AC_MASTER" A
     WHERE A."AC" = UPPER(s_ac);

   --Check if AC is not in service already
     if t_acm."FLIGHT_STATUS" = 'Y' then
       raise ex_ac_in_service;
     end if;

     s_from_user := 'ADM';
     s_to_user := 'ADM';

     s_note_msg := 'An external system has put AC: ' || s_ac || ' back in service and there is a mismatch between the systems that must be resolved manually.  ';
     pkg_iface_message.send_note_to_user(s_from_user, s_to_user, s_note_msg);

  else
    raise ex_ac_not_found;
  end if;

exception
when ex_ac_not_found then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, 'The AC entered does not exist in AC Master', 'Y');

when ex_ac_in_service then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, 'The AC: ' || s_ac || ' is currently in service', 'Y');

end PutACInService;

--#############################################################################
-- Add a defect record
procedure addDefect
(t_defect in out "INTERFACE_DEFECT_REPORT"%rowtype)
is
  t_defect_report "DEFECT_REPORT"%rowtype;
  t_interface_audit "INTERFACE_AUDIT"%rowtype;

defect_exists number;
reference_exists number;

ex_defect_exists_already exception;
ex_iface_ext_ref_exists exception;   -- Log 22251

begin

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'IN','ADD', 'DEFECT_REPORT');

t_defect."TRANSACTION" := t_interface_audit."TRANSACTION";
t_defect."TRANSACTION_ITEM" := 1;

--Check if defect record is a duplicate
SELECT count(*)
INTO defect_exists
FROM "DEFECT_REPORT" R
WHERE R."DEFECT" = UPPER(t_defect."DEFECT") AND
      R."DEFECT_ITEM" = t_defect."DEFECT_ITEM" AND
      R."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE");


if defect_exists > 0 then
   raise ex_defect_exists_already;
end if;

--Check if Defect with INTERFACE_EXTERNAL_REFERENCE already exists
if (t_defect."INTERFACE_EXTERNAL_REFERENCE" is not null and
     t_defect."INTERFACE_EXTERNAL_REFERENCE" > '0' ) then

   SELECT count(*)
   INTO reference_exists
   FROM "DEFECT_REPORT" R
   WHERE R."INTERFACE_EXTERNAL_REFERENCE" = UPPER(t_defect."INTERFACE_EXTERNAL_REFERENCE");

   if reference_exists > 0 then
      raise ex_iface_ext_ref_exists;
   end if;

end if;

--Perform validation
validateDefect(t_interface_audit, t_defect, t_defect_report);

--Created by/Date
t_defect_report."CREATED_BY" := t_defect."MODIFIED_BY";
t_defect_report."CREATED_DATE" := t_defect."MODIFIED_DATE";
t_defect_report."CREATED_FROM" := 'INTERFACE';

--Insert record
INSERT INTO "DEFECT_REPORT" R
VALUES t_defect_report;

--Begin Exception Handling
exception

when ex_defect_exists_already then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, 'Defect report already exists', 'Y');

when ex_iface_ext_ref_exists then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, 'Defect with this Interface Reference Number was already added', 'Y');

when others then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, SQLCODE, substr(SQLERRM, 1, 1000), 'N');
  RAISE;
--end exception handling

end addDefect;

--=================================================================================
-- Add Defect to Trax with parameters passed in
procedure addDefect
(p_DEFECT "INTERFACE_DEFECT_REPORT"."DEFECT"%type,
p_DEFECT_ITEM "INTERFACE_DEFECT_REPORT"."DEFECT_ITEM"%type,
p_AC "INTERFACE_DEFECT_REPORT"."AC"%type,
p_CHAPTER "INTERFACE_DEFECT_REPORT"."CHAPTER"%type,
p_SECTION "INTERFACE_DEFECT_REPORT"."SECTION"%type,
p_FLIGHT "INTERFACE_DEFECT_REPORT"."FLIGHT"%type,
p_FLIGHT_PHASE "INTERFACE_DEFECT_REPORT"."FLIGHT_PHASE"%type,
p_DEFECT_DESCRIPTION "INTERFACE_DEFECT_REPORT"."DEFECT_DESCRIPTION"%type,
p_STATION "INTERFACE_DEFECT_REPORT"."STATION"%type,
p_MODIFIED_BY "INTERFACE_DEFECT_REPORT"."MODIFIED_BY"%type,
p_MODIFIED_DATE "INTERFACE_DEFECT_REPORT"."MODIFIED_DATE"%type,
p_DEFECT_DATE "INTERFACE_DEFECT_REPORT"."REPORTED_DATE"%type,
p_MDDR "INTERFACE_DEFECT_REPORT"."MDDR"%type,
p_DEFER "INTERFACE_DEFECT_REPORT"."DEFER"%type,
p_DEFER_BY "INTERFACE_DEFECT_REPORT"."DEFER_BY"%type,
p_DEFER_TO_DATE "INTERFACE_DEFECT_REPORT"."DEFER_TO_DATE"%type,
p_DEFER_DATE "INTERFACE_DEFECT_REPORT"."DEFER_DATE"%type,
p_MEL_NUMBER "INTERFACE_DEFECT_REPORT"."MEL_NUMBER"%type,
p_DEFER_CATEGORY "INTERFACE_DEFECT_REPORT"."DEFER_CATEGORY"%type,
p_SCHEDULE_HOURS "INTERFACE_DEFECT_REPORT"."SCHEDULE_HOURS"%type,
p_SCHEDULE_CYCLES "INTERFACE_DEFECT_REPORT"."SCHEDULE_CYCLES"%type,
p_SCHEDULE_DAYS "INTERFACE_DEFECT_REPORT"."SCHEDULE_DAYS"%type,
p_DEFER_TO_NEXT_EC "INTERFACE_DEFECT_REPORT"."DEFER_TO_NEXT_EC"%type,
p_SKILL "INTERFACE_DEFECT_REPORT"."SKILL"%type,
p_MAN_HOURS "INTERFACE_DEFECT_REPORT"."MAN_HOURS"%type,
p_MAN_REQUIRED "INTERFACE_DEFECT_REPORT"."MAN_REQUIRED"%type,
p_CAPABILITY_AREA "INTERFACE_DEFECT_REPORT"."CAPABILITY_AREA"%type,
p_PLAN_DEFECT "INTERFACE_DEFECT_REPORT"."PLAN_DEFECT"%type,
p_REPEAT_NUMBER "INTERFACE_DEFECT_REPORT"."REPEAT_NUMBER"%type,
p_COMPLETED_NUMBER "INTERFACE_DEFECT_REPORT"."COMPLETED_NUMBER"%type,
p_OVERRIDE_MDDR_AUTO "INTERFACE_DEFECT_REPORT"."OVERRIDE_MDDR_AUTO"%type,
p_DISPATCHER_NOTIFIED "INTERFACE_DEFECT_REPORT"."DISPATCHER_NOTIFIED"%type,
p_DO_NOT_ALLOW_CONCESSION "INTERFACE_DEFECT_REPORT"."DO_NOT_ALLOW_CONCESSION"%type,
p_MEL_CALENDAR_DAYS_FLAG "INTERFACE_DEFECT_REPORT"."MEL_CALENDAR_DAYS_FLAG"%type,
p_DEFER_NOTES "INTERFACE_DEFECT_REPORT"."DEFER_NOTES"%type,
p_DEFECT_TYPE "INTERFACE_DEFECT_REPORT"."DEFECT_TYPE"%type,
p_MEL "INTERFACE_DEFECT_REPORT"."MEL"%type,
p_RESOLUTION_CATEGORY "INTERFACE_DEFECT_REPORT"."RESOLUTION_CATEGORY"%type,
p_RESOLVED_BY "INTERFACE_DEFECT_REPORT"."RESOLVED_BY"%type,
p_RESOLVED_DATE "INTERFACE_DEFECT_REPORT"."RESOLVED_DATE"%type,
p_RESOLUTION_DESCRIPTION "INTERFACE_DEFECT_REPORT"."RESOLUTION_DESCRIPTION"%type,
p_DIS_NOT_RESOLUTION "INTERFACE_DEFECT_REPORT"."DISPATCHER_NOTIFIED_RESOLUTION"%type,
p_RESOLVED_LOCATION "INTERFACE_DEFECT_REPORT"."RESOLVED_LOCATION"%type,
p_FAULT_CONFIRM "INTERFACE_DEFECT_REPORT"."FAULT_CONFIRM"%type,
p_REPORTED_BY "INTERFACE_DEFECT_REPORT"."REPORTED_BY"%type,
p_SDR "INTERFACE_DEFECT_REPORT"."SDR"%type,
p_DEFECT_GATE "INTERFACE_DEFECT_REPORT"."DEFECT_GATE"%type,
p_AUTO_GENERATE_DEFECT "INTERFACE_DEFECT_REPORT"."AUTO_GENERATE_DEFECT"%type,
p_INTERFACE_EXTERNAL_REFERENCE "INTERFACE_DEFECT_REPORT"."INTERFACE_EXTERNAL_REFERENCE"%type,
--36077
p_PARAGRAPH "INTERFACE_DEFECT_REPORT"."PARAGRAPH"%type,
p_DELAY "INTERFACE_DEFECT_REPORT"."DELAY"%type,
p_WO "INTERFACE_DEFECT_REPORT"."WO"%type,
p_DEFECT_CATEGORY "INTERFACE_DEFECT_REPORT"."DEFECT_CATEGORY"%type )


is

t_defect "INTERFACE_DEFECT_REPORT"%rowtype;
t_defect_report "DEFECT_REPORT"%rowtype;
t_interface_audit "INTERFACE_AUDIT"%rowtype;

defect_exists number;
reference_exists number;

ex_defect_exists_already exception;
ex_iface_ext_ref_exists exception;   -- Log 22251

begin

t_defect.DEFECT := p_DEFECT ;
t_defect.DEFECT_ITEM := p_DEFECT_ITEM ;
t_defect.AC := p_AC;
t_defect.CHAPTER := p_CHAPTER;
t_defect.SECTION := p_SECTION ;
t_defect.FLIGHT := p_FLIGHT ;
t_defect.FLIGHT_PHASE := p_FLIGHT_PHASE ;
t_defect.DEFECT_DESCRIPTION := p_DEFECT_DESCRIPTION ;
t_defect.STATION := p_STATION;
t_defect.MODIFIED_BY := p_MODIFIED_BY;
t_defect.MODIFIED_DATE := p_MODIFIED_DATE;
t_defect.REPORTED_DATE := p_DEFECT_DATE;
t_defect.MDDR := p_MDDR;
t_defect.DEFER := p_DEFER ;
t_defect.DEFER_BY := p_DEFER_BY;
t_defect.DEFER_DATE := p_DEFER_DATE;
t_defect.DEFER_TO_DATE := p_DEFER_TO_DATE;
t_defect.MEL_NUMBER := p_MEL_NUMBER;
t_defect.DEFER_CATEGORY := p_DEFER_CATEGORY;
t_defect.SCHEDULE_HOURS := p_SCHEDULE_HOURS;
t_defect.SCHEDULE_CYCLES := p_SCHEDULE_CYCLES;
t_defect.SCHEDULE_DAYS := p_SCHEDULE_DAYS;
t_defect.DEFER_TO_NEXT_EC := p_DEFER_TO_NEXT_EC;
t_defect.SKILL := p_SKILL;
t_defect.MAN_HOURS := p_MAN_HOURS;
t_defect.MAN_REQUIRED := p_MAN_REQUIRED;
t_defect.CAPABILITY_AREA := p_CAPABILITY_AREA;
t_defect.PLAN_DEFECT := p_PLAN_DEFECT;
t_defect.REPEAT_NUMBER := p_REPEAT_NUMBER;
t_defect.COMPLETED_NUMBER := p_COMPLETED_NUMBER;
t_defect.OVERRIDE_MDDR_AUTO := p_OVERRIDE_MDDR_AUTO;
t_defect.DISPATCHER_NOTIFIED := p_DISPATCHER_NOTIFIED;
t_defect.DO_NOT_ALLOW_CONCESSION := p_DO_NOT_ALLOW_CONCESSION;
t_defect.MEL_CALENDAR_DAYS_FLAG := p_MEL_CALENDAR_DAYS_FLAG;
t_defect.DEFER_NOTES := p_DEFER_NOTES;
t_defect.DEFECT_TYPE := p_DEFECT_TYPE;
t_defect.MEL := p_MEL;
t_defect.RESOLUTION_CATEGORY := p_RESOLUTION_CATEGORY;
t_defect.RESOLVED_BY := p_RESOLVED_BY;
t_defect.RESOLVED_DATE := p_RESOLVED_DATE;
t_defect.RESOLUTION_DESCRIPTION := p_RESOLUTION_DESCRIPTION;
t_defect.DISPATCHER_NOTIFIED_RESOLUTION := p_DIS_NOT_RESOLUTION;
t_defect.RESOLVED_LOCATION := p_RESOLVED_LOCATION;
t_defect.FAULT_CONFIRM := p_FAULT_CONFIRM;
t_defect.REPORTED_BY := p_REPORTED_BY;
t_defect.SDR := p_SDR;
t_defect.DEFECT_GATE := p_DEFECT_GATE;
t_defect.AUTO_GENERATE_DEFECT := p_AUTO_GENERATE_DEFECT;
t_defect.INTERFACE_EXTERNAL_REFERENCE := p_INTERFACE_EXTERNAL_REFERENCE;
--36077
t_defect.PARAGRAPH := p_PARAGRAPH;
t_defect.DELAY := p_DELAY;
t_defect.WO := p_WO;
t_defect.DEFECT_CATEGORY := p_DEFECT_CATEGORY;

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'IN','ADD', 'DEFECT_REPORT');

t_defect."TRANSACTION" := t_interface_audit."TRANSACTION";
t_defect."TRANSACTION_ITEM" := 1;

--Check if defect record is a duplicate
SELECT count(*)
INTO defect_exists
FROM "DEFECT_REPORT" R
WHERE R."DEFECT" = UPPER(t_defect."DEFECT") AND
      R."DEFECT_ITEM" = t_defect."DEFECT_ITEM" AND
      R."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE");


if defect_exists > 0 then
   raise ex_defect_exists_already;
end if;

--Check if Defect with INTERFACE_EXTERNAL_REFERENCE already exists
if (t_defect."INTERFACE_EXTERNAL_REFERENCE" is not null and
     t_defect."INTERFACE_EXTERNAL_REFERENCE" > '0' ) then

   SELECT count(*)
   INTO reference_exists
   FROM "DEFECT_REPORT" R
   WHERE R."INTERFACE_EXTERNAL_REFERENCE" = UPPER(t_defect."INTERFACE_EXTERNAL_REFERENCE");

   if reference_exists > 0 then
      raise ex_iface_ext_ref_exists;
   end if;

end if;

--Perform validation
validateDefect(t_interface_audit, t_defect, t_defect_report);

--Created by/Date
t_defect_report."CREATED_BY" := t_defect."MODIFIED_BY";
t_defect_report."CREATED_DATE" := t_defect."MODIFIED_DATE";
t_defect_report."CREATED_FROM" := 'INTERFACE';

--Insert record
INSERT INTO "DEFECT_REPORT" R
VALUES t_defect_report;

--Begin Exception Handling
exception

when ex_defect_exists_already then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, 'Defect report already exists', 'Y');

when ex_iface_ext_ref_exists then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, 'Defect with this Interface Reference Number was already added', 'Y');

when others then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, SQLCODE, substr(SQLERRM, 1, 1000), 'N');
  RAISE;
--end exception handling

end addDefect;

--#####################################################################
--*******************************************
procedure recordErrorXML(
    c_XML_error IN OUT CLOB,
    xml_error_item IN CLOB,
    s_error_message IN VARCHAR2 ) IS
BEGIN
  IF c_XML_error IS NULL THEN
    c_XML_error := '<?xml version="1.0" encoding="UTF-8"?> <errorLog> ';
  END IF;
  c_XML_error := c_XML_error ||
       '<defect> ' ||
          xml_error_item || ' ' ||
        '</defect> '  ||
        '<error> ' ||
           s_error_message || ' ' ||
        '</error> ';
END recordErrorXML;

--***********************************************************
procedure reportErrorXML(
    t_interface_audit IN OUT "INTERFACE_AUDIT"%ROWTYPE,
    c_XML_error IN OUT CLOB ) IS
BEGIN
  IF c_XML_error IS NOT NULL THEN
    c_XML_error := c_XML_error || ' </errorLog>';

    INSERT INTO "INTERFACE_DATA_EXCEPTIONS" (
      "TRANSACTION",
      "TRANSACTION_ITEM",
      "XML_DOCUMENT" )
    VALUES (
      t_interface_audit."TRANSACTION",
      1,
      XMLType(c_XML_error) );

      DBMS_OUTPUT.put_line('XML Error inserted');
      PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20010, 'Error processing Invoice XML document','Y');
      DBMS_OUTPUT.put_line('setException called');
  END IF;
END reportErrorXML;


----------------------
  --Procedure to extract the defects from XML
procedure extractDefect(
  t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE,
  t_interface_data in "INTERFACE_DATA"%ROWTYPE,
  t_interface_audit in out "INTERFACE_AUDIT"%ROWTYPE)
is

ac_found number;
ac_source varchar2(50);
t_ac_master "AC_MASTER"%ROWTYPE;

ex_ac_basic_not_found exception;

BEGIN

  SELECT
   extractValue(d.XML_DOCUMENT, '/*/Defect'),
   extractValue(d.XML_DOCUMENT, '/*/Defect_Item'),
   extractValue(d.XML_DOCUMENT, '/*/AC_Source'),
   extractValue(d.XML_DOCUMENT, '/*/Chapter'),
   extractValue(d.XML_DOCUMENT, '/*/Section'),
   extractValue(d.XML_DOCUMENT, '/*/Flight'),
   extractValue(d.XML_DOCUMENT, '/*/Flight_Phase'),
   extractValue(d.XML_DOCUMENT, '/*/Defect_Description'),
   extractValue(d.XML_DOCUMENT, '/*/Station'),
   extractValue(d.XML_DOCUMENT, '/*/Modified_By'),
   TO_DATE(extractValue(d.XML_DOCUMENT, '/*/Modified_Date'),'YYYY-MM-DD"T"HH24:MI:SS' ),
   TO_DATE(extractValue(d.XML_DOCUMENT, '/*/Defect_Date'),'YYYY-MM-DD"T"HH24:MI:SS' ),
   extractValue(d.XML_DOCUMENT, '/*/MDDR'),
   extractValue(d.XML_DOCUMENT, '/*/Defer'),
   extractValue(d.XML_DOCUMENT, '/*/Defer_By'),
   TO_DATE(extractValue(d.XML_DOCUMENT, '/*/Defer_To_Date'),'YYYY-MM-DD"T"HH24:MI:SS' ),
   TO_DATE(extractValue(d.XML_DOCUMENT, '/*/Defer_Date'),'YYYY-MM-DD"T"HH24:MI:SS' ),
   extractValue(d.XML_DOCUMENT, '/*/MEL_Number'),
   extractValue(d.XML_DOCUMENT, '/*/Defer_Category'),
   extractValue(d.XML_DOCUMENT, '/*/Schedule_Hours'),
   extractValue(d.XML_DOCUMENT, '/*/Schedule_Cycles'),
   extractValue(d.XML_DOCUMENT, '/*/Schedule_Days'),
   extractValue(d.XML_DOCUMENT, '/*/Defer_To_Next_EC'),
   extractValue(d.XML_DOCUMENT, '/*/Skill'),
   extractValue(d.XML_DOCUMENT, '/*/Man_Hours'),
   extractValue(d.XML_DOCUMENT, '/*/Man_Required'),
   extractValue(d.XML_DOCUMENT, '/*/Capability_Area'),
   extractValue(d.XML_DOCUMENT, '/*/Plan_Defect'),
   extractValue(d.XML_DOCUMENT, '/*/Repeat_Number'),
   extractValue(d.XML_DOCUMENT, '/*/Completed_Number'),
   extractValue(d.XML_DOCUMENT, '/*/Override_MDDR_Auto'),
   extractValue(d.XML_DOCUMENT, '/*/Dispatcher_Notified'),
   extractValue(d.XML_DOCUMENT, '/*/Do_Not_Allow_Concession'),
   extractValue(d.XML_DOCUMENT, '/*/Mel_Calendar_Days_Flag'),
   extractValue(d.XML_DOCUMENT, '/*/Defer_Notes'),
   extractValue(d.XML_DOCUMENT, '/*/Defect_Type'),
   extractValue(d.XML_DOCUMENT, '/*/MEL'),
   extractValue(d.XML_DOCUMENT, '/*/Resolution_Category'),
   extractValue(d.XML_DOCUMENT, '/*/Resolved_By'),
   TO_DATE(extractValue(d.XML_DOCUMENT, '/*/Resolved_Date'),'YYYY-MM-DD"T"HH24:MI:SS' ),
   extractValue(d.XML_DOCUMENT, '/*/Resolution_Description'),
   extractValue(d.XML_DOCUMENT, '/*/Dispatcher_Notified_Resolution'),
   extractValue(d.XML_DOCUMENT, '/*/Resolved_By'),
   extractValue(d.XML_DOCUMENT, '/*/Resolved_Location'),
   extractValue(d.XML_DOCUMENT, '/*/Fault_Confirm'),
   extractValue(d.XML_DOCUMENT, '/*/Reported_By'),
   extractValue(d.XML_DOCUMENT, '/*/SDR'),
   extractValue(d.XML_DOCUMENT, '/*/Defect_Gate'),
   extractValue(d.XML_DOCUMENT, '/*/Auto_Generate_Defect'),
   extractValue(d.XML_DOCUMENT, '/*/Interface_External_Reference'),
   extractValue(d.XML_DOCUMENT, '/*/Internal_Capability'),
   extractValue(d.XML_DOCUMENT, '/*/Do_Not_Validate_Locations')
 INTO
    t_defect."DEFECT",
    t_defect."DEFECT_ITEM",
    ac_source,
    t_defect."CHAPTER",
    t_defect."SECTION",
    t_defect."FLIGHT",
    t_defect."FLIGHT_PHASE",
    t_defect."DEFECT_DESCRIPTION",
    t_defect."STATION",
    t_defect."MODIFIED_BY",
    t_defect."MODIFIED_DATE",
    t_defect."REPORTED_DATE",
    t_defect."MDDR",
    t_defect."DEFER",
    t_defect."DEFER_BY",
    t_defect."DEFER_TO_DATE",
    t_defect."DEFER_DATE",
    t_defect."MEL_NUMBER",
    t_defect."DEFER_CATEGORY",
    t_defect."SCHEDULE_HOURS",
    t_defect."SCHEDULE_CYCLES",
    t_defect."SCHEDULE_DAYS",
    t_defect."DEFER_TO_NEXT_EC",
    t_defect."SKILL",
    t_defect."MAN_HOURS",
    t_defect."MAN_REQUIRED",
    t_defect."CAPABILITY_AREA",
    t_defect."PLAN_DEFECT",
    t_defect."REPEAT_NUMBER",
    t_defect."COMPLETED_NUMBER",
    t_defect."OVERRIDE_MDDR_AUTO",
    t_defect."DISPATCHER_NOTIFIED",
    t_defect."DO_NOT_ALLOW_CONCESSION",
    t_defect."MEL_CALENDAR_DAYS_FLAG",
    t_defect."DEFER_NOTES",
    t_defect."DEFECT_TYPE",
    t_defect."MEL",
    t_defect."RESOLUTION_CATEGORY",
    t_defect."RESOLVED_BY",
    t_defect."RESOLVED_DATE",
    t_defect."RESOLUTION_DESCRIPTION",
    t_defect."DISPATCHER_NOTIFIED_RESOLUTION",
    t_defect."RESOLVED_BY",
    t_defect."RESOLVED_LOCATION",
    t_defect."FAULT_CONFIRM",
    t_defect."REPORTED_BY",
    t_defect."SDR",
    t_defect."DEFECT_GATE",
    t_defect."AUTO_GENERATE_DEFECT",
    t_defect."INTERFACE_EXTERNAL_REFERENCE",
    t_defect."INTERNAL_CAPABILITY",
    t_defect."DO_NOT_VALIDATE_LOCATIONS"
  FROM "INTERFACE_DATA" d
  WHERE d."TRANSACTION" = t_interface_data."TRANSACTION" AND
        d."TRANSACTION_ITEM" = t_interface_data."TRANSACTION_ITEM";

 --Check if AC source has been passed in
 --Get actual AC number by looking up the basic number if AC source is BASIC_NUMBER
   If ac_source is not null and ac_source = 'BASIC_NUMBER' then
       SELECT extractValue(d.XML_DOCUMENT, '/*/AC')
       INTO t_ac_master."BASIC_NUMBER"
       FROM "INTERFACE_DATA" d
       WHERE d."TRANSACTION" = t_interface_data."TRANSACTION" AND
             d."TRANSACTION_ITEM" = t_interface_data."TRANSACTION_ITEM";

       SELECT COUNT(*)
       INTO ac_found
       FROM "AC_MASTER"
       WHERE "AC_MASTER"."BASIC_NUMBER" = t_ac_master."BASIC_NUMBER";

       If ac_found > 0 Then
          SELECT *
          INTO t_ac_master
          FROM "AC_MASTER"
          WHERE "AC_MASTER"."BASIC_NUMBER" = t_ac_master."BASIC_NUMBER";

          t_defect."AC" := t_ac_master."AC";
       Else
         raise ex_ac_basic_not_found;
       End if;

   --Number passed in is the AC number
   elsif ac_source is null or ac_source = 'AC' then
       SELECT extractValue(d.XML_DOCUMENT, '/*/AC')
       INTO t_defect."AC"
       FROM "INTERFACE_DATA" d
       WHERE d."TRANSACTION" = t_interface_data."TRANSACTION" AND
             d."TRANSACTION_ITEM" = t_interface_data."TRANSACTION_ITEM";
   End if;


---
 --  dbms_output.put_line('AC: ' || t_defect."AC");
 --  dbms_output.put_line('ac source: ' || ac_source);
   dbms_output.put_line('ac found: ' || ac_found);
   dbms_output.put_line('defect type: ' || t_defect."DEFECT_TYPE");
   dbms_output.put_line('defect : ' ||  t_defect."DEFECT");
   dbms_output.put_line('TRANSACTION: ' || t_interface_data."TRANSACTION");
 --  dbms_output.put_line('defect type: ' || t_defect."DEFECT_TYPE");
----

EXCEPTION

when ex_ac_basic_not_found then
  s_error_message := 'An AC with the Basic Number entered was not found';
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20010, s_error_message, 'Y');

when others then
   PKG_INTERFACE_AUDIT.setException(t_interface_audit, SQLCODE, substr(SQLERRM, 1, 1000), 'N');
  RAISE;


END extractDefect;


------------------
--Procedure to be called to add a defect to the table
procedure add( t_interface_data in "INTERFACE_DATA"%ROWTYPE ) is

t_interface_audit "INTERFACE_AUDIT"%ROWTYPE;
t_defect_report "DEFECT_REPORT"%ROWTYPE;
t_defect "INTERFACE_DEFECT_REPORT"%ROWTYPE;
is_valid NUMBER;
s_val VARCHAR2(2000);
c_error CLOB := null;
loop_num number;
XML_Defect XMLTYPE;

defect_exists number;
reference_exists number;

ex_defect_exists_already exception;
ex_iface_ext_ref_exists exception;
ex_schema_validation_failed exception;

begin

XML_Defect := t_interface_data."XML_DOCUMENT";

--Validate XML Document against Schema
is_valid := XML_DEFECT.isSchemaValid('http://trax.aero/xml/DefectReport.xsd');

If is_valid = 1 Then
   DBMS_OUTPUT.put_line('XML validated against schema');
Else
   DBMS_OUTPUT.put_line('XML failed validation against Schema');
   raise ex_schema_validation_failed;
End if;

t_interface_audit."TRANSACTION" := t_interface_data."TRANSACTION";

t_defect."TRANSACTION" := t_interface_data."TRANSACTION";
t_defect."TRANSACTION_ITEM" := 1;

Begin
--Extract defect from XML file
extractDefect(t_defect, t_interface_data, t_interface_audit);

--Check if defect record is a duplicate
SELECT count(*)
INTO defect_exists
FROM "DEFECT_REPORT" R
WHERE R."DEFECT" = UPPER(t_defect."DEFECT") AND
      R."DEFECT_ITEM" = t_defect."DEFECT_ITEM" AND
      R."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE");

if defect_exists > 0 then
   raise ex_defect_exists_already;
end if;


--Check if Defect with INTERFACE_EXTERNAL_REFERENCE already exists
if (t_defect."INTERFACE_EXTERNAL_REFERENCE" is not null and
     t_defect."INTERFACE_EXTERNAL_REFERENCE" > '0' ) then

   SELECT count(*)
   INTO reference_exists
   FROM "DEFECT_REPORT" R
   WHERE R."INTERFACE_EXTERNAL_REFERENCE" = UPPER(t_defect."INTERFACE_EXTERNAL_REFERENCE");

   if reference_exists > 0 then
      raise ex_iface_ext_ref_exists;
   end if;

end if;


--Perform validation
DBMS_OUTPUT.put_line('Starting validating');---
s_error_message := null;
validateDefect(t_interface_audit, t_defect, t_defect_report);
DBMS_OUTPUT.put_line('Validation completed');---

--Created by/Date
t_defect_report."CREATED_BY" := t_defect."MODIFIED_BY";
t_defect_report."CREATED_DATE" := t_defect."MODIFIED_DATE";
t_defect_report."CREATED_FROM" := 'INTERFACE';

--Insert record
INSERT INTO "DEFECT_REPORT" R
VALUES t_defect_report;


EXCEPTION
   when ex_defect_exists_already then
     s_error_message := 'Defect report already exists';
   --  recordErrorXML(c_error, t_interface_data."XML_DOCUMENT".extract('/*').getCLOBVal(), s_error_message );
     PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, s_error_message, 'Y');

   when ex_iface_ext_ref_exists then
     s_error_message := 'Defect with this Interface Reference Number was already added';
     PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, s_error_message, 'Y');

   when others then
      rollback;
      If s_error_message is null then
        dbms_output.put_line('ERROR: ' || substr(SQLERRM,1,1000));
        PKG_INTERFACE_AUDIT.setException(t_interface_audit, SQLCODE, ' Add: ' || substr(SQLERRM,1,1000), 'N');
      Else
        dbms_output.put_line('ERROR: ' || s_error_message);   ---
        recordErrorXML(c_error, t_interface_data."XML_DOCUMENT".extract('/*').getCLOBVal(), s_error_message );
      End if;
end;

-- Write defect error log
  reportErrorXML( t_interface_audit, c_error );

--Begin Exception Handling
exception

when ex_schema_validation_failed then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20010, 'XML Document Failed Schema Validation', 'Y');

when others then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, SQLCODE, substr(SQLERRM, 1, 1000), 'N');
  RAISE;
--end exception handling

end add;

--#############################################################

--=================================================================================
-- Add or Update a Defect Report to/in Trax
procedure setDefect
(p_DEFECT "INTERFACE_DEFECT_REPORT"."DEFECT"%type,
p_DEFECT_ITEM "INTERFACE_DEFECT_REPORT"."DEFECT_ITEM"%type,
p_AC "INTERFACE_DEFECT_REPORT"."AC"%type,
p_CHAPTER "INTERFACE_DEFECT_REPORT"."CHAPTER"%type,
p_SECTION "INTERFACE_DEFECT_REPORT"."SECTION"%type,
p_FLIGHT "INTERFACE_DEFECT_REPORT"."FLIGHT"%type,
p_FLIGHT_PHASE "INTERFACE_DEFECT_REPORT"."FLIGHT_PHASE"%type,
p_DEFECT_DESCRIPTION "INTERFACE_DEFECT_REPORT"."DEFECT_DESCRIPTION"%type,
p_STATION "INTERFACE_DEFECT_REPORT"."STATION"%type,
p_MODIFIED_BY "INTERFACE_DEFECT_REPORT"."MODIFIED_BY"%type,
p_MODIFIED_DATE "INTERFACE_DEFECT_REPORT"."MODIFIED_DATE"%type,
p_DEFECT_DATE "INTERFACE_DEFECT_REPORT"."REPORTED_DATE"%type,
p_MDDR "INTERFACE_DEFECT_REPORT"."MDDR"%type,
p_DEFER "INTERFACE_DEFECT_REPORT"."DEFER"%type,
p_DEFER_BY "INTERFACE_DEFECT_REPORT"."DEFER_BY"%type,
p_DEFER_TO_DATE "INTERFACE_DEFECT_REPORT"."DEFER_TO_DATE"%type,
p_DEFER_DATE "INTERFACE_DEFECT_REPORT"."DEFER_DATE"%type,
p_MEL_NUMBER "INTERFACE_DEFECT_REPORT"."MEL_NUMBER"%type,
p_DEFER_CATEGORY "INTERFACE_DEFECT_REPORT"."DEFER_CATEGORY"%type,
p_SCHEDULE_HOURS "INTERFACE_DEFECT_REPORT"."SCHEDULE_HOURS"%type,
p_SCHEDULE_CYCLES "INTERFACE_DEFECT_REPORT"."SCHEDULE_CYCLES"%type,
p_SCHEDULE_DAYS "INTERFACE_DEFECT_REPORT"."SCHEDULE_DAYS"%type,
p_DEFER_TO_NEXT_EC "INTERFACE_DEFECT_REPORT"."DEFER_TO_NEXT_EC"%type,
p_SKILL "INTERFACE_DEFECT_REPORT"."SKILL"%type,
p_MAN_HOURS "INTERFACE_DEFECT_REPORT"."MAN_HOURS"%type,
p_MAN_REQUIRED "INTERFACE_DEFECT_REPORT"."MAN_REQUIRED"%type,
p_CAPABILITY_AREA "INTERFACE_DEFECT_REPORT"."CAPABILITY_AREA"%type,
p_PLAN_DEFECT "INTERFACE_DEFECT_REPORT"."PLAN_DEFECT"%type,
p_REPEAT_NUMBER "INTERFACE_DEFECT_REPORT"."REPEAT_NUMBER"%type,
p_COMPLETED_NUMBER "INTERFACE_DEFECT_REPORT"."COMPLETED_NUMBER"%type,
p_OVERRIDE_MDDR_AUTO "INTERFACE_DEFECT_REPORT"."OVERRIDE_MDDR_AUTO"%type,
p_DISPATCHER_NOTIFIED "INTERFACE_DEFECT_REPORT"."DISPATCHER_NOTIFIED"%type,
p_DO_NOT_ALLOW_CONCESSION "INTERFACE_DEFECT_REPORT"."DO_NOT_ALLOW_CONCESSION"%type,
p_MEL_CALENDAR_DAYS_FLAG "INTERFACE_DEFECT_REPORT"."MEL_CALENDAR_DAYS_FLAG"%type,
p_DEFER_NOTES "INTERFACE_DEFECT_REPORT"."DEFER_NOTES"%type,
p_DEFECT_TYPE "INTERFACE_DEFECT_REPORT"."DEFECT_TYPE"%type,
p_MEL "INTERFACE_DEFECT_REPORT"."MEL"%type,
p_RESOLUTION_CATEGORY "INTERFACE_DEFECT_REPORT"."RESOLUTION_CATEGORY"%type,
p_RESOLVED_BY "INTERFACE_DEFECT_REPORT"."RESOLVED_BY"%type,
p_RESOLVED_DATE "INTERFACE_DEFECT_REPORT"."RESOLVED_DATE"%type,
p_RESOLUTION_DESCRIPTION "INTERFACE_DEFECT_REPORT"."RESOLUTION_DESCRIPTION"%type,
p_DIS_NOT_RESOLUTION "INTERFACE_DEFECT_REPORT"."DISPATCHER_NOTIFIED_RESOLUTION"%type,
p_RESOLVED_LOCATION "INTERFACE_DEFECT_REPORT"."RESOLVED_LOCATION"%type,
p_FAULT_CONFIRM "INTERFACE_DEFECT_REPORT"."FAULT_CONFIRM"%type,
p_REPORTED_BY "INTERFACE_DEFECT_REPORT"."REPORTED_BY"%type,
p_SDR "INTERFACE_DEFECT_REPORT"."SDR"%type,
p_DEFECT_GATE "INTERFACE_DEFECT_REPORT"."DEFECT_GATE"%type,
p_AUTO_GENERATE_DEFECT "INTERFACE_DEFECT_REPORT"."AUTO_GENERATE_DEFECT"%type,
p_INTERFACE_EXTERNAL_REFERENCE "INTERFACE_DEFECT_REPORT"."INTERFACE_EXTERNAL_REFERENCE"%type,
--36077
p_PARAGRAPH "INTERFACE_DEFECT_REPORT"."PARAGRAPH"%type,
p_DELAY "INTERFACE_DEFECT_REPORT"."DELAY"%type,
p_WO "INTERFACE_DEFECT_REPORT"."WO"%type ,
p_DEFECT_CATEGORY "INTERFACE_DEFECT_REPORT"."DEFECT_CATEGORY"%type )

is

t_defect "INTERFACE_DEFECT_REPORT"%rowtype;

begin

t_defect.DEFECT := p_DEFECT ;
t_defect.DEFECT_ITEM := p_DEFECT_ITEM ;
t_defect.AC := p_AC;
t_defect.CHAPTER := p_CHAPTER;
t_defect.SECTION := p_SECTION ;
t_defect.FLIGHT := p_FLIGHT ;
t_defect.FLIGHT_PHASE := p_FLIGHT_PHASE ;
t_defect.DEFECT_DESCRIPTION := p_DEFECT_DESCRIPTION ;
t_defect.STATION := p_STATION;
t_defect.MODIFIED_BY := p_MODIFIED_BY;
t_defect.MODIFIED_DATE := p_MODIFIED_DATE;
t_defect.REPORTED_DATE := p_DEFECT_DATE;
t_defect.MDDR := p_MDDR;
t_defect.DEFER := p_DEFER ;
t_defect.DEFER_BY := p_DEFER_BY;
t_defect.DEFER_DATE := p_DEFER_DATE;
t_defect.DEFER_TO_DATE := p_DEFER_TO_DATE;
t_defect.MEL_NUMBER := p_MEL_NUMBER;
t_defect.DEFER_CATEGORY := p_DEFER_CATEGORY;
t_defect.SCHEDULE_HOURS := p_SCHEDULE_HOURS;
t_defect.SCHEDULE_CYCLES := p_SCHEDULE_CYCLES;
t_defect.SCHEDULE_DAYS := p_SCHEDULE_DAYS;
t_defect.DEFER_TO_NEXT_EC := p_DEFER_TO_NEXT_EC;
t_defect.SKILL := p_SKILL;
t_defect.MAN_HOURS := p_MAN_HOURS;
t_defect.MAN_REQUIRED := p_MAN_REQUIRED;
t_defect.CAPABILITY_AREA := p_CAPABILITY_AREA;
t_defect.PLAN_DEFECT := p_PLAN_DEFECT;
t_defect.REPEAT_NUMBER := p_REPEAT_NUMBER;
t_defect.COMPLETED_NUMBER := p_COMPLETED_NUMBER;
t_defect.OVERRIDE_MDDR_AUTO := p_OVERRIDE_MDDR_AUTO;
t_defect.DISPATCHER_NOTIFIED := p_DISPATCHER_NOTIFIED;
t_defect.DO_NOT_ALLOW_CONCESSION := p_DO_NOT_ALLOW_CONCESSION;
t_defect.MEL_CALENDAR_DAYS_FLAG := p_MEL_CALENDAR_DAYS_FLAG;
t_defect.DEFER_NOTES := p_DEFER_NOTES;
t_defect.DEFECT_TYPE := p_DEFECT_TYPE;
t_defect.MEL := p_MEL;
t_defect.RESOLUTION_CATEGORY := p_RESOLUTION_CATEGORY;
t_defect.RESOLVED_BY := p_RESOLVED_BY;
t_defect.RESOLVED_DATE := p_RESOLVED_DATE;
t_defect.RESOLUTION_DESCRIPTION := p_RESOLUTION_DESCRIPTION;
t_defect.DISPATCHER_NOTIFIED_RESOLUTION := p_DIS_NOT_RESOLUTION;
t_defect.RESOLVED_LOCATION := p_RESOLVED_LOCATION;
t_defect.FAULT_CONFIRM := p_FAULT_CONFIRM;
t_defect.REPORTED_BY := p_REPORTED_BY;
t_defect.SDR := p_SDR;
t_defect.DEFECT_GATE := p_DEFECT_GATE;
t_defect.AUTO_GENERATE_DEFECT := p_AUTO_GENERATE_DEFECT;
t_defect.INTERFACE_EXTERNAL_REFERENCE := p_INTERFACE_EXTERNAL_REFERENCE;
--36077
t_defect.PARAGRAPH := p_PARAGRAPH;
t_defect.DELAY := p_DELAY;
t_defect.WO := p_WO;
t_defect.DEFECT_CATEGORY := p_DEFECT_CATEGORY;

setDefect(t_defect);

end setDefect;

--==========================================================================
-- Add/Update a defect report record to/in Trax
procedure setDefect
(t_defect in out "INTERFACE_DEFECT_REPORT"%rowtype)
is

t_defect_report "DEFECT_REPORT"%rowtype;
t_interface_audit "INTERFACE_AUDIT"%rowtype;

defect_exists number;

begin

--Check if defect record is a duplicate
SELECT count(*)
INTO defect_exists
FROM "DEFECT_REPORT" R
WHERE R."DEFECT" = UPPER(t_defect."DEFECT") AND
      R."DEFECT_ITEM" = t_defect."DEFECT_ITEM" AND
      R."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE");

if defect_exists > 0 then
  updateDefect(t_defect);
else
  addDefect(t_defect);
end if;

end setDefect;
--====================================================================
------ Update Defect Report record
procedure updateDefect(t_defect in out "INTERFACE_DEFECT_REPORT"%rowtype)
is

t_defect_report "DEFECT_REPORT"%rowtype;
t_interface_audit "INTERFACE_AUDIT"%rowtype;

defect_record_exists number;

ex_defect_does_not_exist exception;

begin

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'IN','UPDATE' ,'DEFECT_REPORT');

t_defect."TRANSACTION" := t_interface_audit."TRANSACTION";
t_defect."TRANSACTION_ITEM" := 1;

--Check for duplicates
SELECT COUNT(*)
INTO defect_record_exists
FROM "DEFECT_REPORT"
WHERE ( "DEFECT_REPORT"."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE") ) AND
      ( "DEFECT_REPORT"."DEFECT" = UPPER(t_defect."DEFECT") )  AND
			( "DEFECT_REPORT"."DEFECT_ITEM" = t_defect."DEFECT_ITEM") ;

if defect_record_exists = 0 then
  raise ex_defect_does_not_exist;
end if;

SELECT *
INTO t_defect_report
FROM "DEFECT_REPORT"
WHERE ( "DEFECT_REPORT"."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE") ) AND
      ( "DEFECT_REPORT"."DEFECT" = UPPER(t_defect."DEFECT") )  AND
			( "DEFECT_REPORT"."DEFECT_ITEM" = t_defect."DEFECT_ITEM") ;

--Perform validation
 validateDefect(t_interface_audit, t_defect, t_defect_report);


--Modified by/Date
if (t_defect."MODIFIED_BY" is null) then
    t_defect_report."MODIFIED_BY" := 'TRAX_IFACE';
else
    t_defect_report."MODIFIED_BY" := t_defect."MODIFIED_BY";
end if;

if (t_defect."MODIFIED_DATE" is null) then
    t_defect_report."MODIFIED_DATE" := sysdate;
else
   t_defect_report."MODIFIED_DATE" := t_defect."MODIFIED_DATE";
end if;

--Update Defect Report record
UPDATE "DEFECT_REPORT" R
SET "DEFECT" = t_defect_report."DEFECT" ,
    "DEFECT_ITEM" = t_defect_report."DEFECT_ITEM" ,
    "DEFECT_TYPE" = t_defect_report."DEFECT_TYPE" ,
    "AC" =  t_defect_report."AC",
    "CHAPTER" = t_defect_report."CHAPTER",
    "SECTION" = t_defect_report."SECTION" ,
    "FLIGHT" = t_defect_report."FLIGHT" ,
    "FLIGHT_PHASE" = t_defect_report."FLIGHT_PHASE" ,
    "DEFECT_DESCRIPTION" = t_defect_report."DEFECT_DESCRIPTION",
    "STATION" = t_defect_report."STATION",
    "REPORTED_DATE" = t_defect_report."REPORTED_DATE",
    "REPORTED_HOUR" = t_defect_report."REPORTED_HOUR",
    "REPOTED_MINUTE" = t_defect_report."REPOTED_MINUTE",
    "MDDR" = t_defect_report."MDDR" ,
    "DEFER" = t_defect_report."DEFER",
    "DEFER_BY" =  t_defect_report."DEFER_BY",
    "DEFER_TO_DATE" = t_defect_report."DEFER_TO_DATE",
    "DEFER_TO_HOUR" = t_defect_report."DEFER_TO_HOUR",
    "DEFER_TO_MINUTE" = t_defect_report."DEFER_TO_MINUTE",
    "DEFER_DATE" = t_defect_report."DEFER_DATE",
    "DEFER_HOUR" = t_defect_report."DEFER_HOUR",
    "DEFER_MINUTE" = t_defect_report."DEFER_MINUTE",
    "MEL_NUMBER" = t_defect_report."MEL_NUMBER",
    "DEFER_CATEGORY" = t_defect_report."DEFER_CATEGORY",
    "SCHEDULE_HOURS" = t_defect_report."SCHEDULE_HOURS",
    "SCHEDULE_CYCLES" = t_defect_report."SCHEDULE_CYCLES" ,
    "SCHEDULE_DAYS" = t_defect_report."SCHEDULE_DAYS" ,
    "DEFER_TO_NEXT_EC" = t_defect_report."DEFER_TO_NEXT_EC",
    "SKILL" = t_defect_report."SKILL" ,
    "MAN_HOURS" = t_defect_report."MAN_HOURS" ,
    "MAN_REQUIRED" = t_defect_report."MAN_REQUIRED" ,
    "CAPABILITY_AREA" = t_defect_report."CAPABILITY_AREA" ,
    "PLAN_DEFECT" = t_defect_report."PLAN_DEFECT",
    "REPEAT_NUMBER" = t_defect_report."REPEAT_NUMBER" ,
    "COMPLETED_NUMBER" = t_defect_report."COMPLETED_NUMBER" ,
    "OVERRIDE_MDDR_AUTO" = t_defect_report."OVERRIDE_MDDR_AUTO" ,
    "DISPATCHER_NOTIFIED" = t_defect_report."DISPATCHER_NOTIFIED" ,
    "NOT_DO_ALLOW_CONCESSION" = t_defect_report."NOT_DO_ALLOW_CONCESSION" ,
    "MEL_CALENDAR_DAYS_FLAG" = t_defect_report."MEL_CALENDAR_DAYS_FLAG" ,
    "DEFER_NOTES" = t_defect_report."DEFER_NOTES",
    "MEL" = t_defect_report."MEL" ,
    "STATUS" = t_defect_report."STATUS" ,
    "RESOLUTION_CATEGORY" = t_defect_report."RESOLUTION_CATEGORY" ,
    "RESOLVED_BY" = t_defect_report."RESOLVED_BY" ,
    "RESOLVED_DATE" = t_defect_report."RESOLVED_DATE" ,
    "RESOLUTION_DESCRIPTION" = t_defect_report."RESOLUTION_DESCRIPTION" ,
    "DISPATCHER_NOTIFIED_RESOLUTION" = t_defect_report."DISPATCHER_NOTIFIED_RESOLUTION" ,
    "RESOLVED_LOCATION" = t_defect_report."RESOLVED_LOCATION" ,
    "FAULT_CONFIRM" = t_defect_report."FAULT_CONFIRM" ,
    "REPORTED_BY" = t_defect_report."REPORTED_BY" ,
    "MODIFIED_BY" = t_defect_report."MODIFIED_BY" ,
    "MODIFIED_DATE" = t_defect_report."MODIFIED_DATE",
    "SDR" = t_defect_report."SDR",
    "DEFECT_GATE" = t_defect_report."DEFECT_GATE"
    --36077
    ,"PARAGRAPH" = t_defect_report."PARAGRAPH" ,
     "DELAY" = t_defect_report."DELAY" ,
     "WO" = t_defect_report."WO" ,
     "DEFECT_CATEGORY" = t_defect_report."DEFECT_CATEGORY"


WHERE R."DEFECT_TYPE" = UPPER(t_defect."DEFECT_TYPE") AND
      R."DEFECT" = UPPER(t_defect."DEFECT") AND
      R."DEFECT_ITEM" = t_defect."DEFECT_ITEM";


--Begin Exception Handling
exception

when ex_defect_does_not_exist then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, -20015, 'Defect Record does not exist for updating', 'Y');

when others then
  PKG_INTERFACE_AUDIT.setException(t_interface_audit, SQLCODE, substr(SQLERRM, 1, 1000), 'N');
  RAISE;
--end exception handling

end updateDefect;

--=================================================================================
----- Validate Defect record
procedure validateDefect(t_interface_audit in out "INTERFACE_AUDIT"%ROWTYPE,
t_defect in out "INTERFACE_DEFECT_REPORT"%ROWTYPE,
t_defect_report in out "DEFECT_REPORT"%ROWTYPE)
is
BEGIN
  pkg_iface_defect_reports_val.validateDefect(t_interface_audit, t_defect, t_defect_report);
end validateDefect;

--#############################################################################
-- Export a defect record from Trax
procedure exportDefect
(t_defect_report in out "DEFECT_REPORT"%rowtype, t_interface_audit in out "INTERFACE_AUDIT" %rowtype)
is

t_defect "INTERFACE_DEFECT_REPORT"%rowtype;

begin

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'OUT',t_interface_audit."TRANSACTION_METHOD", 'DEFECT_REPORT');

UPDATE "INTERFACE_AUDIT" T
 SET "MESSAGE_NEEDS_TO_BE_SENT" = 'Y'
WHERE T."TRANSACTION" = t_interface_audit."TRANSACTION" ;

t_defect."TRANSACTION" := t_interface_audit."TRANSACTION";
t_defect."TRANSACTION_ITEM" := 1;

t_defect."DEFECT" := t_defect_report."DEFECT";
t_defect."DEFECT_ITEM" := t_defect_report."DEFECT_ITEM";
t_defect."DEFECT_TYPE" := t_defect_report."DEFECT_TYPE";
t_defect."AC" := t_defect_report."AC";
t_defect."CHAPTER" := t_defect_report."CHAPTER";
t_defect."SECTION" := t_defect_report."SECTION";
t_defect."FLIGHT" := t_defect_report."FLIGHT";
t_defect."FLIGHT_PHASE" := t_defect_report."FLIGHT_PHASE";
t_defect."DEFECT_DESCRIPTION" := t_defect_report."DEFECT_DESCRIPTION";
t_defect."STATION" := t_defect_report."STATION";

t_defect."REPORTED_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."REPORTED_DATE", t_defect_report."REPORTED_HOUR", t_defect_report."REPOTED_MINUTE");

t_defect."MDDR" := t_defect_report."MDDR";
t_defect."DEFER" := t_defect_report."DEFER";
t_defect."DEFER_BY" := t_defect_report."DEFER_BY";

t_defect."DEFER_TO_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."DEFER_TO_DATE", t_defect_report."DEFER_TO_HOUR", t_defect_report."DEFER_TO_MINUTE");

t_defect."DEFER_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."DEFER_DATE", t_defect_report."DEFER_HOUR", t_defect_report."DEFER_MINUTE");

t_defect."MEL_NUMBER" := t_defect_report."MEL_NUMBER";
t_defect."DEFER_CATEGORY" := t_defect_report."DEFER_CATEGORY";
t_defect."SCHEDULE_HOURS" := t_defect_report."SCHEDULE_HOURS";
t_defect."SCHEDULE_CYCLES" := t_defect_report."SCHEDULE_CYCLES";
t_defect."SCHEDULE_DAYS" := t_defect_report."SCHEDULE_DAYS";
t_defect."DEFER_TO_NEXT_EC" := t_defect_report."DEFER_TO_NEXT_EC";
t_defect."SKILL" := t_defect_report."SKILL";
t_defect."MAN_HOURS" := t_defect_report."MAN_HOURS";
t_defect."MAN_REQUIRED" := t_defect_report."MAN_REQUIRED";
t_defect."CAPABILITY_AREA" := t_defect_report."CAPABILITY_AREA";
t_defect."PLAN_DEFECT" := t_defect_report."PLAN_DEFECT";
t_defect."REPEAT_NUMBER" := t_defect_report."REPEAT_NUMBER";
t_defect."COMPLETED_NUMBER" := t_defect_report."COMPLETED_NUMBER";
t_defect."OVERRIDE_MDDR_AUTO" := t_defect_report."OVERRIDE_MDDR_AUTO";
t_defect."DISPATCHER_NOTIFIED" := t_defect_report."DISPATCHER_NOTIFIED";
t_defect."DO_NOT_ALLOW_CONCESSION" := t_defect_report."NOT_DO_ALLOW_CONCESSION";
t_defect."MEL_CALENDAR_DAYS_FLAG" := t_defect_report."MEL_CALENDAR_DAYS_FLAG";
t_defect."DEFER_NOTES" := t_defect_report."DEFER_NOTES";
t_defect."MEL" := t_defect_report."MEL";
t_defect."RESOLUTION_CATEGORY" := t_defect_report."RESOLUTION_CATEGORY";
t_defect."RESOLVED_BY" := t_defect_report."RESOLVED_BY";
t_defect."RESOLVED_DATE" := t_defect_report."RESOLVED_DATE";
t_defect."RESOLUTION_DESCRIPTION" := t_defect_report."RESOLUTION_DESCRIPTION";
t_defect."DISPATCHER_NOTIFIED_RESOLUTION" := t_defect_report."DISPATCHER_NOTIFIED_RESOLUTION";
t_defect."RESOLVED_LOCATION" := t_defect_report."RESOLVED_LOCATION";
t_defect."FAULT_CONFIRM" := t_defect_report."FAULT_CONFIRM";
t_defect."REPORTED_BY" := t_defect_report."REPORTED_BY";
t_defect."MODIFIED_BY" := t_defect_report."MODIFIED_BY";
t_defect."MODIFIED_DATE" := t_defect_report."MODIFIED_DATE";
t_defect."SDR" := t_defect_report."SDR";
t_defect."DEFECT_GATE" := t_defect_report."DEFECT_GATE";
t_defect."INTERFACE_EXTERNAL_REFERENCE" := t_defect_report."INTERFACE_EXTERNAL_REFERENCE";

-- Modified by/date
   if (t_defect."MODIFIED_BY" is null) then
      t_defect."MODIFIED_BY" := 'TRAX_IFACE';
   end if;

   if (t_defect."MODIFIED_DATE" is null) then
      t_defect."MODIFIED_DATE" := sysdate;
   end if;

--Write to Table
insert into "INTERFACE_DEFECT_REPORT"
values t_defect;

end exportDefect;
--#############################################################################
-- Export troubleshooting tab from defect record from Trax
procedure exportDefectTroubleShooting
(t_drt IN OUT "INTERFACE_DEFECT_TROUBLESHOOT"%rowtype, t_interface_audit in out "INTERFACE_AUDIT" %ROWTYPE)
is

TYPE cur_type is ref cursor;
c_defect_tb cur_type;

t_defect_tb "DEFECT_REPORT_TROUBLE_SHOOTING"%rowtype;
t_defect "INTERFACE_DEFECT_REPORT"%rowtype;
t_defect_report "DEFECT_REPORT"%rowtype;

begin

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'OUT',t_interface_audit."TRANSACTION_METHOD", 'DEFECT_REPORT');

UPDATE "INTERFACE_AUDIT" T
 SET "MESSAGE_NEEDS_TO_BE_SENT" = 'Y'
WHERE T."TRANSACTION" = t_interface_audit."TRANSACTION" ;


t_drt."TRANSACTION" := t_interface_audit."TRANSACTION";
t_drt."TRANSACTION_ITEM" := 1;
t_drt."TRANSACTION_LINE_ITEM" :=  0;


--insert to Interface Defect Report
begin
SELECT *
INTO t_defect_report
FROM "DEFECT_REPORT" DR
WHERE DR."DEFECT_TYPE" = t_drt."DEFECT_TYPE" AND
      DR."DEFECT" = t_drt."DEFECT" AND
      DR."DEFECT_ITEM" = t_drt."DEFECT_ITEM";
exception
when no_data_found then
    null;
    return;
end;

t_defect."TRANSACTION" := t_interface_audit."TRANSACTION";
t_defect."TRANSACTION_ITEM" := 1;
t_defect."DEFECT" := t_defect_report."DEFECT";
t_defect."DEFECT_ITEM" := t_defect_report."DEFECT_ITEM";
t_defect."DEFECT_TYPE" := t_defect_report."DEFECT_TYPE";
t_defect."AC" := t_defect_report."AC";
t_defect."CHAPTER" := t_defect_report."CHAPTER";
t_defect."SECTION" := t_defect_report."SECTION";
t_defect."FLIGHT" := t_defect_report."FLIGHT";
t_defect."FLIGHT_PHASE" := t_defect_report."FLIGHT_PHASE";
t_defect."DEFECT_DESCRIPTION" := t_defect_report."DEFECT_DESCRIPTION";
t_defect."STATION" := t_defect_report."STATION";
t_defect."REPORTED_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."REPORTED_DATE", t_defect_report."REPORTED_HOUR", t_defect_report."REPOTED_MINUTE");
t_defect."MDDR" := t_defect_report."MDDR";
t_defect."DEFER" := t_defect_report."DEFER";
t_defect."DEFER_BY" := t_defect_report."DEFER_BY";
t_defect."DEFER_TO_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."DEFER_TO_DATE", t_defect_report."DEFER_TO_HOUR", t_defect_report."DEFER_TO_MINUTE");
t_defect."DEFER_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."DEFER_DATE", t_defect_report."DEFER_HOUR", t_defect_report."DEFER_MINUTE");
t_defect."MEL_NUMBER" := t_defect_report."MEL_NUMBER";
t_defect."DEFER_CATEGORY" := t_defect_report."DEFER_CATEGORY";
t_defect."SCHEDULE_HOURS" := t_defect_report."SCHEDULE_HOURS";
t_defect."SCHEDULE_CYCLES" := t_defect_report."SCHEDULE_CYCLES";
t_defect."SCHEDULE_DAYS" := t_defect_report."SCHEDULE_DAYS";
t_defect."DEFER_TO_NEXT_EC" := t_defect_report."DEFER_TO_NEXT_EC";
t_defect."SKILL" := t_defect_report."SKILL";
t_defect."MAN_HOURS" := t_defect_report."MAN_HOURS";
t_defect."MAN_REQUIRED" := t_defect_report."MAN_REQUIRED";
t_defect."CAPABILITY_AREA" := t_defect_report."CAPABILITY_AREA";
t_defect."PLAN_DEFECT" := t_defect_report."PLAN_DEFECT";
t_defect."REPEAT_NUMBER" := t_defect_report."REPEAT_NUMBER";
t_defect."COMPLETED_NUMBER" := t_defect_report."COMPLETED_NUMBER";
t_defect."OVERRIDE_MDDR_AUTO" := t_defect_report."OVERRIDE_MDDR_AUTO";
t_defect."DISPATCHER_NOTIFIED" := t_defect_report."DISPATCHER_NOTIFIED";
t_defect."DO_NOT_ALLOW_CONCESSION" := t_defect_report."NOT_DO_ALLOW_CONCESSION";
t_defect."MEL_CALENDAR_DAYS_FLAG" := t_defect_report."MEL_CALENDAR_DAYS_FLAG";
t_defect."DEFER_NOTES" := t_defect_report."DEFER_NOTES";
t_defect."MEL" := t_defect_report."MEL";
t_defect."RESOLUTION_CATEGORY" := t_defect_report."RESOLUTION_CATEGORY";
t_defect."RESOLVED_BY" := t_defect_report."RESOLVED_BY";
t_defect."RESOLVED_DATE" := t_defect_report."RESOLVED_DATE";
t_defect."RESOLUTION_DESCRIPTION" := t_defect_report."RESOLUTION_DESCRIPTION";
t_defect."DISPATCHER_NOTIFIED_RESOLUTION" := t_defect_report."DISPATCHER_NOTIFIED_RESOLUTION";
t_defect."RESOLVED_LOCATION" := t_defect_report."RESOLVED_LOCATION";
t_defect."FAULT_CONFIRM" := t_defect_report."FAULT_CONFIRM";
t_defect."REPORTED_BY" := t_defect_report."REPORTED_BY";
t_defect."MODIFIED_BY" := t_defect_report."MODIFIED_BY";
t_defect."MODIFIED_DATE" := t_defect_report."MODIFIED_DATE";
t_defect."SDR" := t_defect_report."SDR";

-- Modified by/date
if (t_defect."MODIFIED_BY" is null) then
   t_defect."MODIFIED_BY" := 'TRAX_IFACE';
end if;

if (t_defect."MODIFIED_DATE" is null) then
   t_defect."MODIFIED_DATE" := sysdate;
end if;

--Write to Table
insert into "INTERFACE_DEFECT_REPORT"
values t_defect;

--end load

--When deleting, do not include the troubleshooting item that is being deleted
if t_interface_audit."TRANSACTION_METHOD" = 'DELETE' then

   open c_defect_tb for
      SELECT *
      FROM "DEFECT_REPORT_TROUBLE_SHOOTING" DR
      WHERE DR."DEFECT_TYPE" = t_drt."DEFECT_TYPE" AND
            DR."DEFECT" = t_drt."DEFECT" AND
            DR."DEFECT_ITEM" = t_drt."DEFECT_ITEM" AND
            DR."TROUBLE_SHOOTING_ITEM" <> t_drt."TROUBLE_SHOOTING_ITEM";

else
   open c_defect_tb for
      SELECT *
      FROM "DEFECT_REPORT_TROUBLE_SHOOTING" DR
      WHERE DR."DEFECT_TYPE" = t_drt."DEFECT_TYPE" AND
            DR."DEFECT" = t_drt."DEFECT" AND
            DR."DEFECT_ITEM" = t_drt."DEFECT_ITEM";


end if;

loop
fetch c_defect_tb into t_defect_tb;
exit when c_defect_tb%notfound;

t_drt."TRANSACTION_LINE_ITEM" := t_drt."TRANSACTION_LINE_ITEM" + 1;
t_drt."DEFECT_TYPE" := t_defect_tb."DEFECT_TYPE";
t_drt."DEFECT" := t_defect_tb."DEFECT";
t_drt."DEFECT_ITEM" := t_defect_tb."DEFECT_ITEM";
t_drt."TROUBLE_SHOOTING_ITEM" := t_defect_tb."TROUBLE_SHOOTING_ITEM";
t_drt."STATUS" := t_defect_tb."STATUS";
t_drt."STATION" := t_defect_tb."STATION";
t_drt."TROUBLE_SHOOTING_CODE" := t_defect_tb."TROUBLE_SHOOTING_CODE";
t_drt."TROUBLE_SHOOTING_BY" := t_defect_tb."TROUBLE_SHOOTING_BY";
t_drt."TROUBLE_SHOOTING_ON" := t_defect_tb."TROUBLE_SHOOTING_ON";
t_drt."TROUBLE_SHOOTING_TEXT" := t_defect_tb."TROUBLE_SHOOTING_TEXT";
t_drt."NOTES" := t_defect_tb."NOTES";
t_drt."TROUBLE_SHOOTING_DEFECT_TYPE" := t_defect_tb."TROUBLE_SHOOTING_DEFECT_TYPE";
t_drt."TROUBLE_SHOOTING_DEFECT" := t_defect_tb."TROUBLE_SHOOTING_DEFECT";
t_drt."TROUBLE_SHOOTING_DEFECT_ITEM" := t_defect_tb."TROUBLE_SHOOTING_DEFECT_ITEM";
t_drt."REQUIRED_INSPECTION_ITEM" := t_defect_tb."REQUIRED_INSPECTION_ITEM";
t_drt."REQUIRED_INSPECTION_BY" := t_defect_tb."REQUIRED_INSPECTION_BY";
t_drt."TROUBLE_SHOOTING_DEFECT" := t_defect_tb."TROUBLE_SHOOTING_DEFECT";
t_drt."CONTROL_CATEGORY" := t_defect_tb."CONTROL_CATEGORY";
t_drt."REFERENCE_CODE" := t_defect_tb."REFERENCE_CODE";

-- Modified by/date
if (t_drt."MODIFIED_BY" is null) then
    t_drt."MODIFIED_BY" := 'TRAX_IFACE';
end if;

if (t_drt."MODIFIED_DATE" is null) then
    t_drt."MODIFIED_DATE" := sysdate;
end if;


--insert troubleshooting data
insert into "INTERFACE_DEFECT_TROUBLESHOOT"
values t_drt;
--end load

end loop;

end exportDefectTroubleShooting;

--=============================================================================
-- Export AC in out of service header record in Trax
procedure exportACINOUT_SRV_HDR
(t_acinout in out "AC_OUT_OF_SERVICE"%rowtype,
t_interface_audit in out "INTERFACE_AUDIT" %rowtype)
is
t_ac_header "INTERFACE_AC_IN_OUT_SRV_HEADER"%rowtype;

begin

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'OUT',t_interface_audit."TRANSACTION_METHOD", 'AC_IN_OUT_SERVICE');

UPDATE "INTERFACE_AUDIT" T
 SET "MESSAGE_NEEDS_TO_BE_SENT" = 'Y'
WHERE T."TRANSACTION" = t_interface_audit."TRANSACTION" ;

t_ac_header."TRANSACTION" := t_interface_audit."TRANSACTION";
t_ac_header."TRANSACTION_ITEM" := 1;

--------
t_ac_header."OUT_SERVICE_NO" := t_acinout."OUT_SERVICE_NO";
t_ac_header."AC" := t_acinout."AC";
t_ac_header."FLIGHT_STATUS" := t_acinout."FLIGHT_STATUS";
t_ac_header."OUT_OF_SERVICE_STATION" := t_acinout."OUT_OF_SERVICE_STATION";

t_ac_header."AC_SCHEDULE_OUT_SERVICE_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_acinout."AC_SCHEDULE_OUT_SERVICE_DATE", t_acinout."AC_SCHEDULE_OUT_SERVICE_HOUR", t_acinout."AC_SCHEDULE_OUT_SERVICE_MINUTE");

t_ac_header."AC_DEFECT_TYPE_OUT_SERVICE" := t_acinout."AC_DEFECT_TYPE_OUT_SERVICE";
t_ac_header."AC_DEFECT_OUT_OF_SERVICE" := t_acinout."AC_DEFECT_OUT_OF_SERIVE";
t_ac_header."AC_DEFECT_ITEM_OUT_OF_SERVICE" := t_acinout."AC_DEFECT_ITEM_OUT_OF_SERVICE";

t_ac_header."AC_OUT_OF_SVR_ADVISED_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_acinout."AC_OUT_OF_SVR_ADVISED_DATE", t_acinout."AC_OUT_OF_SVR_ADVISED_HOUR", t_acinout."AC_OUT_OF_SVR_ADVISED_MINUTE");

t_ac_header."AC_SCHEDULE_IN_SERVICE_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_acinout."AC_SCHEDULE_IN_SERVICE_DATE", t_acinout."AC_SCHEDULE_IN_SERVICE_HOUR", t_acinout."AC_SCHEDULE_IN_SERVICE_MINUTE");

t_ac_header."NOTES" := t_acinout."NOTES";
t_ac_header."DOCUMENT_NO" := t_acinout."DOCUMENT_NO";
t_ac_header."MODIFIED_DATE" := t_acinout."MODIFIED_DATE";
t_ac_header."MODIFIED_BY" := t_acinout."MODIFIED_BY";


-- Modified by/date
   if (t_ac_header."MODIFIED_BY" is null) then
      t_ac_header."MODIFIED_BY" := 'TRAX_IFACE';
   end if;

   if (t_ac_header."MODIFIED_DATE" is null) then
      t_ac_header."MODIFIED_DATE" := sysdate;
   end if;

--insert data
insert into "INTERFACE_AC_IN_OUT_SRV_HEADER"
values t_ac_header;
--end load

end exportACINOUT_SRV_HDR;

--=============================================================================
-- Export AC in out of service detail record in Trax
procedure exportACINOUT_SRV_DTL
(t_acinout in out "AC_OUT_OF_SERVICE_DETAIL"%rowtype,
t_interface_audit in out "INTERFACE_AUDIT" %ROWTYPE)
is
t_ac_dtl "INTERFACE_AC_IN_OUT_SRV_DETAIL"%rowtype;
t_ac_header "INTERFACE_AC_IN_OUT_SRV_HEADER"%rowtype;
t_ac_srv_header "AC_OUT_OF_SERVICE"%rowtype;

record_found number;

begin

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'OUT',t_interface_audit."TRANSACTION_METHOD", 'AC_IN_OUT_SERVICE');

UPDATE "INTERFACE_AUDIT" T
 SET "MESSAGE_NEEDS_TO_BE_SENT" = 'Y'
WHERE T."TRANSACTION" = t_interface_audit."TRANSACTION" ;

t_ac_dtl."TRANSACTION" := t_interface_audit."TRANSACTION";
t_ac_dtl."TRANSACTION_ITEM" := 1;

----------

t_ac_dtl."OUT_SERVICE_NO" := t_acinout."OUT_SERVICE_NO";
t_ac_dtl."DEFECT_TYPE" := t_acinout."DEFECT_TYPE";
t_ac_dtl."DEFECT" := t_acinout."DEFECT";
t_ac_dtl."DEFECT_ITEM" := t_acinout."DEFECT_ITEM";
t_ac_dtl."AC" := t_acinout."AC";
t_ac_dtl."WO" := t_acinout."WO";
t_ac_dtl."FLIGHT_STATUS" := t_acinout."FLIGHT_STATUS";

t_ac_dtl."AC_SCHEDULE_OUT_SERVICE_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_acinout."AC_SCHEDULE_OUT_SERVICE_DATE", t_acinout."AC_SCHEDULE_OUT_SERVICE_HOUR", t_acinout."AC_SCHEDULE_OUT_SERVICE_MINUTE");
t_ac_dtl."AC_OUT_OF_SVR_ADVISED_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_acinout."AC_OUT_OF_SVR_ADVISED_DATE", t_acinout."AC_OUT_OF_SVR_ADVISED_HOUR", t_acinout."AC_OUT_OF_SVR_ADVISED_MINUTE");
t_ac_dtl."AC_SCHEDULE_IN_SERVICE_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_acinout."AC_SCHEDULE_IN_SERVICE_DATE", t_acinout."AC_SCHEDULE_IN_SERVICE_HOUR", t_acinout."AC_SCHEDULE_IN_SERVICE_MINUTE");

t_ac_dtl."NOTES" := t_acinout."NOTES";
t_ac_dtl."DOCUMENT_NO" := t_acinout."DOCUMENT_NO";
t_ac_dtl."HOLD_BOARDING" := t_acinout."HOLD_BOARDING";

t_ac_dtl."AC_ACTUAL_IN_SERVICE_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_acinout."AC_ACTUAL_IN_SERVICE_DATE", t_acinout."AC_ACTUAL_IN_SERVICE_HOUR", t_acinout."AC_ACTUAL_IN_SERVICE_MINUTE");
t_ac_dtl."DOCUMENT_NO" := t_acinout."DOCUMENT_NO";
t_ac_dtl."MODIFIED_BY" := t_acinout."MODIFIED_BY";
t_ac_dtl."MODIFIED_DATE" := t_acinout."MODIFIED_DATE";


-- Modified by/date
   if (t_ac_dtl."MODIFIED_BY" is null) then
      t_ac_dtl."MODIFIED_BY" := 'TRAX_IFACE';
   end if;

   if (t_ac_dtl."MODIFIED_DATE" is null) then
      t_ac_dtl."MODIFIED_DATE" := sysdate;
   end if;

--insert data if the record has been updated or added
   insert into "INTERFACE_AC_IN_OUT_SRV_DETAIL"
   values t_ac_dtl;

--end load

--Export header record
SELECT count(*)
INTO record_found
FROM "AC_OUT_OF_SERVICE" ACOUT
WHERE ACOUT."OUT_SERVICE_NO" = t_ac_dtl."OUT_SERVICE_NO" AND
      ACOUT."AC" = t_ac_dtl."AC";

if record_found = 0 then
  return;
end if;

SELECT *
INTO t_ac_srv_header
FROM "AC_OUT_OF_SERVICE" ACOUT
WHERE ACOUT."OUT_SERVICE_NO" = t_ac_dtl."OUT_SERVICE_NO" AND
      ACOUT."AC" = t_ac_dtl."AC";

--load data
t_ac_header."TRANSACTION" := t_interface_audit."TRANSACTION";
t_ac_header."TRANSACTION_ITEM" := 1;

t_ac_header."OUT_SERVICE_NO" := t_ac_srv_header."OUT_SERVICE_NO";
t_ac_header."AC" := t_ac_srv_header."AC";
t_ac_header."FLIGHT_STATUS" := t_ac_srv_header."FLIGHT_STATUS";
t_ac_header."OUT_OF_SERVICE_STATION" := t_ac_srv_header."OUT_OF_SERVICE_STATION";

t_ac_header."AC_SCHEDULE_OUT_SERVICE_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_ac_srv_header."AC_SCHEDULE_OUT_SERVICE_DATE", t_ac_srv_header."AC_SCHEDULE_OUT_SERVICE_HOUR", t_ac_srv_header."AC_SCHEDULE_OUT_SERVICE_MINUTE");

t_ac_header."AC_DEFECT_TYPE_OUT_SERVICE" := t_ac_srv_header."AC_DEFECT_TYPE_OUT_SERVICE";
t_ac_header."AC_DEFECT_OUT_OF_SERVICE" := t_ac_srv_header."AC_DEFECT_OUT_OF_SERIVE";
t_ac_header."AC_DEFECT_ITEM_OUT_OF_SERVICE" := t_ac_srv_header."AC_DEFECT_ITEM_OUT_OF_SERVICE";

t_ac_header."AC_OUT_OF_SVR_ADVISED_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_ac_srv_header."AC_OUT_OF_SVR_ADVISED_DATE", t_ac_srv_header."AC_OUT_OF_SVR_ADVISED_HOUR", t_ac_srv_header."AC_OUT_OF_SVR_ADVISED_MINUTE");

t_ac_header."AC_SCHEDULE_IN_SERVICE_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_ac_srv_header."AC_SCHEDULE_IN_SERVICE_DATE", t_ac_srv_header."AC_SCHEDULE_IN_SERVICE_HOUR", t_ac_srv_header."AC_SCHEDULE_IN_SERVICE_MINUTE");

t_ac_header."NOTES" := t_ac_srv_header."NOTES";
t_ac_header."DOCUMENT_NO" := t_ac_srv_header."DOCUMENT_NO";

t_ac_header."MODIFIED_BY" := 'TRAX_IFACE';
t_ac_header."MODIFIED_DATE" := sysdate;


--insert ac out of service header data
insert into "INTERFACE_AC_IN_OUT_SRV_HEADER"
values t_ac_header;
--end load


end exportACINOUT_SRV_DTL;

-- ------------------------------------------------------------------
-- Get a Defect Record from Trax
procedure getDefectReport
(p_DEFECT_TYPE "INTERFACE_DEFECT_REPORT"."DEFECT_TYPE"%type,
  p_DEFECT  "INTERFACE_DEFECT_REPORT"."DEFECT"%TYPE,
  p_DEFECT_ITEM "INTERFACE_DEFECT_REPORT"."DEFECT_ITEM"%TYPE,
  p_INTERFACE_DEFECT_CUR in out c_interface_defect_report)

IS
t_defect_report "DEFECT_REPORT"%rowtype;
t_defect "INTERFACE_DEFECT_REPORT"%rowtype;
t_interface_audit "INTERFACE_AUDIT"%rowtype;

TYPE cur_type is ref cursor;
c_defect cur_type;

begin

PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'IN', 'GET', 'DEFECT_REPORT');

t_defect."TRANSACTION" := t_interface_audit."TRANSACTION";
t_defect."TRANSACTION_ITEM" := 0;

open c_defect for
SELECT *
FROM "DEFECT_REPORT" DR
WHERE DR."DEFECT_TYPE" = p_DEFECT_TYPE AND
      DR."DEFECT" = p_DEFECT AND
      DR."DEFECT_ITEM" = p_DEFECT_ITEM;

loop
fetch c_defect into t_defect_report;
exit when c_defect%notfound;

------------------------
t_defect."TRANSACTION_ITEM" := t_defect."TRANSACTION_ITEM" + 1;
t_defect."DEFECT" := t_defect_report."DEFECT" ;
t_defect."DEFECT_ITEM" := t_defect_report."DEFECT_ITEM" ;
t_defect."DEFECT_TYPE" := t_defect_report."DEFECT_TYPE" ;
t_defect."AC" :=  t_defect_report."AC";
t_defect."CHAPTER" := t_defect_report."CHAPTER";
t_defect."SECTION" := t_defect_report."SECTION" ;
t_defect."FLIGHT" := t_defect_report."FLIGHT" ;
t_defect."FLIGHT_PHASE" := t_defect_report."FLIGHT_PHASE" ;
t_defect."DEFECT_DESCRIPTION" := t_defect_report."DEFECT_DESCRIPTION";
t_defect."STATION" := t_defect_report."STATION";
t_defect."REPORTED_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."REPORTED_DATE",t_defect_report."REPORTED_HOUR",t_defect_report."REPOTED_MINUTE");
t_defect."MDDR" := t_defect_report."MDDR" ;
t_defect."DEFER" := t_defect_report."DEFER";
t_defect."DEFER_BY" :=  t_defect_report."DEFER_BY";
t_defect."DEFER_TO_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."DEFER_TO_DATE", t_defect_report."DEFER_TO_HOUR", t_defect_report."DEFER_TO_MINUTE");
t_defect."DEFER_DATE" := PKG_APPLICATION_FUNCTION.getCombinedDate(t_defect_report."DEFER_DATE", t_defect_report."DEFER_HOUR", t_defect_report."DEFER_MINUTE");
t_defect."MEL_NUMBER" := t_defect_report."MEL_NUMBER";
t_defect."DEFER_CATEGORY" := t_defect_report."DEFER_CATEGORY";
t_defect."SCHEDULE_HOURS" := t_defect_report."SCHEDULE_HOURS";
t_defect."SCHEDULE_CYCLES" := t_defect_report."SCHEDULE_CYCLES" ;
t_defect."SCHEDULE_DAYS" := t_defect_report."SCHEDULE_DAYS" ;
t_defect."DEFER_TO_NEXT_EC" := t_defect_report."DEFER_TO_NEXT_EC";
t_defect."SKILL" := t_defect_report."SKILL" ;
t_defect."MAN_HOURS" := t_defect_report."MAN_HOURS" ;
t_defect."MAN_REQUIRED" := t_defect_report."MAN_REQUIRED" ;
t_defect."CAPABILITY_AREA" := t_defect_report."CAPABILITY_AREA" ;
--36077
t_defect."PARAGRAPH" := t_defect_report."PARAGRAPH" ;
t_defect."DELAY" := t_defect_report."DELAY" ;
t_defect."WO" := t_defect_report."WO" ;
t_defect."DEFECT_CATEGORY" := t_defect_report."DEFECT_CATEGORY" ;


--Plan defect
if t_defect_report."PLAN_DEFECT" = 'YES' and t_defect_report."PLAN_DEFECT" is not null then
   t_defect."PLAN_DEFECT" := 'Y';
else
   t_defect."PLAN_DEFECT" := 'N';
end if;

t_defect."REPEAT_NUMBER" := t_defect_report."REPEAT_NUMBER" ;
t_defect."COMPLETED_NUMBER" := t_defect_report."COMPLETED_NUMBER" ;

--Override MDDR auto
if t_defect_report."OVERRIDE_MDDR_AUTO" = 'YES' and t_defect_report."OVERRIDE_MDDR_AUTO" is not null then
   t_defect."OVERRIDE_MDDR_AUTO" := 'Y';
else
   t_defect."OVERRIDE_MDDR_AUTO" := 'N';
end if;

t_defect."DISPATCHER_NOTIFIED" := t_defect_report."DISPATCHER_NOTIFIED" ;

--Do not allow concession
if t_defect_report."NOT_DO_ALLOW_CONCESSION" = 'YES' and t_defect_report."NOT_DO_ALLOW_CONCESSION" is not null then
   t_defect."DO_NOT_ALLOW_CONCESSION" := 'Y';
else
   t_defect."DO_NOT_ALLOW_CONCESSION" := 'N';
end if;

--Calendar days
if t_defect_report."MEL_CALENDAR_DAYS_FLAG" = 'Y' and t_defect_report."MEL_CALENDAR_DAYS_FLAG" is not null then
   t_defect."MEL_CALENDAR_DAYS_FLAG" := 'Y';
else
   t_defect."MEL_CALENDAR_DAYS_FLAG" := 'N';
end if;


t_defect."DEFER_NOTES" := t_defect_report."DEFER_NOTES";
t_defect."MEL" := t_defect_report."MEL" ;
t_defect."RESOLUTION_CATEGORY" := t_defect_report."RESOLUTION_CATEGORY" ;
t_defect."RESOLVED_BY" := t_defect_report."RESOLVED_BY" ;
t_defect."RESOLVED_DATE" := t_defect_report."RESOLVED_DATE" ;
t_defect."RESOLUTION_DESCRIPTION" := t_defect_report."RESOLUTION_DESCRIPTION" ;
t_defect."DISPATCHER_NOTIFIED_RESOLUTION" := t_defect_report."DISPATCHER_NOTIFIED_RESOLUTION" ;
t_defect."RESOLVED_LOCATION" := t_defect_report."RESOLVED_LOCATION" ;
t_defect."FAULT_CONFIRM" := t_defect_report."FAULT_CONFIRM" ;
t_defect."REPORTED_BY" := t_defect_report."REPORTED_BY" ;
t_defect."MODIFIED_BY" := t_defect_report."MODIFIED_BY" ;
t_defect."MODIFIED_DATE" := t_defect_report."MODIFIED_DATE";
t_defect."SDR" := t_defect_report."SDR";
t_defect."INTERFACE_EXTERNAL_REFERENCE" := t_defect_report."INTERFACE_EXTERNAL_REFERENCE";
t_defect."DEFECT_GATE" := t_defect_report."DEFECT_GATE";


INSERT  INTO "INTERFACE_DEFECT_REPORT"
VALUES t_defect;

COMMIT;

end loop;

OPEN p_INTERFACE_DEFECT_CUR for
   SELECT *
   FROM "INTERFACE_DEFECT_REPORT" IDR
   WHERE IDR."TRANSACTION" = t_defect."TRANSACTION"
   ;

end getDefectReport
;



FUNCTION get_Defect_DEFER_DUE_DATE( t_DR IN OUT DEFECT_REPORT%ROWTYPE ) RETURN DATE IS
	PRAGMA AUTONOMOUS_TRANSACTION;
	--obj_param OBJ_PLANNING_PARAM;
	t_stc SYSTEM_TRAN_CONFIG%ROWTYPE;
	dt_return_value DATE;
	t_ia interface_Audit%rowtype;
BEGIN
        /*
	raise_application_error(-2100, 'Get defer due date not functional.');

	pkg_interface_audit.setAudit(t_ia,'OUT','ADD','PLANNING');

	obj_param := OBJ_PLANNING_PARAM(t_ia."TRANSACTION");
	obj_param."TRANSACTION_ITEM" := 1;
	obj_param."DT_PLANNING_DATE" := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
	obj_param."L_PLANNING_HOUR" := TO_NUMBER(TO_CHAR(obj_param."DT_PLANNING_DATE", 'HH24'));
	obj_param."L_CURRENT_MINUTE" := TO_NUMBER(TO_CHAR(obj_param."DT_PLANNING_DATE", 'MI'));
	obj_param."V_SCHEDULE" := 'EARLIEST';
	obj_param."V_AC" := t_DR."AC";
	obj_param."FLIGHT_STATUS" := 'CLOSED';

	--The Following switch is not used yet
	t_stc := PKG_SYSTEM_ADMIN.GET_SYSTEM_TRAN_CONFIG_RECORD('AC/SCHED');
	obj_param.s_ac_schedule := t_stc."CONFIG_FLAG";
	obj_param.l_ac_schedule_years := t_stc."CONFIG_NUMBER";

	t_stc := PKG_SYSTEM_ADMIN.GET_SYSTEM_TRAN_CONFIG_RECORD('ACROLAVG');
	obj_param.s_roll_avg := t_stc."CONFIG_FLAG";
	obj_param.l_roll_days := t_stc."CONFIG_NUMBER";

	BEGIN
		SELECT	"AC_MASTER"."AC_FLIGHT_HOURS",
				"AC_MASTER"."AC_FLIGHT_MINUTES",
				"AC_MASTER"."AC_CYCLES",
				"AC_MASTER"."AC_BRAKE_CYCLES",
				"AC_MASTER"."LAST_DATE_FLIGHT_LOG_APPLIED"
		INTO	obj_param."L_AC_TOTAL_HOURS",
				obj_param."L_AC_TOTAL_MINUTES",
				obj_param."L_AC_TOTAL_CYCLES",
				obj_param."L_AC_TOTAL_BRAKE_CYCLES",
				obj_param."DT_LAST_DATE_FLIGHT_LOG"
		FROM	"AC_MASTER"
		WHERE	"AC_MASTER"."AC" = t_DR."AC";
	EXCEPTION
		when no_data_found then
			obj_param."L_AC_TOTAL_HOURS" := 0;
			obj_param."L_AC_TOTAL_MINUTES" := 0;
			obj_param."L_AC_TOTAL_CYCLES" := 0;
			obj_param."L_AC_TOTAL_BRAKE_CYCLES" := 0;
	END;


	BEGIN
		SELECT	"AC_SCHEDULE_FLIGHT"."HOURS",
				"AC_SCHEDULE_FLIGHT"."CYCLES",
				nvl("AC_SCHEDULE_FLIGHT"."OVERRIDE",'N')
		INTO    obj_param."L_MEAN_HOURS",
				obj_param."L_MEAN_CYCLES",
				obj_param."S_ROLL_OVERRIDE"
		FROM	"AC_SCHEDULE_FLIGHT"
		WHERE	"AC_SCHEDULE_FLIGHT"."AC" = t_DR."AC"     AND
				"AC_SCHEDULE_FLIGHT"."AC_SCHEDULE_CATEGORY" = 'AC' AND
				"AC_SCHEDULE_FLIGHT"."FLIGHT_DATE" = (
						SELECT 	MAX("FLIGHT_DATE")
						FROM   	"AC_SCHEDULE_FLIGHT"
						WHERE	"AC_SCHEDULE_FLIGHT"."AC" = t_DR."AC" AND
								"AC_SCHEDULE_FLIGHT"."AC_SCHEDULE_CATEGORY" = 'AC' );
	EXCEPTION
		WHEN no_data_found then
			obj_param."L_MEAN_HOURS" := 0;
			obj_param."L_MEAN_CYCLES" := 0;
			obj_param."S_ROLL_OVERRIDE" := 'N';
	END;

	if obj_param."S_ROLL_AVG" = 'Y'
	and obj_param."S_ROLL_OVERRIDE" <> 'Y' then
		null;
		--PKG_PLANNING.LOAD_AC_MEAN_AVERAGE(obj_param);
	end if;

	obj_param.l_ac_flight_hours := obj_param."L_AC_TOTAL_HOURS";
	obj_param.l_ac_flight_minute := obj_param."L_AC_TOTAL_MINUTES";
	obj_param.l_ac_cycles := obj_param."L_AC_TOTAL_CYCLES";
	obj_param.l_ac_brake_cycles := obj_param."L_AC_TOTAL_BRAKE_CYCLES";

	if obj_param."L_MEAN_CYCLES" is null or obj_param."L_MEAN_CYCLES" = 0 or
	obj_param."L_MEAN_HOURS" = 0 or obj_param."L_MEAN_HOURS" is null then
		return null;
	end if;

	--PKG_PLANNING.LOAD_ONE_DEFECT_INTO_PLANNING(obj_param, t_DR);

	-- get info
	SELECT 	"DUE_DATE"
	INTO	dt_return_value
	FROM	INTERFACE_PLANNING
	WHERE 	"TRANSACTION" = t_ia."TRANSACTION";

	-- Don't need the records anymore
	DELETE FROM INTERFACE_PLANNING
	WHERE 	"TRANSACTION" = t_ia."TRANSACTION";

	COMMIT;
	return dt_return_value;
--EXCEPTION
--	WHEN OTHERS THEN
--		return null;
*/
return null;
END;


--*******************************************
-- Log 111926 - Jing Huang 2010-09-10
-- Merge and update methods from pkg_iface_defect_reports_test
-- and Defect_Report_Service.java
--*******************************************
	Function queryRecords (
	  p_status varchar2,
	  p_ac varchar2,
	  p_only_Unsent_Mel_Items varchar2,
	  p_only_Mel_Items varchar2,
	  p_sabre_Allow_Mel varchar2,
	  p_sabre_Allow_Cdl varchar2,
	  p_sabre_Allow_Gmm varchar2,
	  p_get_only_unsent_records varchar2,
	  p_defect varchar2,
	  p_only_non_mel_items varchar2,
	  p_defer_category varchar2,
    p_only_mddr_items varchar2 default 'N', 
    p_max_records number default 0,
    p_linked_mddr varchar2 default 'N'
	) return refCursor 
  as
	  row_defect DEFECT_REPORT%ROWTYPE;
	  s_defect_query varchar2(2000);
	  l_message_id number(30);
	  l_cursor refCursor;
	  l_return_cursor refCursor;
	  t_interface_audit INTERFACE_AUDIT%ROWTYPE;
	  s_companyProfile PROFILE_MASTER."PROFILE"%TYPE;
	  dt_now DATE;
    d_due_at_ac_hours number;
    d_due_at_ac_cycles number;
    dt_defer_to_date date;
    d_schedule_days number;
    v_due_control "PLANNING"."DUE_CONTROL"%TYPE;
    dt_forcasted_due_date date;
    b_exportDefectXML boolean;
    n_sqlcode NUMBER := 0;
    xml_previous xmltype;
    l_process_times number;
	BEGIN

	  s_companyProfile := PKG_APPLICATION_FUNCTION.GETCOMPANYPROFILE();
	  dt_now := PKG_APPLICATION_FUNCTION.CURRENTDATETIME();

	  s_defect_query := buildDefectQuery(
	    p_status,
	    p_ac,
      p_only_Unsent_Mel_Items ,
	    p_only_Mel_Items,
	    p_sabre_Allow_Mel,
	    p_sabre_Allow_Cdl,
	    p_sabre_Allow_Gmm,
	    p_get_only_unsent_records,
	    p_defect,
	    p_only_non_mel_items,
	    p_defer_category,
      p_only_mddr_items,
      p_max_records);


	  If (p_get_only_unsent_records = 'Y' or p_only_unsent_mel_items = 'Y') Then
	    unmarkDefectFromConcession;
      unmarkByDefectTroubleShooting;
	    l_message_id := 0;
	  Else
	    l_message_id := PKG_INTERFACE_AUDIT.GETINTERFACEAUDITSEQ();
	  End If;

	  -- Begin looping through defect report records
	  OPEN l_cursor FOR s_defect_query;
	  LOOP
	    FETCH l_cursor INTO row_defect;
	    EXIT WHEN l_cursor%NOTFOUND;

      n_sqlcode := SQLCODE;  --log148105    
      --If the resource is avaialbe (not -54) then go ahead as normal.  
      --Else skip altogether and we'll try again on the next call.
      IF n_sqlcode <> -54 THEN  --log148105  
        -- create an interface audit record for the defect
        t_interface_audit."MESSAGE_ID" := l_message_id;
        b_exportDefectXML := true;
        xml_previous := getXML(row_defect."PREVIOUS_INTERFACE_TRANSACTION", 1);

        IF P_GET_ONLY_UNSENT_RECORDS = 'Y' OR P_ONLY_UNSENT_MEL_ITEMS = 'Y' THEN
          If (s_companyProfile IN ('HRZ','ASK','VRD')) Then
            t_interface_audit."TRANSACTION_METHOD" :=
              getTransactionMethodHRZ(row_defect, xml_previous);
            if t_interface_audit."TRANSACTION_METHOD" is null then
              b_exportDefectXML := false;
            end if;
          Else
            If row_defect."INTERFACE_CREATED_DATE" is null Then
              t_interface_audit."TRANSACTION_METHOD" := 'ADD';
            Else
              t_interface_audit."TRANSACTION_METHOD" := 'UPDATE';
            End If;
          End If;
        end if;

        If b_exportDefectXML Then
           -- get due at times
          d_due_at_ac_hours := null;
          d_due_at_ac_cycles := null;
          dt_defer_to_date := null;
          dt_forcasted_due_date := null;
          d_schedule_days := null;

          getDefectDueAt(
            row_defect.defect_type,
            row_defect.defect,
            row_defect.defect_item,
            dt_forcasted_due_date,
            d_due_at_ac_hours,
            d_due_at_ac_cycles,
            dt_defer_to_date,
            d_schedule_days,
            v_due_control);

          -- process times
          if (xml_previous is not null) then
            SELECT  to_number(nvl(extractValue(xml_previous, '/*/process_Times'), '1')) + 1
              INTO l_process_times
              FROM DUAL;
          else
            -- initial process times
            l_process_times := 1;
          end if;

          ExportDefectXML(t_interface_audit,
            row_defect,
            l_process_times,
            dt_forcasted_due_date,
            d_due_at_ac_hours,
            d_due_at_ac_cycles,
            dt_defer_to_date,
            d_schedule_days,
            v_due_control, 
            p_linked_mddr);
        End If;

        if p_get_only_unsent_records = 'Y' or p_only_unsent_mel_items = 'Y' then
          UPDATE DEFECT_REPORT
          SET INTERFACE_CREATED_DATE = NVL(INTERFACE_CREATED_DATE, dt_now),
              INTERFACE_MODIFIED_DATE = dt_now,
              PREVIOUS_INTERFACE_TRANSACTION = t_interface_audit."TRANSACTION"
          WHERE 1 = 1
            AND DEFECT_TYPE = row_defect.defect_type
            AND DEFECT = row_defect.defect
            AND DEFECT_ITEM = row_defect.defect_item;

          -- clear trouble shooting
          UPDATE DEFECT_REPORT_TROUBLE_SHOOTING DRTT
               SET INTERFACE_MODIFIED_DATE = dt_now
             WHERE 1 = 1
             AND DEFECT_TYPE = row_defect.defect_type
               AND DEFECT = row_defect.defect
               AND DEFECT_ITEM = row_defect.defect_item;

          -- only keep current xml and previous xml data
          -- deletePreviousTransaction(row_defect.defect_type, row_defect.defect, row_defect.defect_item, 2, t_interface_audit."TRANSACTION");
        end if;
      END IF; --log148105 
	  END LOOP;
	  CLOSE l_cursor;

	  COMMIT;

	  -- return a reference cursor of the resultset
	  l_return_cursor := getQueryRecords(l_message_id, p_get_only_unsent_records, p_max_records);
	  return l_return_cursor;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      if l_cursor%isopen then
				close l_cursor;
			end if;
      RAISE_APPLICATION_ERROR(-20111, sqlerrm || Chr(10) || 'Backtrace...' || Chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(), TRUE);
	END queryRecords;

	Function getQueryRecords(
	  l_message_id number,
	  p_get_only_unsent_records varchar2,
    p_max_records number default 0
	) Return refCursor AS
	  l_return_cursor refCursor;
	  s_ia_query VARCHAR2(2000);
	Begin
	  s_ia_Query :=
	        'SELECT /*+ INDEX(ia I_IFACE_AUDIT_UNSENT_WMSGID) */
                  ia."TRANSACTION",
	                ia."TRANSACTION_METHOD",
	                oid."XML_DOCUMENT", ' ||
                  l_message_id || ',' ||
          '       decode(ia."TRANSACTION_METHOD", ''DELETE'', 1, 0) SORTORDER
	           FROM "INTERFACE_AUDIT" ia, "INTERFACE_DATA" oid
			  WHERE 1 = 1
	            AND ia."TRANSACTION_OBJECT" = ''TRAX_DEFECT_XML''
	            AND ia."EXCEPTION_ID" IS NULL
	            AND ia."MESSAGE_NEEDS_TO_BE_SENT" = ''Y''
	            AND (ia."MESSAGE_WAS_SENT" = ''N'' OR ia."MESSAGE_WAS_SENT" IS NULL)
	            AND (   ((   ia."TRANSACTION_METHOD" IS NULL
	                      OR ia."TRANSACTION_METHOD" <> ''DELETE'')
	                      AND ia."MESSAGE_ID" = ' || l_message_id || ' )';

	  If (p_get_only_unsent_records = 'Y') Then
	    s_ia_Query := s_ia_Query
	    ||  '        OR (ia."TRANSACTION_METHOD" = ''DELETE'' ) )';
	  Else
	    s_ia_Query := s_ia_Query ||  ') ';
	  End If;

    If nvl(p_max_records, 0) <> 0 Then
	    s_ia_Query := s_ia_Query || ' AND ROWNUM <=  ' || p_max_records;
	  End If;
 --Added by log 171501 DavidS  
	  s_ia_Query := s_ia_Query ||
	        '  AND ia."TRANSACTION" = oid."TRANSACTION"
	           AND oid."TRANSACTION_ITEM" = 1 '
 --Added by log 171501 DavidS            
            || ' AND oid."XML_DOCUMENT" is not null '
 --log 171501
	         || ' ORDER BY "SORTORDER" ASC, ia."TRANSACTION" ASC ';
 --end  
	  --DBMS_OUTPUT.PUT_LINE('s_Return = ' || s_ia_Query);
	  OPEN l_return_cursor FOR s_ia_Query;
	  return l_return_cursor;
	Exception
	  WHEN NO_DATA_FOUND THEN
	    return null;
	  WHEN OTHERS THEN
	    IF (l_return_cursor%isOpen) THEN
	      CLOSE l_return_cursor;
	    END IF;
	    RAISE;
	End;

 -- --------------------------------
	-- get xml message via transaction number
	Function getXML(l_transaction number, l_transaction_item number)
	return XMLType AS
	  return_value INTERFACE_DATA.XML_DOCUMENT%TYPE;
	BEGIN
		if nvl(l_transaction, 0) = 0 or nvl(l_transaction_item, 0) = 0 then
			return_value := null;
		else
			SELECT XML_DOCUMENT
        into return_value
			  FROM INTERFACE_DATA
			 WHERE TRANSACTION = l_transaction
			   AND TRANSACTION_ITEM = l_transaction_item;
		end if;
		return return_value;
	exception
		when no_data_found then
			return null;
	END getXML;

  -- --------------------------------
	-- get defect xml message via defect and the position in descending sequence, starting from current transaction
  Function getDefectXML(
    v_defect_type DEFECT_REPORT.DEFECT_TYPE%TYPE,
    v_defect DEFECT_REPORT.DEFECT%TYPE,
    l_defect_item DEFECT_REPORT.DEFECT_ITEM%TYPE,
    l_position number,
    l_current_transaction number)
	return XMLType AS
	BEGIN
		if nvl(v_defect_type, ' ') = ' ' or nvl(v_defect, ' ') = ' ' or nvl(l_defect_item, 0) = 0 or nvl(l_position, 0) <= 0 then
			return null;
		else

      return getXML(getInterfaceTransaction(v_defect_type, v_defect, l_defect_item, l_position, l_current_transaction), 1);
		end if;
	END getDefectXML;

  -- --------------------------------
	-- get transaction method for ASK, VRD and HRZ
	function getTransactionMethodHRZ(p_defect_report in DEFECT_REPORT%ROWTYPE, p_defect_report_prev in
	XMLType)
	RETURN varchar2 as
	  s_old_MEL_Number varchar2(20);
	  s_new_MEL_Number varchar2(20);
	  s_old_resolved_by varchar2(10);
	  s_new_resolved_by varchar2(10);
	BEGIN
	  s_new_MEL_Number := p_defect_report."MEL_NUMBER";
	  s_new_resolved_by := p_defect_report."RESOLVED_BY";

	  If (p_defect_report_prev is null and s_new_MEL_Number is not null) Then
	    return 'ADD';
	  End If;

	  If (p_defect_report_prev is null) Then
	    return null;
	  End If;

	  SELECT  extractValue(p_defect_report_prev, '/*/MEL_Number'),
	          extractValue(p_defect_report_prev, '/*/resolved_By')
	  INTO    s_old_MEL_Number,
	          s_old_resolved_by
	  FROM DUAL;

	  If (s_old_MEL_Number is null AND s_new_MEL_Number is not null) Then
	    return 'ADD';
	  End If;
	  If (s_old_MEL_Number is not null AND s_new_MEL_Number is null) Then
	    return 'UPDATE';
	  End If;
	  If ( (s_old_MEL_Number is not null OR s_new_MEL_Number is not null) AND
	        (s_old_resolved_by is null AND s_new_resolved_by is not null) ) Then
	    return 'UPDATE';
	  End If;
	  return null;
	END;

	------------------------------------------------------------------------------
	----- Procedure to export a Defect to XML
	PROCEDURE ExportDefectXML(
	  t_interface_audit in out nocopy INTERFACE_AUDIT%ROWTYPE,
	  v_DefectReport   in DEFECT_REPORT%ROWTYPE,
    l_process_times in number,
    dt_forcasting_due_date in date,
    d_due_at_ac_hours in number,
    d_due_at_ac_cycles in number,
    dt_defer_to_date in date,
    d_schedule_days in number,
    v_due_control in "PLANNING"."DUE_CONTROL"%TYPE, 
    p_linked_mddr varchar2 default 'N')
	is
	  t_interface_data INTERFACE_DATA%ROWTYPE;
	  v_transaction "PLANNING"."TRANSACTION"%TYPE;
	BEGIN
	  t_interface_audit."DEFECT_TYPE" := v_DefectReport."DEFECT_TYPE";
    t_interface_audit."DEFECT" := v_DefectReport."DEFECT";
    t_interface_audit."DEFECT_ITEM" := v_DefectReport."DEFECT_ITEM";

    PKG_INTERFACE_AUDIT.setAudit(t_interface_audit, 'OUT', t_interface_audit."TRANSACTION_METHOD", 'TRAX_DEFECT_XML');
    t_interface_data."TRANSACTION" := t_interface_audit."TRANSACTION";
    t_interface_data.TRANSACTION_ITEM := 1;

		t_interface_data."XML_DOCUMENT" := createDefectXML(
			v_DefectReport."DEFECT_TYPE",
			v_DefectReport."DEFECT",
			v_DefectReport."DEFECT_ITEM",
			t_interface_audit."TRANSACTION",
			t_interface_audit."TRANSACTION_METHOD",
      l_process_times,
			dt_forcasting_due_date,
			d_due_at_ac_hours,
			d_due_at_ac_cycles,
			dt_defer_to_date,
      d_schedule_days,
      v_due_control,
      p_linked_mddr);

		pkg_interface.insertIntoInterfaceData( t_interface_data );
		pkg_interface.transactionNeedsToBeSent(t_interface_audit."TRANSACTION");

	END ExportDefectXML;

	-- ------------------------------------
	Function createDefectXML(
	  p_defect_type VARCHAR2,
	  p_defect VARCHAR2,
	  p_defect_item NUMBER,
	  p_interface_transaction IN NUMBER default null,
	  p_transactionMethod IN VARCHAR2 default null,
    l_process_times in number default 0,
	  dt_forecasted_due_date in DATE default null,
	  d_due_at_ac_hours in number default null,
	  d_due_at_ac_cycles in number default null,
	  dt_defer_to_date in date default null,
    d_schedule_days in number default null,
    v_due_control in "PLANNING"."DUE_CONTROL"%TYPE default null,
    v_has_linked_mddr varchar2 default 'N')
	RETURN XMLType is
    xml_linked varchar2(32000);
	  return_value XMLType;
    s_mddr varchar2(16);
	begin

    begin
      select mddr
      into s_mddr
      from defect_report
      where defect = p_defect
      and defect_type = p_defect_type
      and defect_item = p_defect_item;
    exception
    when others then
      s_mddr := null;
    end;

    if v_has_linked_mddr = 'Y' then
      return_value := getLinkedMddrDefectsXml(p_defect_type, p_defect, p_defect_item, s_mddr, v_has_linked_mddr);
    end if;

	  SELECT
	    XMLElement( "Defect_Report_Outgoing_Element",
	      XMLForest(
          v_DefectReport."DEFECT_TYPE"                                                    as "defect_Type",
	        v_DefectReport."DEFECT"                                                         as "defect",
	        v_DefectReport."DEFECT_ITEM"                                                    as "defect_Item",
          v_DefectReport."DEFECT_CATEGORY"                                                as "defect_Category",
          pkg_interface.replaceNonPrintingCharacters(v_DefectReport."DEFECT_DESCRIPTION") as "defect_Description",
          --REGEXP_REPLACE(v_DefectReport."DEFECT_DESCRIPTION", '[^a-zA-Z0-9 ,.:;#@!$%&*|~]', null) as "defect_Description",
	        v_DefectReport."AC"                                                             as "AC",
	        v_DefectReport."CHAPTER"                                                        as "chapter",
	        v_DefectReport."SECTION"                                                        as "section",
	        v_DefectReport."FLIGHT"                                                         as "flight",
	        v_DefectReport."FLIGHT_PHASE"                                                   as "flight_Phase",
	        PKG_INTERFACE.GETXMLDATESTRING(v_DefectReport."DEFER_TO_DATE")                  as "defer_To_Date",
	        v_DefectReport."STATION"                                                        as "station",
          PKG_INTERFACE.GETXMLDATESTRING(
	          pkg_application_function.GETCOMBINEDDATE(v_DefectReport."DEFER_DATE",
            v_DefectReport."DEFER_HOUR",v_DefectReport."DEFER_MINUTE"))                   as "defer_Date",
	        v_DefectReport."MODIFIED_BY"                                                    as "modified_By",
	        v_DefectReport."MDDR"                                                           as "MDDR",
	        v_DefectReport."DEFER"                                                          as "defer",
	        v_DefectReport."DEFER_BY"                                                       as "defer_By",
	        v_DefectReport."MEL_NUMBER"                                                     as "MEL_Number",
          v_DefectReport."MEL_ALERT"                                                      as "MEL_Alert",
          v_DefectReport."STATUS"                                                         as "status",
	        v_DefectReport."DEFER_CATEGORY"                                                 as "defer_Category",
	        v_DefectReport."SCHEDULE_HOURS"                                                 as "schedule_Hours",
	        v_DefectReport."SCHEDULE_CYCLES"                                                as "schedule_Cycles",
	        v_DefectReport."SCHEDULE_DAYS"                                                  as "schedule_Days",
	        v_DefectReport."DEFER_TO_NEXT_EC"                                               as "defer_To_Next_EC",
	        v_DefectReport."SKILL"                                                          as "skill",
	        v_DefectReport."MAN_HOURS"                                                      as "man_Hours",
	        v_DefectReport."MAN_REQUIRED"                                                   as "man_Required",
	        v_DefectReport."CAPABILITY_AREA"                                                as "capability_Area",
	        v_DefectReport."REPEAT_NUMBER"                                                  as "repeat_Number",
	        v_DefectReport."COMPLETED_NUMBER"                                               as "completed_Number",
	        v_DefectReport."DISPATCHER_NOTIFIED"                                            as "dispatcher_Notified",
	        v_DefectReport."NOT_DO_ALLOW_CONCESSION"                                        as "do_Not_Allow_Concession",
	        v_DefectReport."MEL_CALENDAR_DAYS_FLAG"                                         as "mel_Calendar_Days_Flag",
          v_DefectReport."MODIFIED_DATE"                                                  as "modified_Date",
          pkg_interface.replaceNonPrintingCharacters(v_DefectReport."DEFER_NOTES")        as "defer_Notes",
	        --REGEXP_REPLACE(v_DefectReport."DEFER_NOTES", '[^a-zA-Z0-9 ,.:;#@!$%&*|~]', null) as "defer_Notes",
	        nvl(v_DefectReport."MEL",
            (SELECT DMA."MEL"
              FROM DEFECT_MEL_MASTER DMA, AC_MASTER AM
             WHERE DMA.AC_TYPE = AM.AC_TYPE
               AND DMA.AC_SERIES = AM.AC_SERIES
               AND DMA.MEL_NUMBER = v_DefectReport.MEL_NUMBER
               AND DMA.MEL_SUB = v_DefectReport.MEL_SUB
               AND AM.AC = v_DefectReport.AC)
          )                                                                                   as "MEL",
          v_DefectReport."RESOLUTION_CATEGORY"                                                as "resolution_Category",
	        v_DefectReport."RESOLVED_BY"                                                        as "resolved_By",
	        PKG_INTERFACE.GETXMLDATESTRING(PKG_APPLICATION_FUNCTION.getCombinedDate(
              v_DefectReport."RESOLVED_DATE", NVL(v_DefectReport."RESOLVED_HOUR", 0),
              NVL(v_DefectReport."RESOLVED_MINUTE", 0)))                                      as "resolved_Date",
          pkg_interface.replaceNonPrintingCharacters(v_DefectReport."RESOLUTION_DESCRIPTION") as "resolution_Description",
	        --REGEXP_REPLACE(v_DefectReport."RESOLUTION_DESCRIPTION", '[^a-zA-Z0-9 ,.:;#@!$%&*|~]', null) as "resolution_Description",
	       	v_DefectReport."DISPATCHER_NOTIFIED_RESOLUTION"                                     as "dispatcher_Notified_Resolution",
	        v_DefectReport."RESOLVED_LOCATION"                                                  as "resolved_Location",
	        v_DefectReport."FAULT_CONFIRM"                                                      as "fault_Confirm",
	        v_DefectReport."REPORTED_BY"                                                        as "reported_By",
	        v_DefectReport."SDR"                                                                as "SDR",
	        v_DefectReport."DEFECT_GATE"                                                        as "defect_Gate",
	        SUBSTR(v_DefectReport."INTERNAL_CAPABILITY",1,1)                                    as "internal_Capability",--CHANGE YES => Y AND NO => N
	        PKG_INTERFACE.GETXMLDATESTRING(PKG_APPLICATION_FUNCTION.getCombinedDate(
            v_DefectReport."REPORTED_DATE", NVL(v_DefectReport."REPORTED_HOUR", 0),
            NVL(v_DefectReport."REPOTED_MINUTE", 0)))                                         as "reported_Date",
	        SUBSTR(v_DefectReport."CADOR_DAMAGE",1,1)                                           as "cador_Damage", --CHANGE YES => Y AND NO => N
	        getDefectMELXML(v_DefectReport."MEL_NUMBER", v_DefectReport."MEL_SUB",
            v_DefectReport."AC")                                                              as "Defect_Rep_Outgoing_MEL_Master",
	        PKG_IFACE_PRODUCTION_WO.Get_WO_Header_XML(v_DefectReport."WO")                      as "Work_Order_Outgoing_Element",
	        ( SELECT  "AC_TYPE"
	          FROM    "AC_MASTER"
	          WHERE   "AC" = v_DefectReport."AC"
	        ) as "ac_Type",
	        ( SELECT  "AC_SERIES"
	          FROM    "AC_MASTER"
	          WHERE   "AC" = v_DefectReport."AC"
	        )                                                                                   as "ac_Series",
          	(SELECT "STATION_CODE"
	          FROM    "LOCATION_MASTER"
	          WHERE   "LOCATION" = v_DefectReport."STATION"
	        )                                                                                   as "station_Code",
	        v_DefectReport."LINKING_SEQ"                                                        as "ref_Seq_Num",
          p_transactionMethod                                                                 as "transactionMethod",
	        PKG_INTERFACE.GETXMLDATESTRING(trunc(dt_forecasted_due_date))                       as "forecasted_due_date", --Log 168284 (trunc added)
	        -- Sabre,
	        p_interface_transaction                                                             as "interface_transaction",
	        nvl(v_DefectReport."SABRE_MESSAGE_NUMBER", '0')                                     as "sabre_Control_Number",
	        getTroubleShootings(
	          v_DefectReport."DEFECT_TYPE",
	          v_DefectReport."DEFECT",
	          v_DefectReport."DEFECT_ITEM")                                                     as "troubleshootings",
	        PKG_INTERFACE.GETXMLDATESTRING(v_DefectReport."MODIFIED_DATE")                      as "modified_Date",
	        PKG_INTERFACE.GETXMLDATESTRING(v_DefectReport."AUTHORIZATION_DATE")                 as "authorized_Date",
          v_DefectReport."MIS"                                                                as "mis",
	        v_DefectReport."I_F_S_D"                                                            as "ifsd",
          v_DefectReport."MEL_SUB"                                                            as "mel_Sub",
          getConcessions(
	          v_DefectReport."DEFECT_TYPE",
	          v_DefectReport."DEFECT",
	          v_DefectReport."DEFECT_ITEM")                                                     as "concessions",
          d_due_at_ac_hours                                                                   as "due_At_AC_Hours",
          d_due_at_ac_cycles                                                                  as "due_At_AC_Cycles",
          PKG_INTERFACE.GETXMLDATESTRING(dt_defer_to_date)                                    as "due_Date",
          l_process_times                                                                     as "process_Times",
          v_DefectReport."MOC_ITEM_DESCRIPTION"                                               as "MOC_Item_Description",
          d_schedule_days                                                                     as "planning_Schedule_Days",
          v_due_control                                                                       as "planning_Due_Control",
          pkg_iface_ac_in_out_service.get_ac_master_xml(v_DefectReport.AC)                    as "AC_Master",
          v_DefectReport."REFERENCE"                                                          as "reference",
          return_value                                                                        as "Linked_MDDR_Defects"
	      )
	    )
	  INTO  return_value
	  FROM  DEFECT_REPORT v_DefectReport
	  WHERE 1 = 1
	    AND DEFECT_TYPE = p_defect_type
	    AND DEFECT      = p_defect
	    AND DEFECT_ITEM = p_defect_item;

	  return return_value;
	EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    return null;
    when others then
      raise_application_error(-20001, 'Failed while processing defect type: ' || p_defect_type || '; Defect: ' || p_defect || '; Defect_Item: ' || p_defect_item ||
                                    chr(10) ||
                                    'Error: ' || sqlerrm ||
                                    chr(10) ||
                                    'Backtrace: ' || 
                                    Chr(10) ||
                                    DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(), true);
	END createDefectXML;


	function getTroubleShootings(
	  p_defect_type in DEFECT_REPORT.DEFECT_TYPE%TYPE,
	  p_defect in DEFECT_REPORT.DEFECT%TYPE,
	  p_defect_item in DEFECT_REPORT.DEFECT_ITEM%TYPE
	) RETURN XMLType IS
	  return_value XMLType;
	BEGIN
	  SELECT
	    XMLAGG(
	      XMLElement( "troubleshooting",
	        XMLForest(
	          "TROUBLE_SHOOTING_ITEM" as "item",
	          "STATION" as "station",
	          "TROUBLE_SHOOTING_BY" as "troubleshooting_By",
	          PKG_INTERFACE.GETXMLDATESTRING(
	            PKG_APPLICATION_FUNCTION.getCombinedDate(
	              "TROUBLE_SHOOTING_ON",
	              "TROUBLE_SHOOTING_HOUR",
	              "TROUBLE_SHOOTING_MINUTE") ) as "troubleshooting_Date",
	          "STATUS" as "status",
	          "TROUBLE_SHOOTING_CODE" as "category",
	          "TROUBLE_SHOOTING_DEFECT" as "ac_Log",
	          "TROUBLE_SHOOTING_DEFECT_ITEM" as "ac_Log_Item",
	          pkg_interface.replaceNonPrintingCharacters("TROUBLE_SHOOTING_TEXT") as "description",
	          "CONTROL_CATEGORY" as "manual",
            "REFERENCE_CODE" as "reference",
	          DECODE(NVL("REQUIRED_INSPECTION_ITEM",'NO'), 'NO', 'false', 'true') as "rii",
	          "REQUIRED_INSPECTION_BY" as "rii_By"
	        )
	      )
	      ORDER BY "TROUBLE_SHOOTING_ITEM"
	    )
	  INTO    return_value
	  FROM    DEFECT_REPORT_TROUBLE_SHOOTING
	  WHERE   DEFECT_TYPE = p_defect_type AND
	          DEFECT = p_defect AND
	          DEFECT_ITEM = p_defect_item;

	  return return_value;
	EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    return null;
	END;

  function getConcessions(
	  p_defect_type in DEFECT_REPORT.DEFECT_TYPE%TYPE,
	  p_defect in DEFECT_REPORT.DEFECT%TYPE,
	  p_defect_item in DEFECT_REPORT.DEFECT_ITEM%TYPE
	) RETURN XMLType IS
	  return_value XMLType;
    v_config_flag SYSTEM_TRAN_CODE.CONFIG_FLAG%TYPE;
    v_sql varchar2(1000) := '
        SELECT
        XMLAGG(
          XMLElement( "concession_Item",
            XMLForest(
              "CONCESSION" as "concession",
              "CONCESSION_HOURS" as "concession_Hours",
              "CONCESSION_CYCLES" as "concession_Cycles",
              "CONCESSION_DAYS" as "concession_Days",
              pkg_interface.getxmldatestring("CONCESSION_DATE") as "concession_Date",
              pkg_interface.getxmldatestring("AUTHORIZATION_DATE") as "authorization_Date"
            )
          )
          ORDER BY "CONCESSION"
        )
        FROM CONCESSION_REGISTRY
       WHERE DEFECT_TYPE = :1
         AND DEFECT = :2
         AND DEFECT_ITEM = :3
    ';
	BEGIN
    v_config_flag := nvl(pkg_application_function.config_flag('REQCONAUTH'), 'N');
    if nvl(v_config_flag, 'N') = 'Y' then
      v_sql := v_sql || ' AND AUTHORIZATION = ''Y''';
    end if;

    execute immediate v_sql into return_value using p_defect_type, p_defect, p_defect_item;
    return return_value;
	EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    return null;
	END;


	FUNCTION getDefectMELXML(
	  p_defect_mel_number in DEFECT_REPORT.MEL_NUMBER%TYPE,
    p_defect_mel_sub in DEFECT_REPORT.MEL_SUB%TYPE,
	  p_ac in DEFECT_REPORT.AC%TYPE)
	RETURN XMLType IS
	  return_value XMLType;
	BEGIN
	  SELECT
	    XMLForest(
        A."AC_TYPE"                                      as "AC_Type",
	      A."AC_SERIES"                                    as "AC_Series",
	      A."MEL_NUMBER"                                   as "MEL_Number",
	      A."MEL_SUB"                                      as "MEL_Sub",
	      A."DESCRIPTION"                                  as "description",
	      A."MEL"                                          as "MEL",
	      A."RESTRICATION_OPERATION"                       as "restriction_Operation",
	      A."RESTRICATION_MAINTENANCE"                     as "restriction_Maintenance",
        A."RESTRICTION_AUTOLAND"                         as "restriction_Autoland",
        A."RESTRICTION_PAX_CONV"                         as "restriction_Pax_Conv",
        A."RESTRICATION_ETOPS"                           as "restriction_ETOPS",
	      A."MEL_HOURS"                                    as "MEL_Hours",
        A."SEND_ALERT"                                   as "send_Alert",
        A."WARNING_CREATE"                               as "warning_Create",
        A."WARNING_RESOLVE"                              as "warning_Resolve",
	      A."MEL_CYCLES"                                   as "MEL_Cycles",
	      A."MEL_DAYS"                                     as "MEL_Days",
	      A."MODIFIED_BY"                                  as "modified_By",
	      SUBSTR(A."MEL_CALENDAR_DAYS_FLAG",1,1)           as "MEL_Calendar_Days_Flag",
	      A."CREATED_BY"                                   as "created_By",
	      PKG_INTERFACE.GETXMLDATESTRING(A."CREATED_DATE") as "created_Date",
	      A."MEL"                                          as "cat",
	      A."CAT_RATING"                                   as "cat_rating",
	      DECODE(A."RVSM", 'Y', 'true', 'false')           as "rvsm"
--	      ( SELECT
--	          XMLAgg(
--	            XMLElement( "MEL_Master_Item",
--	              XMLForest(
--	                C."ITEM" as "mel_Master_Item_Number",
--	                C."REMARKS" as "remarks"
--	              )
--	            )
--	          ORDER BY C."ITEM")
--	        FROM DEFECT_MEL_MASTER_ITEMS C
--	        WHERE  A."AC_TYPE" = C.AC_TYPE
--	          AND A."AC_SERIES" = C."AC_SERIES"
--	          AND A."MEL_NUMBER" = C."MEL_NUMBER"
--	          AND A."MEL_SUB" = C."MEL_SUB"
--	      ) as "MEL_Master_Items",
	    )
	  INTO  return_value
	  FROM  DEFECT_MEL_MASTER A,
	        AC_MASTER B
	  WHERE	1 = 1
	        AND A.AC_TYPE     = B.AC_TYPE
	        AND A.AC_SERIES   = B.AC_SERIES
	        AND A.MEL_NUMBER  = p_defect_mel_number
          AND A.MEL_SUB     = p_defect_mel_sub
	        AND B.AC          = p_ac
	        AND ROWNUM        = 1;

	  return return_value;
	EXCEPTION
	  WHEN NO_DATA_FOUND THEN
	    return null;
	END getDefectMELXML;

	Function buildDefectQuery(
	  p_status varchar2,
	  p_ac varchar2,
	  p_only_Unsent_Mel_Items varchar2,
	  p_only_Mel_Items varchar2,
	  p_sabre_Allow_Mel varchar2,
	  p_sabre_Allow_Cdl varchar2,
	  p_sabre_Allow_Gmm varchar2,
	  p_get_only_unsent_records varchar2,
	  p_defect varchar2,
	  p_only_non_mel_items varchar2,
	  p_defer_category varchar2,
    p_only_mddr_items varchar2 default 'N', 
    p_max_records number default 0
	) return varchar2
	IS
	  s_defect_query VARCHAR2(2000);
	BEGIN
	    s_defect_query := 'SELECT A.* FROM "DEFECT_REPORT" A WHERE 1 = 1';

	  if nvl(p_get_only_unsent_records, 'N') = 'Y' then

	    s_defect_query := s_defect_query || ' AND A."INTERFACE_MODIFIED_DATE" IS NULL';

      if nvl(p_only_mddr_items, 'N') = 'Y' then
        s_defect_query := s_defect_query || ' AND A."MDDR" IS NOT NULL';
      end if;

	  Else --p_get_only_unsent_records <> 'Y'
	    If nvl(p_ac, ' ') <> ' ' Then
	      s_defect_query := s_defect_query || ' AND A."AC" = ''' || p_ac || '''';
	    end if;
      if nvl(p_only_unsent_mel_items, 'N') = 'Y' then
        s_defect_query := s_defect_query || ' AND A."INTERFACE_MODIFIED_DATE" IS NULL';
        s_defect_query := s_defect_query || ' AND A."MEL_NUMBER" IS NOT NULL';
      end if;
	    If nvl(p_status, ' ') <> ' ' Then
	      s_defect_query := s_defect_query || ' AND A."STATUS" = ''' || p_status || '''';
	    End If;
	    If nvl(p_only_MEL_Items, 'N') = 'Y' Then
	      s_defect_query := s_defect_query || ' AND A."MEL" IS NOT NULL';
	    End If;
      if nvl(p_only_mddr_items, 'N') = 'Y' then
        s_defect_query := s_defect_query || ' AND A."MDDR" IS NOT NULL';
      end if;
	    If nvl(p_sabre_Allow_Mel, 'N') = 'Y' OR
	       nvl(p_sabre_Allow_Cdl, 'N') = 'Y' OR
         nvl(p_sabre_Allow_Gmm, 'N') = 'Y' Then
	      s_defect_query := s_defect_query || ' AND EXISTS (
	          SELECT  1
	          FROM    DEFECT_MEL_MASTER DMM,
	                  AC_MASTER ACM
	          WHERE   DMM.AC_TYPE = ACM.AC_TYPE AND
	                  DMM.AC_SERIES = ACM.AC_SERIES AND
	                  ACM.AC = A.AC AND
	                  A.MEL_NUMBER = DMM.MEL_NUMBER AND
	                  DMM.MEL_SUB IN ( ''dummy'' ';
	      If nvl(p_sabre_Allow_Mel, 'N') = 'Y' Then
	        s_defect_query := s_defect_query || ' ,''MEL'' ';
	      End If;
	      If nvl(p_sabre_Allow_Cdl, 'N') = 'Y' Then
	        s_defect_query := s_defect_query || ' ,''CDL'' ';
	      End If;
	      If nvl(p_sabre_Allow_Gmm, 'N') = 'Y' Then
	        s_defect_query := s_defect_query || ' ,''GMM'' ';
	      End If;
	      s_defect_query := s_defect_query || ' ) ) ';
	    End If;

	    If nvl(p_only_non_mel_items, 'N') = 'Y' Then
	      s_defect_query := s_defect_query || ' AND A.MEL IS NULL';
	    End If;

	    If nvl(p_defer_category, ' ') <> ' ' Then
	      s_defect_query := s_defect_query || ' AND A.DEFER_CATEGORY = ''' || p_defer_category || '''';
	    End If;

	    If nvl(p_defect, ' ') <> ' ' Then
	      s_defect_query := s_defect_query || ' AND A.DEFECT = ''' || p_defect || '''';
	    End If;
	  end if;

    If nvl(p_max_records, 0) > 0 Then
	    s_defect_query := s_defect_query || ' AND ROWNUM <=  ' || p_max_records;
	  End If;

	  return s_defect_query;
	END buildDefectQuery;

	-- --------------------------------
	-- unmark defect report if there are unsent concessions
	procedure unmarkDefectFromConcession
	as
		Type t_concession_registry_cursor IS REF CURSOR;
    r_concession_registry t_concession_registry_cursor;
		t_concession_registry "CONCESSION_REGISTRY"%ROWTYPE;

    v_config_flag "SYSTEM_TRAN_CONFIG"."CONFIG_FLAG"%TYPE;
	  v_sql varchar2(1000);
		r_concession_cursor refCursor;
		v_defect_type "DEFECT_REPORT"."DEFECT_TYPE"%TYPE;
		v_defect "DEFECT_REPORT"."DEFECT"%TYPE;
		l_defect_item "DEFECT_REPORT"."DEFECT_ITEM"%TYPE;
    dt_today date;
	begin
    dt_today := pkg_application_function.currentDateTime;
    v_sql := '
      SELECT *
			  FROM "CONCESSION_REGISTRY"
			 WHERE "INTERFACE_MODIFIED_DATE" is null
			   AND "DEFECT_TYPE" is not null
			   AND "DEFECT" is not null
	    ';

	  v_config_flag := pkg_application_function.config_flag('REQCONAUTH');

		if nvl(v_config_flag, 'N') = 'Y' then
			v_sql := v_sql || '
			   AND "AUTHORIZATION" = ''Y''';
	    end if;

		open r_concession_registry for v_sql;
		loop
			fetch r_concession_registry into t_concession_registry;
			exit when r_concession_registry%notfound;

			UPDATE "DEFECT_REPORT"
			   SET "INTERFACE_MODIFIED_DATE" = null
			 WHERE "AC" = t_concession_registry."AC"
			   AND "DEFECT_TYPE" = t_concession_registry."DEFECT_TYPE"
		       AND "DEFECT" = t_concession_registry."DEFECT"
		       AND "DEFECT_ITEM" = t_concession_registry."DEFECT_ITEM";

			t_concession_registry."INTERFACE_CREATED_DATE" := nvl(t_concession_registry."INTERFACE_CREATED_DATE", dt_today);
			t_concession_registry."INTERFACE_MODIFIED_DATE" := dt_today;

			update "CONCESSION_REGISTRY"
			   set row = t_concession_registry
			 where "CONCESSION_REGISTRY"."CONCESSION" = t_concession_registry."CONCESSION";
		end loop;

		close r_concession_registry;
	exception
		when others then
			if (r_concession_registry%isOpen) then
				close r_concession_registry;
			end if;
      raise_application_error(-20111, sqlerrm || Chr(10) || 'Backtrace...' || Chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(), TRUE);
	end unmarkDefectFromConcession;

	-- --------------------------------
	-- unmark Defect Report if there are unsent trouble shooting items
	procedure unmarkByDefectTroubleShooting
	as
	begin
	    UPDATE "DEFECT_REPORT" DR
	       SET "INTERFACE_MODIFIED_DATE" = null
	     WHERE EXISTS(
	       SELECT 1
	         FROM "DEFECT_REPORT_TROUBLE_SHOOTING" DRTT
	        WHERE DRTT."DEFECT_TYPE" = DR."DEFECT_TYPE"
	          AND DRTT."DEFECT" = DR."DEFECT"
	          AND DRTT."DEFECT_ITEM" = DR."DEFECT_ITEM"
	          AND DRTT."INTERFACE_MODIFIED_DATE" is null);
	end unmarkByDefectTroubleShooting;

	-- --------------------------------
	-- get Defect Due At times
  procedure getDefectDueAt(
    v_defect_type in "PLANNING"."DEFECT_TYPE"%TYPE,
    v_defect in "PLANNING"."DEFECT"%TYPE,
    l_defect_item in "PLANNING"."DEFECT_ITEM"%TYPE,
    dt_forcasted_due_date out nocopy date,
    d_due_at_ac_hours out nocopy number,
    d_due_at_ac_cycles out nocopy number,
    dt_defer_to_date out nocopy date,
    d_schedule_days out nocopy number,
    v_due_control out nocopy "PLANNING"."DUE_CONTROL"%TYPE
    )
  AS
     v_transaction "PLANNING"."TRANSACTION"%TYPE;
     dt_today date;
     d_due_at_ac_minutes number;
     d_remain_days number;
     v_ac "AC_MASTER"."AC"%TYPE;
     s_LivePlan varchar2(10);
  BEGIN
    -- Jing Huang 219679
    s_LivePlan := pkg_application_function.config_flag('LivePlan');
    if nvl(s_LivePlan, ' ') = 'Y' then
      if trim(v_defect_type) is null or trim(v_defect) is null or l_defect_item = 0 then
        return;
      end if;

      begin
        SELECT P."DUE_AT_AC_HOURS", P."DUE_AT_AC_MINUTES", P."DUE_AC_CYCLES", P."SCHEDULE_DATE", P."DUE_DATE", P."SCHEDULE_DAYS", P."DUE_CONTROL"
          INTO d_due_at_ac_hours, d_due_at_ac_minutes, d_due_at_ac_cycles, dt_defer_to_date, dt_forcasted_due_date, d_schedule_days, v_due_control
          FROM "PLANNING" P
         WHERE P."TRANSACTION" = 'LivePlan'
           AND P."DEFECT_TYPE" = v_defect_type
           AND P."DEFECT" = v_defect
           AND P."DEFECT_ITEM" = l_defect_item
           AND P."RECORD_TYPE" = 'Defect'
           AND ROWNUM <= 1;

        if d_due_at_ac_minutes > 0 then
           d_due_at_ac_hours := floor(d_due_at_ac_hours + d_due_at_ac_minutes/60);
        end if;
        RETURN;
      exception
        when no_data_found then
          NULL;
      end;
    end if;
    -- 219679

    dt_today := "PKG_APPLICATION_FUNCTION"."CURRENTDATETIME";
    begin
      v_transaction := to_char(PKG_APPLICATION_FUNCTION.config_number('PLNTRNNO'));
    exception
    	when others then
      	  v_transaction := 'IF_DR_' || to_char(dt_today,'RRMMDDHH24MISSSSS');
    end;

    begin
    SELECT D."AC"
      INTO v_ac
      FROM DEFECT_REPORT D
      WHERE D.DEFECT_TYPE = v_defect_type
        AND D.DEFECT = v_defect
        AND D.DEFECT_ITEM = l_defect_item ;
    exception
      when no_data_found then
        v_ac := null;
    end;

    INSERT INTO "PLANNING_PARAMETER"
             ( "V_TRANSACTION",
               "DT_TODAY",
               "FROM_AC",
               "TO_AC",
               "DEFECT_SEL", "EC_SEL", "PN_EC_SEL", "PN_CONTROL_SEL", "SPARE_FORECAST",
               "DEFECT_TYPE",
               "DEFECT",
               "DEFECT_ITEM")
      VALUES ( v_transaction,
               dt_today,
              v_ac,
              v_ac,
               'Y','N','N','N','N',
              v_defect_type,
              v_defect,
              l_defect_item)  ;

    PKG_PLANNING_ASYNC.LOAD_PLANNING_without_Jobs(v_transaction);

    begin
      SELECT P."DUE_AT_AC_HOURS", P."DUE_AT_AC_MINUTES", P."DUE_AC_CYCLES", P."SCHEDULE_DATE", P."DUE_DATE", P."SCHEDULE_DAYS", P."DUE_CONTROL"
      INTO d_due_at_ac_hours, d_due_at_ac_minutes, d_due_at_ac_cycles, dt_defer_to_date, dt_forcasted_due_date, d_schedule_days, v_due_control
      FROM "PLANNING" P
      WHERE P."TRANSACTION" = v_transaction ;

      if d_due_at_ac_minutes > 0 then
         d_due_at_ac_hours := floor(d_due_at_ac_hours + d_due_at_ac_minutes/60);
      end if;
    exception
      when no_data_found then
        return;
    end;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR(-20111, 'Exception in getDefectDueAt for defect ' || v_defect_type || ' ' || v_defect || ' ' || to_char(l_defect_item) || sqlerrm || Chr(10) || 'Backtrace...' || Chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(), TRUE);
  END getDefectDueAt;

	-- --------------------------------
	-- get interface transaction ranked l_position in descending sequence
	FUNCTION getInterfaceTransaction(
		v_defect_type in "DEFECT_REPORT"."DEFECT_TYPE"%TYPE,
		v_defect in "DEFECT_REPORT"."DEFECT"%TYPE,
		l_defect_item in "DEFECT_REPORT"."DEFECT_ITEM"%TYPE,
    l_position in number,
    l_current_transaction in number) return "INTERFACE_AUDIT".TRANSACTION%TYPE
	AS
		l_transaction "INTERFACE_AUDIT"."TRANSACTION"%TYPE;
	BEGIN
    SELECT AA.TRANSACTION
      INTO l_transaction
      FROM ( SELECT IA.TRANSACTION, RANK() OVER (ORDER BY IA.TRANSACTION DESC) transaction_rank
               FROM INTERFACE_AUDIT IA
              WHERE IA.DEFECT_TYPE = v_defect_type
                AND IA.DEFECT = v_defect
                AND IA.DEFECT_ITEM = l_defect_item
                AND IA.TRANSACTION <= l_current_transaction
                 ) AA
     WHERE AA.transaction_rank = l_position;
		RETURN l_transaction;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN 0;
	END getInterfaceTransaction;

	-- --------------------------------
	-- delete defect report interface audit records - only keep the most l_recent records
	procedure deletePreviousTransaction(
    v_defect_type in "DEFECT_REPORT"."DEFECT_TYPE"%TYPE,
    v_defect in "DEFECT_REPORT"."DEFECT"%TYPE,
    v_defect_item in "DEFECT_REPORT"."DEFECT_ITEM"%TYPE,
    l_recent in number,
    l_current_transaction in number)
	as
		l_count number;
	begin
    DELETE FROM INTERFACE_AUDIT
      WHERE INTERFACE_AUDIT.TRANSACTION IN
          (SELECT AA.TRANSACTION
             FROM (SELECT IA.TRANSACTION, RANK() OVER (ORDER BY IA.TRANSACTION DESC) TRANSACTION_RANK
                     FROM INTERFACE_AUDIT IA
                     WHERE IA.DEFECT_TYPE = v_defect_type
                       AND IA.DEFECT = v_defect
                       AND IA.DEFECT_ITEM = v_defect_item
                       and nvl(ia.message_was_sent, 'N') = 'Y'
                       AND IA.TRANSACTION <= l_current_transaction) AA
            WHERE AA.TRANSACTION_RANK > l_recent);
	end deletePreviousTransaction;

  -- --------------------------------
	-- delete records for non unsent
	procedure deleteAuditNonUnsent(messageId number)
	as
	begin
		if messageId = 0 then
      return;
    end if;

    DELETE FROM INTERFACE_AUDIT
    WHERE MESSAGE_ID = messageId;
	end deleteAuditNonUnsent;
--*******************************************
-- Log 111926 - Jing Huang 2010-09-10
--*******************************************

--********* Log 152819 - Oscar 02/07/2013*********
  function getLinkedMddrDefectsXml( p_defect_type "DEFECT_REPORT"."DEFECT_TYPE"%TYPE, 
                                    p_defect "DEFECT_REPORT"."DEFECT"%TYPE,
                                    p_defect_item "DEFECT_REPORT"."DEFECT_ITEM"%TYPE,
                                    p_mddr "DEFECT_REPORT"."MDDR"%TYPE,
                                    b_has_linked_mddr varchar2 default 'N')return xmltype
  AS
    x_result xmltype;
--    s_result varchar2(32000);
    type rt_linked_mddr_defect is record(s_defect_type "DEFECT_REPORT"."DEFECT_TYPE"%TYPE, 
                                          s_defect "DEFECT_REPORT"."DEFECT"%TYPE,
                                          n_defect_item "DEFECT_REPORT"."DEFECT_ITEM"%TYPE);

    type tt_linked_mddr_defect is table of rt_linked_mddr_defect;
    t_linked_defect tt_linked_mddr_defect := tt_linked_mddr_defect();

    cursor c_linked_defect is (SELECT "DEFECT_REPORT"."DEFECT_TYPE",   
                               "DEFECT_REPORT"."DEFECT",   
                               "DEFECT_REPORT"."DEFECT_ITEM"  
                               FROM "DEFECT_REPORT"  
                               WHERE ( "DEFECT_REPORT"."MDDR" = p_mddr ) AND NOT
                                     ( ( "DEFECT_REPORT"."DEFECT_TYPE" = p_defect_type ) AND  
                                     ( "DEFECT_REPORT"."DEFECT" = p_defect ) AND  
                                     ( "DEFECT_REPORT"."DEFECT_ITEM" = p_defect_item ) ) );
  BEGIN
    if b_has_linked_mddr = 'Y' then
      open c_linked_defect;
      fetch c_linked_defect bulk collect into t_linked_defect;
      close c_linked_defect;

      if t_linked_defect.count > 0 then

        for i in t_linked_defect.first..t_linked_defect.last
        loop

          --s_result := s_result || createDefectXML(p_defect_type, p_defect, p_defect_item).getStringVal();

          insert into T_XML
          SELECT createDefectXML(t_linked_defect(i).s_defect_type, t_linked_defect(i).s_defect, t_linked_defect(i).n_defect_item)
          from dual;

        end loop; 
          select xmlagg(t_xml.xml)
          INTO x_result
          from t_xml;

         delete from t_xml;
      end if;
     end if; 
      return x_result;

  END getLinkedMddrDefectsXml;
 --********* End Log 152819**************************



 PROCEDURE setAuditDefectReport
(
  xmlDefect varchar2,
  transaction_type VARCHAR2 ,
  s_employeeId varchar2
)
IS
  b_continue boolean := true ;
  l_count number := 0;
  d_temp DATE ;
  s_deferredBy varchar2(20 char);
  s_closedBy varchar2(20 char);


  BEGIN
  d_temp := sysdate ;

  IF transaction_type = 'CLOSE-QT' THEN
    s_closedBy       := s_employeeId ;
  END IF ;
  IF transaction_type = 'DEFER-QT' THEN
    s_deferredBy       := s_employeeId ;
  END IF ;


  while b_continue  and  l_count <= 100
  loop
    BEGIN
         INSERT INTO DEFECT_REPORT_AUDIT
        (
            TRANSACTION_TYPE,
            DEFECT_TYPE,
            DEFECT,
            DEFECT_ITEM,
            created_by,
            MODIFIED_BY,
            AC,
            STATION,
            REQUIRED_INSPECTION_ITEM,
            REPORTED_BY,
            CHAPTER,
            FLIGHT,
            SECTION,
            SDR,
            ASR,
            CADOR_DAMAGE,
            AC_POSITION,
            SEAT_NUMBER,
            BUY_BACK_RII,
            DEFECT_DESCRIPTION,
            DEFER_BY,
            DEFER,
            DEFER_HOUR,
            DEFER_MINUTE,
            DEFER_CATEGORY,
            MDDR,
            DEFER_NOTES,
            REPEAT_NUMBER,
            COMPLETED_NUMBER,
            schedule_cycles,
            schedule_Hours,
            schedule_Days,
            seat_letter,
            seat_severity,
            status,
            inspected_by,
            required_inspection_by,
            fault_confirm,
            resolution_defect_type,
            resolution_defect,
            resolution_defect_item,
            resolution_category,
            resolution_description,
            resolved_hour,
            resolved_minute,
            resolved_by,
            resolved_location,
            inspector_man_hours,
            skill,
            defer_to_next_ec,
            defer_from_wo,
            defer_from_task_card,
            defer_from_tc_ac,
            defer_from_tc_pn,
            defer_from_tc_sn,
            interface_deferral_reference,
            defer_to_hour,
            defer_to_minute,
            mel_number,
            mel_sub,
            mel,
            man_hours,
            man_required,
            hour_calendar_control,
            mel_calendar_days_flag,
            schedule_hours_repeat,
            schedule_cycles_repeat,
            schedule_days_repeat,
            blob_no,
            planning_dept,
            planning_sub_dept,
            capability_area,
            i_f_s_d ,
            EMOBILITY_CLOSED_BY ,
            EMOBILITY_DEFERRED_BY ,
            MODIFIED_DATE,
            created_date,
            REPORTED_DATE,
            DEFER_DATE,
            resolved_date,
            defer_date_orig ,
            defer_to_date
        )
         select  transaction_type,defectType,defect,defectItem, createdBy,modifiedBy,ac,station,
		        requiredInspectionItem,reportedBy,chapter,flight,section,sdr,asr,cadorDamage,cabinPosition,seatNumber,hasBuyBackRII,defectDescription,
            deferBy,defer,deferHour,deferMinute,deferCategory,mddr,deferNotes,repeatNumber,completedNumber,scheduleCycles,scheduleHours,scheduleDays,seatLetter,seatSeverity,
            status,inspectedBy,requiredInspectionBy,faultConfirm,resolutionDefectType,resolutionDefect,resolutionDefectItem,resolutionCategory,
            resolutionDescription,resolvedHour,resolvedMinute,resolvedBy,resolvedLocation,inspectorManHours,skill,deferToNextEc,deferFromWo,deferFromTaskCard,deferFromTcAc,
            deferFromTcPn,deferFromTcSn,interfaceDeferralReference,deferToHour,deferToMinute,melNumber,melSub,mel,
            manHours,manRequired,hourCalendarControl,melCalendarDaysFlag,scheduleHoursRepeat,scheduleCyclesRepeat,scheduleDaysRepeat,blobNo,planningDept,planningSubDept,capabilityArea,iFSD,
            s_closedBy  ,s_deferredBy ,
       d_temp, --this is MODIFIED DATE
      TO_DATE(createdDate, 'YYYY-MM-DD"T"HH24:MI:SS"Z"') AS createdDate  ,
			TO_DATE(reportedDate, 'YYYY-MM-DD"T"HH24:MI:SS"Z"') as reportedDate ,
			TO_DATE(deferDate, 'YYYY-MM-DD"T"HH24:MI:SS"Z"')  as deferDate,
			TO_DATE(resolvedDate, 'YYYY-MM-DD"T"HH24:MI:SS"Z"') as resolvedDate,
			TO_DATE(deferDateOrig, 'YYYY-MM-DD"T"HH24:MI:SS"Z"') as deferDateOrig ,
			TO_DATE(deferToDate, 'YYYY-MM-DD"T"HH24:MI:SS"Z"') as deferToDate
      from   (select xmltype( xmlDefect) as xml_data  from dual) sd
      cross join xmltable('/defectReport'
              passing sd.xml_data
              columns  ac varchar2(10) path 'ac',
              defectType varchar2(8) path 'id/defectType',
              defect varchar2(12) path 'id/defect',
              defectItem NUMBER path 'id/defectItem',
              createdBy varchar2(10) path 'createdBy',
              createdDate varchar2(30) path 'createdDate',
              modifiedDate varchar2(30) path 'modifiedDate',
              modifiedBy varchar2(10) path 'modifiedBy',
              station varchar2(10) path 'station',
              requiredInspectionItem varchar2(10) path 'requiredInspectionItem',
              reportedBy varchar2(10) path 'reportedBy' ,
              reportedDate varchar2(30) path 'reportedDate',
              chapter number path 'chapter',
              flight varchar2(10) path 'flight',
              section number path 'section',
              sdr varchar2(8) path 'sdr',
              asr varchar2(10) path 'asr',
              cadorDamage varchar2(10) path 'cadorDamage',
              cabinPosition varchar2(20) path 'cabinPosition',
              seatNumber number path 'seatNumber',
              hasBuyBackRII varchar2(10) path 'hasBuyBackRII',
              defectDescription varchar2(4000) path 'defectDescription',
              deferDate varchar2(30) path 'deferDate',
              deferBy varchar2(10) path 'deferBy',
              defer varchar2(8) path 'defer',
              deferHour number path 'deferHour',
              deferMinute number path 'deferMinute',
              deferCategory varchar2(10) path 'deferCategory',
              mddr varchar2(16) path 'mddr',
              deferNotes varchar2(2000) path 'deferNotes',
              repeatNumber number path 'repeatNumber',
              completedNumber number path 'completedNumber',
              scheduleCycles number path 'scheduleCycles',
              scheduleHours number path 'scheduleHours',
              scheduleDays number path 'scheduleDays',
              seatLetter varchar2(10) path 'seatLetter',
              seatSeverity varchar2(10) path 'seatSeverity',
              status varchar2(10) path 'status',
              inspectedBy varchar2(10) path 'inspectedBy',
              requiredInspectionBy varchar2(10) path 'requiredInspectionBy',
              faultConfirm varchar2(12) path 'faultConfirm',
              resolutionDefectType varchar2(8) path 'resolutionDefectType',
              resolutionDefect varchar2(12) path 'resolutionDefect',
              resolutionDefectItem number path 'resolutionDefectItem',
              resolutionCategory varchar2(10) path 'resolutionCategory',
              resolutionDescription varchar2(4000) path 'resolutionDescription',
              resolvedHour number path 'resolvedHour',
              resolvedMinute number path 'resolvedMinute',
              resolvedDate varchar2(30) path 'resolvedDate',
              resolvedBy varchar2(10) path 'resolvedBy',
              resolvedLocation varchar2(10) path 'resolvedLocation',
              inspectorManHours number path 'inspectorManHours',
              skill varchar2(10) path 'skill',
              deferToNextEc varchar2(35) path 'deferToNextEc',
              deferFromWo number path 'deferFromWo',
              deferFromTaskCard varchar2(35) path 'deferFromTaskCard',
              deferFromTcAc varchar2(10) path 'deferFromTcAc',
              deferFromTcPn varchar2(35) path 'deferFromTcPn',
              deferFromTcSn varchar2(35) path 'deferFromTcSn',
              deferDateOrig varchar2(30) path 'deferDateOrig',
              interfaceDeferralReference varchar2(20) path 'interfaceDeferralReference',
              deferToHour number path 'deferToHour',
              deferToMinute number path 'deferToMinute',
              deferToDate varchar2(30) path 'deferToDate',
              melNumber varchar2(20) path 'melNumber',
              melSub varchar2(3) path 'melSub',
              mel varchar2(8) path 'mel',
              manHours number path 'manHours',
              manRequired number path 'manRequired',
              hourCalendarControl varchar2(10) path 'hourCalendarControl',
              melCalendarDaysFlag varchar2(10) path 'melCalendarDaysFlag',
              scheduleHoursRepeat number path 'scheduleHoursRepeat',
              scheduleCyclesRepeat number path 'scheduleCyclesRepeat',
              scheduleDaysRepeat number path 'scheduleDaysRepeat',
              blobNo number path 'blobNo',
              planningDept varchar2(10) path 'planningDept',
              planningSubDept varchar2(10) path 'planningSubDept',
              capabilityArea varchar2(10) path 'capabilityArea',
              iFSD varchar2(8) path 'iFSD'
         ) x;



       b_continue := false ;

      EXCEPTION  WHEN DUP_VAL_ON_INDEX  then

      l_count:= l_count +  1 ;
      SELECT d_temp + INTERVAL '1' SECOND
      into d_temp from dual ;
    END;
 end loop ;
 commit;
END setAuditDefectReport;




end PKG_IFACE_DEFECT_REPORTS;

/ 


  CREATE OR REPLACE PACKAGE "PKG_IFACE_DELAY" AS
/**
* Description: Create, update, delete, and query Delays against Defects/Flights
* @headcom
*/

  /** Add a delay to Trax
  *
  * @param P_ID The unique identifying key for this delay record.
  * @param P_AC The aircraft associated with this delay.
  *             Also the aircraft linking this delay to an actual flight.
  * @param P_DEFECT_TYPE The defect type value linking this delay to a defect report.
  * @param P_DEFECT The defect value linking this delay to a defect report.
  * @param P_DEFECT_ITEM The defect item linking this delay to a defect report.
  * @param P_FLIGHT_LOG The flight log linking this delay to an actual flight.
  * @param P_FLIGHT_LEG The flight leg linking this delay to an actual flight.
  * @param P_FLIGHT The flight number associated to the delay.
  * @param P_DELAY_TYPE Transaction code specifying the type of the delay.
  * @param P_DELAY_HOUR Number of hours of delay.
  * @param P_DELAY_MINUTE Number of minutes of delay.
  * @param P_CANCELLATION "Y" or "N" indicating a flight cancellation occurred.
  * @param P_CANCELLED_FLIGHT The cancelled flight number.
  * @param P_DELAY_CONTROL The delay control system transaction code.
  * @param P_CGI The CGI transaction code.
  * @param P_REI "Y", "N", or "D" indicating REI status.
  * @param P_CANX_FLAG "Y" or "N" indicating CANX status.
  * @param P_ICD The ICD value.
  * @param P_REPORTABLE_FLAG "Y" or "N" indicating whether the delay is reportable.
  * @param P_ADDITIONAL_INFO_FLAG "Y" or "N" indicating status of Additional Info checkbox.
  * @param P_SWAPPED_TO_AC The AC which the flight was swapped to due to the delay.
  * @param P_RECODE The recode system transaction code.
  * @param P_RECODE_REASON Description of the recode reason.
  * @param P_MODIFIED_BY The value for the user modifying the delay.
  * @param P_STATION Station at which the delay occurred.
  * @param P_DELAY_CODE The delay code (a system transaction code) for the delay.
  */
  PROCEDURE ADD_DELAY(
    P_ID IN OUT NUMBER,
    P_AC VARCHAR2,
    P_DEFECT_TYPE VARCHAR2,
    P_DEFECT VARCHAR2,
    P_DEFECT_ITEM NUMBER,
    P_FLIGHT_LOG VARCHAR2,
    P_FLIGHT_LEG NUMBER,
    P_FLIGHT VARCHAR2,
    P_DELAY_TYPE VARCHAR2,
    P_DELAY_HOUR NUMBER,
    P_DELAY_MINUTE NUMBER,
    P_CANCELLATION VARCHAR2,
    P_CANCELLED_FLIGHT VARCHAR2,
    P_DELAY_CONTROL VARCHAR2,
    P_CGI VARCHAR2,
    P_REI VARCHAR2,
    P_CANX_FLAG VARCHAR2,
    P_ICD VARCHAR2,
    P_REPORTABLE_FLAG VARCHAR2,
    P_ADDITIONAL_INFO_FLAG VARCHAR2,
    P_SWAPPED_TO_AC VARCHAR2,
    P_RECODE VARCHAR2,
    P_RECODE_REASON VARCHAR2,
    P_MODIFIED_BY VARCHAR2,
    P_STATION VARCHAR2 DEFAULT NULL,
    P_DELAY_REASON VARCHAR2 DEFAULT NULL,
    P_DELAY_CODE VARCHAR2 DEFAULT NULL,
    P_USER IN VARCHAR2 DEFAULT 'TRAX_IFACE'
  );

    /** Query for delays from Trax based upon criteria.
  *
  * @param P_RESULT Refcursor to return output result set.
  * @param P_ID The key identifier for the delay.
  * @param P_AC The aircraft of the delay.
  * @param P_DEFECT_TYPE The defect type value linking this delay to a defect report.
  * @param P_DEFECT The defect value linking this delay to a defect report.
  * @param P_DEFECT_ITEM The defect item linking this delay to a defect report.
  * @param P_FLIGHT_LOG The flight log linking this delay to an actual flight.
  * @param P_FLIGHT_LEG The flight leg linking this delay to an actual flight.
  * @param P_FLIGHT The flight number of the delay.
  * @param P_DELAY_TYPE Transaction code specifying the type of the delay.
  * @param P_FLIGHT_DATE The flight date of the linked actual flight record.
  * @param P_ORIGIN The origin of the linked actual flight record.
  * @param P_STATION Station at which the delay occurred.
  * @param P_DELAY_CODE The delay code (a system transaction code) for the delay.
  */
  PROCEDURE QUERY_DELAY(
    P_RESULT OUT SYS_REFCURSOR,
    P_ID DEFECT_REPORT_DELAY.ID%TYPE DEFAULT NULL,
    P_AC DEFECT_REPORT_DELAY.AC%TYPE DEFAULT NULL,
    P_DEFECT_TYPE DEFECT_REPORT_DELAY.DEFECT_TYPE%TYPE DEFAULT NULL,
    P_DEFECT DEFECT_REPORT_DELAY.DEFECT%TYPE DEFAULT NULL,
    P_DEFECT_ITEM DEFECT_REPORT_DELAY.DEFECT_ITEM%TYPE DEFAULT NULL,
    P_FLIGHT_LOG DEFECT_REPORT_DELAY.FLIGHT_LOG%TYPE DEFAULT NULL,
    P_FLIGHT_LEG DEFECT_REPORT_DELAY.FLIGHT_LEG%TYPE DEFAULT NULL,
    P_FLIGHT DEFECT_REPORT_DELAY.FLIGHT%TYPE DEFAULT NULL,
    P_DELAY_TYPE DEFECT_REPORT_DELAY.DELAY_TYPE%TYPE DEFAULT NULL,
    P_FLIGHT_DATE AC_ACTUAL_FLIGHTS.FLIGHT_DATE%TYPE DEFAULT NULL,
    P_ORIGIN AC_ACTUAL_FLIGHTS.ORIGIN%TYPE DEFAULT NULL,
    P_STATION DEFECT_REPORT_DELAY.STATION%TYPE DEFAULT NULL,
    P_DELAY_REASON DEFECT_REPORT_DELAY.DELAY_REASON%TYPE DEFAULT NULL,
    P_DELAY_CODE DEFECT_REPORT_DELAY.DELAY_CODE%TYPE DEFAULT NULL
  );

  /** Update a delay in Trax
  *
  * @param P_UPDATED_ROW_COUNT the number of rows updated by the procedure
  * @param P_ID The unique identifying key for this delay record.
  * @param P_AC The aircraft associated with this delay.
  *             Also the aircraft linking this delay to an actual flight.
  * @param P_DEFECT_TYPE The defect type value linking this delay to a defect report.
  * @param P_DEFECT The defect value linking this delay to a defect report.
  * @param P_DEFECT_ITEM The defect item linking this delay to a defect report.
  * @param P_FLIGHT_LOG The flight log linking this delay to an actual flight.
  * @param P_FLIGHT_LEG The flight leg linking this delay to an actual flight.
  * @param P_FLIGHT The flight number associated to the delay.
  * @param P_DELAY_TYPE Transaction code specifying the type of the delay.
  * @param P_DELAY_HOUR Number of hours of delay.
  * @param P_DELAY_MINUTE Number of minutes of delay.
  * @param P_CANCELLATION "Y" or "N" indicating a flight cancellation occurred.
  * @param P_CANCELLED_FLIGHT The cancelled flight number.
  * @param P_DELAY_CONTROL The delay control system transaction code.
  * @param P_CGI The CGI transaction code.
  * @param P_REI "Y", "N", or "D" indicating REI status.
  * @param P_CANX_FLAG "Y" or "N" indicating CANX status.
  * @param P_ICD The ICD value.
  * @param P_REPORTABLE_FLAG "Y" or "N" indicating whether the delay is reportable.
  * @param P_ADDITIONAL_INFO_FLAG "Y" or "N" indicating status of Additional Info checkbox.
  * @param P_SWAPPED_TO_AC The AC which the flight was swapped to due to the delay.
  * @param P_RECODE The recode system transaction code.
  * @param P_RECODE_REASON Description of the recode reason.
  * @param P_MODIFIED_BY The value for the user modifying the delay.
  * @param P_STATION Station at which the delay occurred.
  * @param P_DELAY_CODE The delay code (a system transaction code) for the delay.
  */
   PROCEDURE UPDATE_DELAY (
    P_UPDATED_ROW_COUNT OUT NUMBER,
    P_ID NUMBER,
    P_AC VARCHAR2,
    P_DEFECT_TYPE VARCHAR2,
    P_DEFECT VARCHAR2,
    P_DEFECT_ITEM NUMBER,
    P_FLIGHT_LOG VARCHAR2,
    P_FLIGHT_LEG NUMBER,
    P_FLIGHT VARCHAR2,
    P_DELAY_TYPE VARCHAR2,
    P_DELAY_HOUR NUMBER,
    P_DELAY_MINUTE NUMBER,
    P_CANCELLATION VARCHAR2,
    P_CANCELLED_FLIGHT VARCHAR2,
    P_DELAY_CONTROL VARCHAR2,
    P_CGI VARCHAR2,
    P_REI VARCHAR2,
    P_CANX_FLAG VARCHAR2,
    P_ICD VARCHAR2,
    P_REPORTABLE_FLAG VARCHAR2,
    P_ADDITIONAL_INFO_FLAG VARCHAR2,
    P_SWAPPED_TO_AC VARCHAR2,
    P_RECODE VARCHAR2,
    P_RECODE_REASON VARCHAR2,
    P_MODIFIED_BY VARCHAR2,
    P_STATION VARCHAR2 DEFAULT NULL,
    P_DELAY_REASON VARCHAR2 DEFAULT NULL,
    P_DELAY_CODE VARCHAR2 DEFAULT NULL
  ) ;

  /** Delete a delay from Trax
  *
  * @param P_DELETED_ROW_COUNT the number of rows deleted by the procedure (0 or 1)
  * @param P_ID The unique identifying key for the delay record to be deleted.
  */
  PROCEDURE DELETE_DELAY (
     P_DELETED_ROW_COUNT OUT NUMBER,
     P_ID DEFECT_REPORT_DELAY.ID%TYPE DEFAULT NULL
  )  ;

END PKG_IFACE_DELAY;


 / 
 
 CREATE OR REPLACE PACKAGE BODY "PKG_IFACE_DELAY" AS

  PROCEDURE ADD_DELAY(
    P_ID IN OUT NUMBER,
    P_AC VARCHAR2,
    P_DEFECT_TYPE VARCHAR2,
    P_DEFECT VARCHAR2,
    P_DEFECT_ITEM NUMBER,
    P_FLIGHT_LOG VARCHAR2,
    P_FLIGHT_LEG NUMBER,
    P_FLIGHT VARCHAR2,
    P_DELAY_TYPE VARCHAR2,
    P_DELAY_HOUR NUMBER,
    P_DELAY_MINUTE NUMBER,
    P_CANCELLATION VARCHAR2,
    P_CANCELLED_FLIGHT VARCHAR2,
    P_DELAY_CONTROL VARCHAR2,
    P_CGI VARCHAR2,
    P_REI VARCHAR2,
    P_CANX_FLAG VARCHAR2,
    P_ICD VARCHAR2,
    P_REPORTABLE_FLAG VARCHAR2,
    P_ADDITIONAL_INFO_FLAG VARCHAR2,
    P_SWAPPED_TO_AC VARCHAR2,
    P_RECODE VARCHAR2,
    P_RECODE_REASON VARCHAR2,
    P_MODIFIED_BY VARCHAR2,
    P_STATION IN VARCHAR2 DEFAULT NULL,
    P_DELAY_REASON IN VARCHAR2 DEFAULT NULL,
    P_DELAY_CODE IN VARCHAR2 DEFAULT NULL,
    P_USER IN VARCHAR2 DEFAULT 'TRAX_IFACE'
    
  ) IS
    n_ID_PRESENT NUMBER;
    n_ID NUMBER;
    v_COLUMN_LIST VARCHAR2(1000);
    v_VALUES_LIST VARCHAR2(1000);
    v_FULL_SQL VARCHAR2(2000);
    N_DELAY_ITEM NUMBER;
  BEGIN
    v_COLUMN_LIST := '"DEFECT_TYPE","DEFECT","DEFECT_ITEM","DELAY_ITEM",' ||
      '"DELAY_TYPE","DELAY_HOUR","DELAY_MINUTES","REPORTABLE","CREATED_BY",' ||
      '"CREATED_DATE","MODIFIED_BY","MODIFIED_DATE","FLIGHT","CGI","REI",' ||
      '"ICD","DELAY_CONTROL","CANX","ADDITIONAL_INFO","CANCELLATION","AC",' ||
      '"FLIGHT_LOG","FLIGHT_LEG","RECODE","RECODE_REASON","CANCELED_FLIGHT",' ||
      '"SWAPPED_TO_AC","STATION","DELAY_REASON","DELAY_CODE" , "DELAY_DATE"';

    v_VALUES_LIST := ':1, :2, :3, :4, :5, :6, :7, :8, :9, :10, :11, :12,' ||
      ' :13, :14, :15, :16, :17, :18, :19, :20, :21, :22, :23, :24, :25,' ||
      ' :26, :27, :28, :29, :30 , :31' ;

    --Determine if table is using new, synthetic key (ID)
    -- 165975 Updated to ALL_TAB_COLUMNS
    SELECT count(*)
    INTO n_ID_PRESENT
    FROM  ALL_TAB_COLUMNS
    WHERE TABLE_NAME = 'DEFECT_REPORT_DELAY'
    AND COLUMN_NAME = 'ID'
    AND OWNER = ( SELECT SCHEMA_OWNER FROM PROFILE_MASTER WHERE ROWNUM=1 );

    n_ID_PRESENT := 1 ;--added by NELSON ALL tables should have new unique ID now
    IF (n_ID_PRESENT > 0) THEN
      v_COLUMN_LIST := v_COLUMN_LIST || ', "ID"';
      IF (P_ID IS NULL OR P_ID = 0) THEN
        SELECT seq_interface_audit.NextVal
        INTO n_ID
        FROM DUAL;
      ELSE
        n_ID := P_ID;
      END IF;
      v_VALUES_LIST := v_VALUES_LIST || ', ' || to_char(n_ID);
    END IF;

    V_FULL_SQL := 'INSERT INTO DEFECT_REPORT_DELAY ( '
      || v_COLUMN_LIST || ' ) VALUES ( '
      || v_VALUES_LIST || ' ) ';

    SELECT nvl( MAX(DELAY_ITEM),0) + 1
    INTO   N_DELAY_ITEM
    FROM   DEFECT_REPORT_DELAY
    WHERE  DEFECT_TYPE = P_DEFECT_TYPE AND
           DEFECT = P_DEFECT AND
           DEFECT_ITEM = P_DEFECT_ITEM;

    EXECUTE IMMEDIATE V_FULL_SQL USING
      P_DEFECT_TYPE,
      P_DEFECT,
      P_DEFECT_ITEM,
      N_DELAY_ITEM,
      P_DELAY_TYPE,
      P_DELAY_HOUR,
      P_DELAY_MINUTE,
      P_REPORTABLE_FLAG,
      P_USER,
      SYSDATE,
      P_MODIFIED_BY,
      SYSDATE,
      P_FLIGHT,
      P_CGI,
      P_REI,
      P_ICD,
      P_DELAY_CONTROL,
      P_CANX_FLAG,
      P_ADDITIONAL_INFO_FLAG,
      P_CANCELLATION,
      P_AC,
      P_FLIGHT_LOG,
      P_FLIGHT_LEG,
      P_RECODE,
      P_RECODE_REASON,
      P_CANCELLED_FLIGHT,
      P_SWAPPED_TO_AC,
      P_STATION,
      P_DELAY_REASON,
      P_DELAY_CODE,
       sysdate;

    P_ID := n_ID  ;

    RETURN;
  END;

  PROCEDURE QUERY_DELAY(
    P_RESULT OUT SYS_REFCURSOR,
    P_ID DEFECT_REPORT_DELAY.ID%TYPE DEFAULT NULL,
    P_AC DEFECT_REPORT_DELAY.AC%TYPE DEFAULT NULL,
    P_DEFECT_TYPE DEFECT_REPORT_DELAY.DEFECT_TYPE%TYPE DEFAULT NULL,
    P_DEFECT DEFECT_REPORT_DELAY.DEFECT%TYPE DEFAULT NULL,
    P_DEFECT_ITEM DEFECT_REPORT_DELAY.DEFECT_ITEM%TYPE DEFAULT NULL,
    P_FLIGHT_LOG DEFECT_REPORT_DELAY.FLIGHT_LOG%TYPE DEFAULT NULL,
    P_FLIGHT_LEG DEFECT_REPORT_DELAY.FLIGHT_LEG%TYPE DEFAULT NULL,
    P_FLIGHT DEFECT_REPORT_DELAY.FLIGHT%TYPE DEFAULT NULL,
    P_DELAY_TYPE DEFECT_REPORT_DELAY.DELAY_TYPE%TYPE DEFAULT NULL,
    P_FLIGHT_DATE AC_ACTUAL_FLIGHTS.FLIGHT_DATE%TYPE DEFAULT NULL,
    P_ORIGIN AC_ACTUAL_FLIGHTS.ORIGIN%TYPE DEFAULT NULL,
    P_STATION DEFECT_REPORT_DELAY.STATION%TYPE DEFAULT NULL,
    P_DELAY_REASON DEFECT_REPORT_DELAY.DELAY_REASON%TYPE DEFAULT NULL,
    P_DELAY_CODE DEFECT_REPORT_DELAY.DELAY_CODE%TYPE DEFAULT NULL
  )
  IS
    l_query VARCHAR2(2000);
    cur SYS_REFCURSOR;
  BEGIN
    l_query := 'select * from defect_Report_delay where 1=1 ';

    --p_id
    If (p_id IS NOT NULL and p_id > 0) Then
      l_query := l_query || ' AND "ID" = :p_id ';
    Else
      l_query := l_query || ' AND (1=1 or :p_id is null)';
    End If;

    --p_ac
    If (p_ac IS NOT NULL) Then
      l_query := l_query || ' AND "AC" = :p_ac ';
    Else
      l_query := l_query || ' AND (1=1 or :p_ac is null)';
    End If;

    --p_defect_type
    If (p_defect_type IS NOT NULL) Then
      l_query := l_query || ' AND "DEFECT_TYPE" = :p_defect_type ';
    Else
      l_query := l_query || ' AND (1=1 or :p_defect_type is null)';
    End If;

    --p_defect
    If (p_defect IS NOT NULL) Then
      l_query := l_query || ' AND "DEFECT" = :p_defect ';
    Else
      l_query := l_query || ' AND (1=1 or :p_defect is null)';
    End If;

    --p_defect_item
    If (p_defect_item IS NOT NULL and p_defect_item > 0) Then
      l_query := l_query || ' AND "DEFECT_ITEM" = :p_defect_item ';
    Else
      l_query := l_query || ' AND (1=1 or :p_defect_item is null)';
    End If;

    --p_flight_log
    If (p_flight_log IS NOT NULL) Then
      l_query := l_query || ' AND "FLIGHT_LOG" = :p_flight_log ';
    Else
      l_query := l_query || ' AND (1=1 or :p_flight_log is null)';
    End If;

    --p_flight_leg
    If (p_flight_leg IS NOT NULL and p_flight_leg > 0) Then
      l_query := l_query || ' AND "FLIGHT_LEG" = :p_flight_leg ';
    Else
      l_query := l_query || ' AND (1=1 or :p_flight_leg is null)';
    End If;

    --p_flight
    If (p_flight IS NOT NULL) Then
      l_query := l_query || ' AND "FLIGHT" = :p_flight ';
    Else
      l_query := l_query || ' AND (1=1 or :p_flight is null)';
    End If;

    --p_delay_type
    If (p_delay_type IS NOT NULL) Then
      l_query := l_query || ' AND "DELAY_TYPE" = :p_delay_type ';
    Else
      l_query := l_query || ' AND (1=1 or :p_delay_type is null)';
    End If;

    --p_flight_date
    If (p_flight_date IS NOT NULL) Then
      l_query := l_query || ' AND EXISTS (select 1 from ac_actual_flights aaf
      where aaf.ac = defect_report_delay.ac
      and   aaf.flight_log = defect_report_delay.flight_log
      and   aaf.flight_leg = defect_report_delay.flight_leg
      and   aaf.flight_date = :p_flight_date )';
    Else
      l_query := l_query || ' AND (1=1 or :p_flight_date is null)';
    End If;

    --p_origin
    If (p_origin IS NOT NULL) Then
      l_query := l_query || ' AND EXISTS (select 1 from ac_actual_flights aaf
      where aaf.ac = defect_report_delay.ac
      and   aaf.flight_log = defect_report_delay.flight_log
      and   aaf.flight_leg = defect_report_delay.flight_leg
      and   aaf.origin = :p_origin )';
    Else
      l_query := l_query || ' AND (1=1 or :p_origin is null)';
    End If;

    --p_station
    If (p_station IS NOT NULL) Then
      l_query := l_query || ' AND "STATION" =  :p_station ';
    Else
      l_query := l_query || ' AND (1=1 or :p_station is null)';
    End If;

    --p_delay_code
    If (p_delay_code IS NOT NULL) Then
      l_query := l_query || ' AND "DELAY_CODE" = :p_delay_code ';
    Else
      l_query := l_query || ' AND (1=1 or :p_delay_code is null)';
    End If;
    
    --p_delay_reason
    If (p_delay_reason is not null) then
      l_query := l_query || ' AND "DELAY_REASON" = :p_delay_reason ';
    else 
      l_query := l_query || ' AND (1=1 or :p_delay_reason is null)';
    end if;

    open cur for l_query using p_id, p_ac, p_defect_type, p_defect, p_defect_item,
    p_flight_log, p_flight_leg, p_flight, p_delay_type, p_flight_date, p_origin,
    p_station, p_delay_code, p_delay_reason;

    P_RESULT := cur;
    return;
  END;

  PROCEDURE UPDATE_DELAY (
    P_UPDATED_ROW_COUNT OUT NUMBER,
    P_ID NUMBER,
    P_AC VARCHAR2,
    P_DEFECT_TYPE VARCHAR2,
    P_DEFECT VARCHAR2,
    P_DEFECT_ITEM NUMBER,
    P_FLIGHT_LOG VARCHAR2,
    P_FLIGHT_LEG NUMBER,
    P_FLIGHT VARCHAR2,
    P_DELAY_TYPE VARCHAR2,
    P_DELAY_HOUR NUMBER,
    P_DELAY_MINUTE NUMBER,
    P_CANCELLATION VARCHAR2,
    P_CANCELLED_FLIGHT VARCHAR2,
    P_DELAY_CONTROL VARCHAR2,
    P_CGI VARCHAR2,
    P_REI VARCHAR2,
    P_CANX_FLAG VARCHAR2,
    P_ICD VARCHAR2,
    P_REPORTABLE_FLAG VARCHAR2,
    P_ADDITIONAL_INFO_FLAG VARCHAR2,
    P_SWAPPED_TO_AC VARCHAR2,
    P_RECODE VARCHAR2,
    P_RECODE_REASON VARCHAR2,
    P_MODIFIED_BY VARCHAR2,
    P_STATION IN VARCHAR2 DEFAULT NULL,
    P_DELAY_REASON IN VARCHAR2 DEFAULT NULL,
    P_DELAY_CODE IN VARCHAR2 DEFAULT NULL
  ) IS
    L_CURRENT_DATE DATE;
    S_COMPANY_PROFILE VARCHAR2(10);
    S_DEFECT_TYPE VARCHAR2(100);
    S_DEFECT_ITEM NUMBER;
    S_DEFECT VARCHAR2(100);
  BEGIN
    L_CURRENT_DATE := PKG_APPLICATION_FUNCTION.CURRENTDATETIME;
    S_COMPANY_PROFILE := PKG_APPLICATION_FUNCTION.GETCOMPANYPROFILE;
 
    S_DEFECT_ITEM := 0;
    IF(S_COMPANY_PROFILE = 'GTI')
    THEN
      BEGIN
      
        SELECT  DEFECT_TYPE, DEFECT,DEFECT_ITEM
        INTO S_DEFECT_TYPE,S_DEFECT, S_DEFECT_ITEM
        FROM "DEFECT_REPORT_DELAY"
        WHERE  "DEFECT_REPORT_DELAY"."ID" = P_ID;
        
      exception
      WHEN others THEN
       RETURN;
      END;
      
      IF (S_DEFECT_TYPE IS NOT NULL AND S_DEFECT IS NOT NULL AND S_DEFECT_ITEM > 0)
      THEN
        RETURN;
      END IF;
      
    END IF;
    UPDATE DEFECT_REPORT_DELAY
    SET
      AC = P_AC,
      DEFECT_TYPE = P_DEFECT_TYPE,
      DEFECT = P_DEFECT,
      DEFECT_ITEM = P_DEFECT_ITEM,
      FLIGHT_LOG = P_FLIGHT_LOG,
      FLIGHT_LEG = P_FLIGHT_LEG,
      FLIGHT = P_FLIGHT,
      DELAY_TYPE = P_DELAY_TYPE,
      DELAY_HOUR = P_DELAY_HOUR,
      DELAY_MINUTES = P_DELAY_MINUTE,
      CANCELLATION = P_CANCELLATION,
      CANCELED_FLIGHT = P_CANCELLED_FLIGHT,
      DELAY_CONTROL = P_DELAY_CONTROL,
      CGI = P_CGI,
      REI = P_REI,
      CANX = P_CANX_FLAG,
      ICD = P_ICD,
      REPORTABLE = P_REPORTABLE_FLAG,
      ADDITIONAL_INFO = P_ADDITIONAL_INFO_FLAG,
      SWAPPED_TO_AC = P_SWAPPED_TO_AC,
      RECODE = P_RECODE,
      RECODE_REASON = P_RECODE_REASON,
      MODIFIED_BY = P_MODIFIED_BY,
      MODIFIED_DATE = L_CURRENT_DATE,
      STATION = P_STATION,
      DELAY_REASON = P_DELAY_REASON,
      DELAY_CODE = P_DELAY_CODE
    WHERE "ID" = P_ID;

    P_UPDATED_ROW_COUNT := SQL%ROWCOUNT;
    return;
  END;

  PROCEDURE DELETE_DELAY (
    P_DELETED_ROW_COUNT OUT NUMBER,
    P_ID DEFECT_REPORT_DELAY.ID%TYPE DEFAULT NULL
  )IS
  BEGIN
    DELETE FROM DEFECT_REPORT_DELAY
    WHERE "ID" = P_ID;

    P_DELETED_ROW_COUNT := SQL%ROWCOUNT;
    RETURN;
  END;



END PKG_IFACE_DELAY;

 / 
 
  CREATE OR REPLACE PACKAGE "PKG_PROD_CONTROL" AS 

  PROCEDURE APPLY_TEMPLATE(l_wo_parent WO.WO%TYPE, l_id PHASE_TEMPLATE_HEADER.TEMPLATE_ID%TYPE, s_user PHASE_TEMPLATE_HEADER.CREATED_BY%TYPE);
  PROCEDURE POPULATE_TASKCARD_SKILL(x VARCHAR2) ;  
  PROCEDURE ASSIGN_TASK_CARD( s_employee TASK_CARD_EMPLOYEE_ASSIGNED.EMPLOYEE%TYPE, l_wo WO_TASK_CARD.WO%TYPE, s_task_card WO_TASK_CARD.TASK_CARD%TYPE ,
                              s_ac TASK_CARD_EMPLOYEE_ASSIGNED.AC%TYPE, s_pn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN%TYPE, s_sn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN_SN%TYPE,
                              s_user VARCHAR2) ;
  PROCEDURE REASSIGN_TASK_CARD( s_employee TASK_CARD_EMPLOYEE_ASSIGNED.EMPLOYEE%TYPE, l_wo WO_TASK_CARD.WO%TYPE, s_task_card WO_TASK_CARD.TASK_CARD%TYPE ,
                              s_ac TASK_CARD_EMPLOYEE_ASSIGNED.AC%TYPE, s_pn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN%TYPE, s_sn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN_SN%TYPE,
                              s_user VARCHAR2 , s_old_employee TASK_CARD_EMPLOYEE_ASSIGNED.EMPLOYEE%TYPE)   ;   	
  FUNCTION GET_PLAIN_TEXT(RTF_TEXT VARCHAR2) RETURN VARCHAR2;                                
  FUNCTION GET_NEXT_FLIGHT(s_flight VARCHAR2, sched_date DATE) return VARCHAR2; 
  FUNCTION GET_NEXT_FLIGHT(s_flight VARCHAR2, sched_date DATE, s_type VARCHAR2) return VARCHAR2;
  
  FUNCTION GET_NEXT_FLIGHT_EX( s_previous_destination VARCHAR2 , s_ac VARCHAR2 ,  previous_arrival_date DATE) return DATE;
  
  FUNCTION GET_ROW_LETTERS(s_ac VARCHAR2)  return VARCHAR2;
  
  function get_flights_range(s_location varchar2 , fromDate DATE , toDate DATE ) return VARCHAR2 ; 
  
  procedure clean_notification_queue;
  
  PROCEDURE ASSIGN_TASK_CARD_INSP( s_employee TASK_CARD_EMPLOYEE_ASSIGNED.EMPLOYEE%TYPE, l_wo WO_TASK_CARD.WO%TYPE, s_task_card WO_TASK_CARD.TASK_CARD%TYPE ,
                              s_ac TASK_CARD_EMPLOYEE_ASSIGNED.AC%TYPE, s_pn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN%TYPE, s_sn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN_SN%TYPE,
                              s_user VARCHAR2) ;
                              
  PROCEDURE UNASSIGN_FLIGHT; --log 256601
  
  procedure getDefectDueAt(
    v_defect_type in "PLANNING"."DEFECT_TYPE"%TYPE,
    v_defect in "PLANNING"."DEFECT"%TYPE,
    l_defect_item in "PLANNING"."DEFECT_ITEM"%TYPE,
    dt_forcasted_due_date out nocopy date,
    d_due_at_ac_hours out nocopy number,
    d_due_at_ac_minutes out nocopy number,
    d_due_at_ac_cycles out nocopy number,   
    d_remaining_hours out nocopy number,
    d_remaining_minutes out nocopy number,
    d_remaining_cycles out nocopy number,  
    d_remaining_days out nocopy number   
    )  ;                  
    
    PROCEDURE AUTO_ASSIGN_EMPLOYEES(loc VARCHAR2, empHours NUMBER, wDate DATE);
    
    FUNCTION GET_PLANNING_REMAINING( s_defect_type VARCHAR2, s_defect VARCHAR2, l_defect_item NUMBER , unit VARCHAR2) return NUMBER;
  
END PKG_PROD_CONTROL;

/

 CREATE OR REPLACE PACKAGE BODY "PKG_PROD_CONTROL" AS

 PROCEDURE APPLY_TEMPLATE(l_wo_parent WO.WO%TYPE, l_id PHASE_TEMPLATE_HEADER.TEMPLATE_ID%TYPE, s_user PHASE_TEMPLATE_HEADER.CREATED_BY%TYPE) AS
    l_new_id NUMBER;
    schedule_date DATE;
    today DATE;
    l_item NUMBER;
    l_grouped NUMBER;
    firstTime NUMBER;
    l_current_group NUMBER;
    max_hour NUMBER;
    task_dur NUMBER;
    v_code NUMBER;
    v_errm VARCHAR2(200);
    save_date DATE;
    start_date DATE;
    end_date DATE;
    total_hours NUMBER(8,2);
    end_hour NUMBER;
    end_minute NUMBER;
    start_hour NUMBER;
    start_minute NUMBER;
    times NUMBER;
    tc_count NUMBER;
    day_count NUMBER;
    day_of_flow NUMBER;
    pos NUMBER;
    l_wo WO.WO%TYPE;
    swap NUMBER;
    loopCount NUMBER;
    tMH NUMBER(8,2);
    isWeekend NUMBER(8,0);
    proportion NUMBER(8,2);
    openPhase VARCHAR2(10);
    closePhase VARCHAR2(10);

    CURSOR cur_temp (temp_id NUMBER, temp_wo NUMBER)IS
      (  SELECT "WO_TEMPLATE_DETAIL"."ITEM",
         "WO_TEMPLATE_DETAIL"."GROUPED"
    FROM "WO_TEMPLATE_DETAIL"
   WHERE ( "WO_TEMPLATE_DETAIL"."TEMPLATE_ID" = temp_id ) AND
         ( "WO_TEMPLATE_DETAIL"."WO" = temp_wo )
      );

  BEGIN
  
        for xWo in (SELECT WO FROM WO START WITH WO = l_wo_parent CONNECT BY PRIOR WO = NH_WO)
        loop
        
            l_wo := xWo.WO;
           DELETE FROM "WO_TEMPLATE_DETAIL"
            WHERE "WO_TEMPLATE_DETAIL"."TEMPLATE_ID" IN
            (SELECT "WO_TEMPLATE_HEADER"."TEMPLATE_ID"
             FROM "WO_TEMPLATE_HEADER"
             WHERE "WO_TEMPLATE_HEADER"."WO" = l_wo);
        
             DELETE FROM "WO_TEMPLATE_HEADER"
             WHERE "WO_TEMPLATE_HEADER"."WO" = l_wo;
            COMMIT;
        
            --Insert Header
            SELECT "SEQ_WO_TEMPLATE".NextVal
            INTO l_new_id
            FROM DUAL;
        
            SELECT TRUNC(WO.SCHEDULE_START_DATE),
                   TRUNC(SYSDATE)
            INTO schedule_date,
                today
            FROM WO
            WHERE WO.WO = l_wo;
        
            INSERT
            INTO "WO_TEMPLATE_HEADER"
              (
               "TEMPLATE_ID",
               "WO",
               "CODE",
               "NO_OF_DAYS",
               "DESCRIPTION",
               "CREATED_BY",
               "CREATED_DATE",
               "MODIFIED_BY",
               "MODIFIED_DATE",
               "SCHEDULE_START_DATE"
              )
              SELECT l_new_id,
                     l_wo,
                     "PHASE_TEMPLATE_HEADER"."CODE",
                     "PHASE_TEMPLATE_HEADER"."NO_OF_DAYS",
                     "PHASE_TEMPLATE_HEADER"."DESCRIPTION",
                      s_user,
                      today,
                      s_user,
                      today  ,
                      schedule_date
              FROM "PHASE_TEMPLATE_HEADER"
              WHERE "PHASE_TEMPLATE_HEADER"."TEMPLATE_ID" = l_id;
              COMMIT;
              day_of_flow := -1;
            --Insert Detail
              INSERT
                INTO "WO_TEMPLATE_DETAIL"
                  (
                    "TEMPLATE_ID",
                    "ITEM",
                    "WO",
                    "DAY",
                    "PHASE",
                    "MILESTONE",
                    "CATEGORY",
                    "CREATED_BY",
                    "CREATED_DATE",
                    "MODIFIED_BY",
                    "MODIFIED_DATE",
                    "GROUPED",
                    "SCHEDULE_DATE","DURATION",
                    FROM_LINK,TO_LINK,PARENT_ITEM
                  )
                SELECT l_new_id,
                  "PHASE_TEMPLATE_DETAIL"."ITEM",
                  l_wo,
                  "PHASE_TEMPLATE_DETAIL"."DAY",
                  "PHASE_TEMPLATE_DETAIL"."PHASE",
                  "PHASE_TEMPLATE_DETAIL"."MILESTONE",
                  "PHASE_TEMPLATE_DETAIL"."CATEGORY",
                  s_user,
                  today,
                  s_user,
                  today,
                  "PHASE_TEMPLATE_DETAIL"."GROUPED",
                  (schedule_date + "PHASE_TEMPLATE_DETAIL"."DAY" - 1),PHASE_TEMPLATE_DETAIL."DURATION",
                  PHASE_TEMPLATE_DETAIL.FROM_LINK,PHASE_TEMPLATE_DETAIL.TO_LINK,PHASE_TEMPLATE_DETAIL.PARENT_ITEM
                  
                FROM "PHASE_TEMPLATE_DETAIL"
                WHERE "PHASE_TEMPLATE_DETAIL"."TEMPLATE_ID" = l_id
                UNION
                SELECT l_new_id,
                 TRUNC(dbms_random.value((SELECT count(*)  FROM PHASE_TEMPLATE_DETAIL WHERE TEMPLATE_ID = l_id),1000)) AS ITEM,
                l_wo,
                1 AS DAY,
                T.PHASE AS PHASE,                  
                'N' AS MILESTONE,
                'DAY' AS CATEGORY,
                s_user,
                today,
                s_user,
                today,             
                0 AS GROUPED,
                schedule_date ,
                1 AS DURATION,
                null as from_link,
                null as to_link, 
                null as parent_item
                from ((SELECT DISTINCT NVL(WT.PHASE,'NOPHASE') AS PHASE FROM WO_TASK_CARD WT WHERE WT.WO = l_wo AND NVL(WT.PHASE,'NOPHASE') NOT IN (SELECT PTD.PHASE FROM PHASE_TEMPLATE_DETAIL PTD WHERE PTD.TEMPLATE_ID = l_id))) T
                ;
                COMMIT;
                
                SELECT PHASE INTO openPhase FROM PHASE_TEMPLATE_DETAIL WHERE TEMPLATE_ID = l_id AND PANEL_ACCESS = 'OPEN' AND rownum = 1;
                SELECT PHASE INTO closePhase FROM PHASE_TEMPLATE_DETAIL WHERE TEMPLATE_ID = l_id AND PANEL_ACCESS = 'CLOSE' AND rownum = 1;
                if openPhase is not null then
                    UPDATE WO_TASK_CARD 
                    SET PHASE = openPhase
                    WHERE WO = l_wo AND task_card like to_char(l_wo) || '-PNLTC-%' AND PANEL_TC = 'OPEN' ;
                    COMMIT;
                end if;
                
                if closePhase is not null then
                    UPDATE WO_TASK_CARD 
                    SET PHASE = closePhase
                    WHERE WO = l_wo AND task_card like to_char(l_wo) || '-PNLTC-%' AND PANEL_TC = 'CLOSE' ;
                    COMMIT;
                end if;
                
                
                
                times := 1;
                swap := 0;
               -- end_date := schedule_date;
                for x in (
                    SELECT 0 AS DAY,T.PHASE,1 AS DURATION,1 as CONFIG_NUMBER, 1 as outside 
                    from (SELECT DISTINCT NVL(WT.PHASE,'NOPHASE') AS PHASE FROM WO_TASK_CARD WT WHERE WT.WO = l_wo AND NVL(WT.PHASE,'NOPHASE') NOT IN (SELECT PTD.PHASE FROM PHASE_TEMPLATE_DETAIL PTD WHERE PTD.TEMPLATE_ID = l_id)) T
                     UNION
                          SELECT "PHASE_TEMPLATE_DETAIL"."DAY",
                                 "PHASE_TEMPLATE_DETAIL"."PHASE",
                                 "PHASE_TEMPLATE_DETAIL"."DURATION",
                                 CONFIG_NUMBER, 0 as outside
                          FROM "PHASE_TEMPLATE_DETAIL", "SYSTEM_TRAN_CODE"
                          WHERE "PHASE_TEMPLATE_DETAIL".TEMPLATE_ID = l_id AND "PHASE_TEMPLATE_DETAIL".PHASE = SYSTEM_TRAN_CODE.SYSTEM_CODE AND
                          SYSTEM_TRAN_CODE.SYSTEM_TRANSACTION = 'TASKCARD/PHASE' AND PHASE_TEMPLATE_DETAIL."CATEGORY" <> 'LINK'
                          ORDER BY CONFIG_NUMBER ASC)
                 loop
        
        
        
                    SELECT count(*) INTO tc_count
                    FROM WO_TASK_CARD
                    WHERE NVL(WO_TASK_CARD.PHASE,'NOPHASE') = x.PHASE AND WO = l_wo;
        
                    if tc_count > 0 and x.duration > 0 then
                        day_count := (tc_count/x.duration);
                        times := 1;
                        pos := 1;
                        if x.outside = 1 then
                            day_of_flow := 0;
                        else
                            if swap > 0 then
                                day_of_flow := day_of_flow + 1;
                            else
                                day_of_flow := 0;
                            end if;
                            swap := swap +1;
                        end if;
                        save_date := (TRUNC(schedule_date) + day_of_flow );
                        while times <= x.duration
                        loop
                        UPDATE WO_TEMPLATE_DETAIL
                        SET SCHEDULE_DATE = save_date
                        WHERE TEMPLATE_ID = l_new_id AND NVL(PHASE,'NOPHASE') = x.PHASE;
                        loopCount := 1;
                           for t in (SELECT * FROM WO_TASK_CARD WHERE WO = l_wo AND NVL(PHASE,'NOPHASE') = x.PHASE   AND WO_TASK_CARD.MODIFIED_BY <> 'PRODCONT'  ORDER BY TASK_CARD ASC )
                           loop
                                if pos >  FLOOR(day_count) AND loopCount < x.duration then
--                                    if(x.phase = 'NR-1') then
--                                        dbms_output.put_line('finished loop ' || loopCount);
--                                    end if;
                                    day_of_flow:= day_of_flow + 1;
                                    save_date := (TRUNC(schedule_date) + day_of_flow );
                                    pos := 1;
                                    loopCount := loopCount + 1;
                                    
                                end if;
--                                 if(x.phase = 'NR-1') then
--                                        dbms_output.put_line('Task: ' || t.TASK_CARD);
--                                    end if;
                                SELECT SUM(WTCI.MAN_HOURS)
                                INTO tMH
                                FROM WO_TASK_CARD_ITEM WTCI
                                WHERE WTCI.WO = l_wo AND WTCI.TASK_CARD = t.TASK_CARD AND WTCI.AC = t.AC AND WTCI.TASK_CARD_PN = t.PN AND WTCI.TASK_CARD_PN_SN = t.PN_SN;
                                
                                if tMH > 30 then
                                    isWeekend := 0;
                                    end if;
                                
                                SELECT count(*)
                                INTO isWeekend
                                FROM dual
                                WHERE MOD(TO_CHAR(save_date , 'J'), 7) + 1 IN (6, 7);
                                
                                if isWeekend > 0 then
                                    proportion := 2.4;
                                else
                                    proportion := 1.5;
                                end if;
--                                 Fixed size to a maximum of 1 day and minimum of 1/4 of day                                
--                                if tMH < 4 then
--                                    end_hour := 6;
--                                    end_minute := 0;
--                                elsif tMH >=4  AND tMH < 8 then
--                                    end_hour := 12;
--                                    end_minute := 0;
--                                elsif tMH >=8  AND tMH < 12 then
--                                    end_hour := 18;
--                                    end_minute := 0;
--                                else
--                                    end_hour := 23;
--                                    end_minute := 59;
--                                end if;
                             -- Proportional size with minimum of 1/4 day.
                             tMh := tMh * proportion;
                             if tMh <= 6 then
                                end_date := trunc(save_date);
                                end_hour := 6;
                                end_minute := 0;
                            else
                                SELECT trunc(save_date) + tMh/24,
                                       to_char(trunc(save_date) + tMh/24,'HH24') ,
                                       to_char(trunc(save_date) + tMh/24,'MI') 
                                INTO end_date,
                                     end_hour,
                                     end_minute
                                FROM DUAL;
                                
                            end if;
                                


                                UPDATE WO_TASK_CARD
                                SET SCHEDULE_START_DATE = save_date,
                                    SCHEDULE_START_HOUR = 0,
                                    SCHEDULE_START_MINUTE = 0,
                                    SCHEDULE_END_DATE = (end_date) ,
                                    SCHEDULE_END_HOUR = end_hour,
                                    SCHEDULE_END_MINUTE = end_minute,
                                    FLOWDAY = TO_CHAR(day_of_flow),
                                    MODIFIED_DATE = SYSDATE,
                                    MODIFIED_BY = 'PRODCONT'
                                WHERE  WO_TASK_CARD.WO = l_wo AND WO_TASK_CARD.TASK_CARD = t.TASK_CARD AND WO_TASK_CARD.AC = t.AC AND WO_TASK_CARD.PN = t.PN AND WO_TASK_CARD.PN_SN = t.PN_SN
                                      ;
                                      pos := pos + 1;
                           end loop;
                           times := times + 1;
        
        
                        end loop;
                        UPDATE WO_TASK_CARD
                           SET MODIFIED_BY = s_user
                           WHERE NVL(WO_TASK_CARD.PHASE,'NOPHASE') = x.PHASE AND WO = l_wo;
        
                    end if;
        
        
        
                /*
                    if(times = 1) then
                      save_date := (TRUNC(schedule_date) + x."DAY" - 1);
                    else
                      save_date := save_date + (max_hour/24);
                    end if;
                     SELECT
                         MAX(SUM(nvl( (tci.man_hours * tci."MAN_REQUIRE"),0) + nvl( (tci."INSPECTOR_MAN_HOURS" * tci."INSPECTOR_MAN_REQUIRE"),0) + nvl( (
                         tci."DUAL_INSPECTOR_MAN_HOURS" * tci."DUAL_INSPECTOR_MAN_REQUIRE"),0) ))
                     INTO max_hour
                     FROM
                         wo_task_card_item tci,
                         wo_task_card wt
                     WHERE
                         tci.wo = l_wo
                         AND wt.wo = tci.wo
                         AND wt.task_card = tci.task_card
                         AND wt.ac = tci.ac
                         AND wt.pn = tci.task_card_pn
                         AND wt.pn_sn = tci.task_card_pn_sn
                         AND wt.phase = x.PHASE
                          GROUP BY tci.wo,tci.task_card,tci.ac,tci.task_card_pn,tci.task_card_pn_sn,wt.phase ;
        
                    if NVL(max_hour,0) = 0 then
                        max_hour := 24;
                    end if;
        
        
                    times := times + 1;
                    for t in (SELECT * FROM WO_TASK_CARD WHERE WO = l_wo AND PHASE = x.PHASE)
                    loop
                        SELECT sum(nvl( (tci.man_hours * tci."MAN_REQUIRE"),0) + nvl( (tci."INSPECTOR_MAN_HOURS" * tci."INSPECTOR_MAN_REQUIRE"),0) + nvl( (tci."DUAL_INSPECTOR_MAN_HOURS" * tci."DUAL_INSPECTOR_MAN_REQUIRE"),0))
                         INTO total_hours
                         FROM WO_TASK_CARD_ITEM TCI
                         WHERE t.wo = tci.wo
                         AND t.task_card = tci.task_card
                         AND t.ac = tci.ac
                         AND t.pn = tci.task_card_pn
                         AND t.pn_sn = tci.task_card_pn_sn;
                         if (total_hours < 24) then
                            end_hour := floor(total_hours);
                            end_minute := (total_hours - trunc(total_hours))* 60;
                         else
                            end_hour := trunc(total_hours/24);
                            end_minute := ((total_hours/24) - trunc((total_hours/24)))* 60;
                         end if;
        
                         Begin
                          SELECT  PKG_APPLICATION_FUNCTION.getCombinedDate(TC.SCHEDULE_END_DATE,TC.SCHEDULE_END_HOUR,TC.SCHEDULE_END_MINUTE) as dt_end,
                          TC.SCHEDULE_END_HOUR,
                          TC.SCHEDULE_END_MINUTE
                          INTO end_date,
                                start_hour,
                                start_minute
                            FROM WO_TASK_CARD TC,
                                 ( select W3.WO,
                                          W3.PRE_TASK_CARD ,
                                          W3.PRE_TASK_CARD_AC,
                                          W3.PRE_TASK_CARD_PN,
                                          W3.PRE_TASK_CARD_SN
                                   from WO_TASK_CARD_EXECUTION W3
                                   where  W3.WO  = t.wo AND
                                          W3.TASK_CARD  = t.task_card AND
                                          W3.AC  = t.ac AND
                                          W3.PN  = t.pn AND
                                          W3.SN  = t.pn_sn ) B
                            WHERE TC."WO" = B.WO AND
                                  TC.TASK_CARD  = B.PRE_TASK_CARD and
                                  TC.AC  = B.PRE_TASK_CARD_AC AND
                                  TC.PN  = B.PRE_TASK_CARD_PN AND
                                  TC.PN_SN  = B.PRE_TASK_CARD_SN
                            ORDER BY  PKG_APPLICATION_FUNCTION.getCombinedDate(TC.SCHEDULE_END_DATE,TC.SCHEDULE_END_HOUR,TC.SCHEDULE_END_MINUTE) DESC;
        
                          Exception when others then
                            end_date := save_date;
                            select to_char(save_date,'HH24') into start_hour from dual;
                            select to_char(save_date,'MI') into start_minute from dual;
                          --  start_hour := 0;
                          --  start_minute := 0;
                          end;
        
        
                            UPDATE WO_TASK_CARD
                            SET SCHEDULE_START_DATE = end_date,
                                SCHEDULE_START_HOUR = start_hour,
                                SCHEDULE_START_MINUTE = start_minute,
                                SCHEDULE_END_DATE = (end_date) + (total_hours/24),
                                SCHEDULE_END_HOUR = end_hour,
                                SCHEDULE_END_MINUTE = end_minute,
                                FLOWDAY = TO_CHAR(x.DAY)
                            WHERE  WO_TASK_CARD.WO = l_wo AND WO_TASK_CARD.TASK_CARD = t.TASK_CARD AND WO_TASK_CARD.AC = t.AC AND WO_TASK_CARD.PN = t.PN AND WO_TASK_CARD.PN_SN = t.PN_SN;
        
        
        
                    end loop;
                 */
        --            UPDATE WO_TASK_CARD
        --            SET SCHEDULE_START_DATE = save_date,
        --                SCHEDULE_START_HOUR = 0,
        --                SCHEDULE_START_MINUTE = 0,
        --                SCHEDULE_END_DATE = (save_date) + --round(max_hour/24),
        --                (SELECT sum(nvl( (tci.man_hours * tci."MAN_REQUIRE"),0) + nvl( (tci."INSPECTOR_MAN_HOURS" * tci."INSPECTOR_MAN_REQUIRE"),0) + nvl( (tci."DUAL_INSPECTOR_MAN_HOURS" * tci."DUAL_INSPECTOR_MAN_REQUIRE"),0))
        --                 FROM WO_TASK_CARD_ITEM TCI
        --                 WHERE WO_TASK_CARD.wo = tci.wo
        --                 AND WO_TASK_CARD.task_card = tci.task_card
        --                 AND WO_TASK_CARD.ac = tci.ac
        --                 AND WO_TASK_CARD.pn = tci.task_card_pn
        --                 AND WO_TASK_CARD.pn_sn = tci.task_card_pn_sn)/24,
        --                SCHEDULE_END_HOUR = 23,
        --                SCHEDULE_END_MINUTE = 59,
        --                FLOWDAY = TO_CHAR(x.DAY)
        --            WHERE WO_TASK_CARD.PHASE = x.PHASE AND WO_TASK_CARD.WO = l_wo;
        
        
        --            UPDATE WO_TEMPLATE_DETAIL
        --            SET WO_TEMPLATE_DETAIL.SCHEDULE_DATE = (save_date),
        --                WO_TEMPLATE_DETAIL."DURATION" = (max_hour/24)
        --            WHERE WO_TEMPLATE_DETAIL.WO = l_wo and WO_TEMPLATE_DETAIL.PHASE = x.PHASE;
        --            commit;
                 end loop;
        
               UPDATE "WO"
                SET "TEMPLATE_ID" = l_new_id
                WHERE "WO"."WO" = l_wo;
                COMMIT;
        end loop;
  END APPLY_TEMPLATE;
  
  PROCEDURE POPULATE_TASKCARD_SKILL(x VARCHAR2)
   AS
    l_wo WO_TASK_CARD.WO%TYPE;
    s_task_card WO_TASK_CARD.TASK_CARD%TYPE;
    s_ac WO_TASK_CARD.AC%TYPE;
    s_pn WO_TASK_CARD.PN%TYPE;
    s_pn_sn WO_TASK_CARD.PN_SN%TYPE;
    s_skill WO_TASK_CARD.SKILL%TYPE;    
    CURSOR cur_temp IS 
      (   SELECT WTC.WO,
                 WTC.TASK_CARD,
                 WTC.AC,
                 WTC.PN,
                 WTC.PN_SN
          FROM WO_TASK_CARD WTC,
               WO
          WHERE WO.WO = WTC.WO AND
                WO.CREATED_DATE > to_date('01-JAN-2014','DD-MON-YYYY') AND
                WTC.SKILL IS NULL  AND 
                WO.STATUS NOT IN ('CLOSED','COMPLETED','POSTCOMPLT')
      );
    BEGIN    
      OPEN cur_temp;
      LOOP
          FETCH cur_temp
          INTO l_wo,s_task_card, s_ac, s_pn, s_pn_sn;
          EXIT WHEN cur_temp%notfound; 
          
          BEGIN
            SELECT WTCI.SKILL
            INTO s_skill
            FROM WO_TASK_CARD_ITEM WTCI
            WHERE WTCI.WO = l_wo AND
                  WTCI.TASK_CARD = s_task_card AND
                  WTCI.AC = s_ac AND
                  WTCI.TASK_CARD_PN = s_pn AND
                  WTCI.TASK_CARD_PN_SN = s_pn_sn AND
                  WTCI.MAIN_SKILL = 'YES' AND
                  rownum = 1 ;
          EXCEPTION
            WHEN no_data_found then
            BEGIN
              SELECT WTCI.SKILL
            INTO s_skill
            FROM WO_TASK_CARD_ITEM WTCI
            WHERE WTCI.WO = l_wo AND
                  WTCI.TASK_CARD = s_task_card AND
                  WTCI.AC = s_ac AND
                  WTCI.TASK_CARD_PN = s_pn AND
                  WTCI.TASK_CARD_PN_SN = s_pn_sn AND
                  WTCI.TASK_CARD_ITEM = 1 AND
                  rownum = 1;
            EXCEPTION
            WHEN no_data_found then
              s_skill := null;
            END;
          END;
          IF s_skill IS NULL THEN
             BEGIN
            SELECT WTCI.SKILL
            INTO s_skill
            FROM WO_TASK_CARD_ITEM WTCI
            WHERE WTCI.WO = l_wo AND
                  WTCI.TASK_CARD = s_task_card AND
                  WTCI.AC = s_ac AND
                  WTCI.TASK_CARD_PN = s_pn AND
                  WTCI.TASK_CARD_PN_SN = s_pn_sn AND
                  WTCI.TASK_CARD_ITEM = 1 AND 
                  rownum = 1;
            EXCEPTION
            WHEN no_data_found then
              s_skill := null;
            END;
          END IF;
          IF s_skill IS NOT NULL THEN
            UPDATE WO_TASK_CARD
            SET WO_TASK_CARD.SKILL = s_skill              
            WHERE WO_TASK_CARD.WO = l_wo AND
                  WO_TASK_CARD.TASK_CARD = s_task_card AND
                  WO_TASK_CARD.AC = s_ac AND
                  WO_TASK_CARD.PN = s_pn AND
                  WO_TASK_CARD.PN_SN = s_pn_sn;                                                                            
          END IF;
    END LOOP;  
    COMMIT;
    CLOSE cur_temp; 
END POPULATE_TASKCARD_SKILL;

PROCEDURE ASSIGN_TASK_CARD( s_employee TASK_CARD_EMPLOYEE_ASSIGNED.EMPLOYEE%TYPE, l_wo WO_TASK_CARD.WO%TYPE, s_task_card WO_TASK_CARD.TASK_CARD%TYPE ,
                              s_ac TASK_CARD_EMPLOYEE_ASSIGNED.AC%TYPE, s_pn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN%TYPE, s_sn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN_SN%TYPE,
                              s_user VARCHAR2 )     
   AS
    s_result VARCHAR2(10);
    l_count NUMBER;
    s_skill LOCATION_SITE_ASSIGNED.SKILL%TYPE;
   BEGIN
      l_count := 0;
      SELECT COUNT(*)
      INTO l_count
      FROM "TASK_CARD_EMPLOYEE_ASSIGNED"
      WHERE ( "TASK_CARD_EMPLOYEE_ASSIGNED"."WO" = l_wo ) AND  
            ( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD" = s_task_card ) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."AC"),' ') = NVL(TRIM(s_ac ),' ')) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN"),' ') = NVL(TRIM(s_pn ),' ')) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN_SN"),' ') = NVL(TRIM(s_sn ),' ')) AND
            "TASK_CARD_EMPLOYEE_ASSIGNED"."EMPLOYEE" = s_employee;
      IF l_COUNT = 0 THEN
      
        INSERT INTO
          "TASK_CARD_EMPLOYEE_ASSIGNED"
          ( 
          "WO", 
          "TASK_CARD",
          "AC",
          "TASK_CARD_PN",
          "TASK_CARD_PN_SN",
          "EMPLOYEE",
          "CREATED_BY",
          "CREATED_DATE",
          "MODIFIED_BY",
          "MODIFIED_DATE"		
          )
        VALUES
          (
          l_wo,
          s_task_card,
          s_ac,
          s_pn,
          s_sn,
          s_employee,
          s_user,
          SYSDATE,
          s_user,
          SYSDATE
          );
        END IF;
      l_count := 0;
      SELECT COUNT(*)
      INTO l_count
      FROM "LOCATION_SITE_ASSIGNED"
      WHERE ( "LOCATION_SITE_ASSIGNED"."WO" = l_wo ) AND  
            ( "LOCATION_SITE_ASSIGNED"."TASK_CARD" = s_task_card ) AND  
            (NVL(TRIM( "LOCATION_SITE_ASSIGNED"."AC"),' ') = NVL(TRIM(s_ac ),' ')) AND  
            ( NVL(TRIM("LOCATION_SITE_ASSIGNED"."TASK_CARD_PN"), ' ') = NVL(TRIM(s_pn ),' ')) AND  
            ( NVL(TRIM("LOCATION_SITE_ASSIGNED"."TASK_CARD_PN_SN"), ' ') = NVL(TRIM(s_sn ),' ')) AND
            ( "LOCATION_SITE_ASSIGNED"."EMPLOYEE" = s_employee );
      if l_count = 0 then
        BEGIN
          SELECT WO_TASK_CARD_ITEM.SKILL
          INTO s_skill
          FROM WO_TASK_CARD_ITEM
          WHERE WO_TASK_CARD_ITEM.WO = l_wo AND
                WO_TASK_CARD_ITEM.TASK_CARD = s_task_card AND
                WO_TASK_CARD_ITEM.TASK_CARD_PN = s_pn AND
                WO_TASK_CARD_ITEM.TASK_CARD_PN_SN = s_sn AND
                WO_TASK_CARD_ITEM.MAIN_SKILL = 'YES' AND
                rownum = 1;
        EXCEPTION WHEN OTHERS THEN
          s_skill := '          ';
        END;
        BEGIN
        INSERT INTO 
				"LOCATION_SITE_ASSIGNED" 
				(
				"WO",
				"TASK_CARD",
				"AC",
				"TASK_CARD_PN",
				"TASK_CARD_PN_SN",
				"EMPLOYEE",
				"SKILL",
				"MANHOURS", 
				"NOTES", 
				"CREATED_BY", 
				"CREATED_DATE", 
				"MODIFIED_BY", 
				"MODIFIED_DATE" )
			VALUES 
				(
				l_wo,
				s_task_card,
				s_ac,
				s_pn,
				s_sn,
				s_employee,
				s_skill,
				0,
				Null,
				s_user,
        SYSDATE,
        s_user,
        SYSDATE);
        EXCEPTION WHEN OTHERS 
        THEN 
          NULL;
        END;
      end if;
      COMMIT;
   END ASSIGN_TASK_CARD;
   
   PROCEDURE REASSIGN_TASK_CARD( s_employee TASK_CARD_EMPLOYEE_ASSIGNED.EMPLOYEE%TYPE, l_wo WO_TASK_CARD.WO%TYPE, s_task_card WO_TASK_CARD.TASK_CARD%TYPE ,
                              s_ac TASK_CARD_EMPLOYEE_ASSIGNED.AC%TYPE, s_pn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN%TYPE, s_sn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN_SN%TYPE,
                              s_user VARCHAR2 , s_old_employee TASK_CARD_EMPLOYEE_ASSIGNED.EMPLOYEE%TYPE)     
   AS
    s_result VARCHAR2(10);
    l_count NUMBER;
    s_skill LOCATION_SITE_ASSIGNED.SKILL%TYPE;
   BEGIN
      l_count := 0;
      SELECT COUNT(*)
      INTO l_count
      FROM "TASK_CARD_EMPLOYEE_ASSIGNED"
      WHERE ( "TASK_CARD_EMPLOYEE_ASSIGNED"."WO" = l_wo ) AND  
            ( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD" = s_task_card ) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."AC"),' ') = NVL(TRIM(s_ac ),' ')) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN"),' ') = NVL(TRIM(s_pn ),' ')) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN_SN"),' ') = NVL(TRIM(s_sn ),' '));
      IF l_COUNT > 0 THEN
      
        IF s_old_employee IS NOT NULL THEN
        
          UPDATE "TASK_CARD_EMPLOYEE_ASSIGNED"
          SET "EMPLOYEE" = s_employee,
              "MODIFIED_BY" = s_user, 
              "MODIFIED_DATE" = SYSDATE
          WHERE "TASK_CARD_EMPLOYEE_ASSIGNED"."WO" = l_wo AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD" = s_task_card AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."AC" = s_ac AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN" = s_pn AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN_SN" = s_sn AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."EMPLOYEE" = s_old_employee;
        ELSE
          DELETE FROM "TASK_CARD_EMPLOYEE_ASSIGNED"
          WHERE "TASK_CARD_EMPLOYEE_ASSIGNED"."WO" = l_wo AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD" = s_task_card AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."AC" = s_ac AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN" = s_pn AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN_SN" = s_sn AND
                "TASK_CARD_EMPLOYEE_ASSIGNED"."EMPLOYEE" = s_employee;
        END IF;
      END IF;
      l_count := 0;
      SELECT COUNT(*)
      INTO l_count
      FROM "LOCATION_SITE_ASSIGNED"
      WHERE ( "LOCATION_SITE_ASSIGNED"."WO" = l_wo ) AND  
            ( "LOCATION_SITE_ASSIGNED"."TASK_CARD" = s_task_card ) AND  
            (NVL(TRIM( "LOCATION_SITE_ASSIGNED"."AC"),' ') = NVL(TRIM(s_ac ),' ')) AND  
            ( NVL(TRIM("LOCATION_SITE_ASSIGNED"."TASK_CARD_PN"), ' ') = NVL(TRIM(s_pn ),' ')) AND  
            ( NVL(TRIM("LOCATION_SITE_ASSIGNED"."TASK_CARD_PN_SN"), ' ') = NVL(TRIM(s_sn ),' ')) AND
            ( "LOCATION_SITE_ASSIGNED"."EMPLOYEE" = s_old_employee );
      if l_count > 0 then            
        if s_old_employee IS NOT NULL THEN
          BEGIN
          UPDATE "LOCATION_SITE_ASSIGNED"
          SET "EMPLOYEE" = s_employee,
              "MODIFIED_BY" = s_user, 
              "MODIFIED_DATE" = SYSDATE
          WHERE "WO" = l_wo AND
                "TASK_CARD" = s_task_card AND
                "AC" = s_ac AND
                "TASK_CARD_PN" = s_pn AND
                "TASK_CARD_PN_SN" = s_sn AND
                "EMPLOYEE" = s_old_employee;          
          EXCEPTION WHEN OTHERS 
          THEN 
            NULL;
          END;
      else
        DELETE FROM "LOCATION_SITE_ASSIGNED"
        WHERE "WO" = l_wo AND
                "TASK_CARD" = s_task_card AND
                "AC" = s_ac AND
                "TASK_CARD_PN" = s_pn AND
                "TASK_CARD_PN_SN" = s_sn AND
                "EMPLOYEE" = s_employee;
      end if;
      end if;
   END REASSIGN_TASK_CARD;
   
   FUNCTION GET_NEXT_FLIGHT(s_flight VARCHAR2, sched_date DATE) return VARCHAR2   
  AS
   FLIGHT_INFO VARCHAR2(100);  
   FLIGHT_ID NUMBER(30);
  BEGIN
  
    BEGIN
      SELECT MAX("ID")
      INTO FLIGHT_ID
      FROM FLIGHT_SCHEDULE
      WHERE   FLIGHT_SCHEDULE.FLIGHT = s_flight           
          AND sched_date > 
              PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(FLIGHT_SCHEDULE.SCHEDULE_ARRIVAL_DATE_ZULU,FLIGHT_SCHEDULE.SCHEDULE_ARRIVAL_HOUR_ZULU,FLIGHT_SCHEDULE.SCHEDULE_ARRIVAL_MINUTE_ZULU);
        --  AND ROWNUM = 1;
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;
  BEGIN
    SELECT depart 
    INTO FLIGHT_INFO  
    FROM (
              SELECT 'FLIGHT ' || s.flight || ' ' || s.schedule_depart_hour_zulu || ':' || s.schedule_depart_minute_zulu || ' ' || s.destination || ' ' || 
              NVL(trunc(s.schedule_date) - trunc(sysdate),0) || ' ' ||  s.schedule_date AS depart              
              FROM
                flight_schedule s,
                flight_schedule s1
              WHERE
                s1."ID" = flight_id AND              
                (
                  (
                    (
                      TRUNC( s.schedule_date ) = TRUNC(s1.schedule_arrival_date_zulu )
                    AND s.schedule_depart_hour_zulu   = s1.schedule_arrival_hour_zulu
                    AND s.schedule_depart_minute_zulu > s1.schedule_arrival_minute_zulu --d=d and h=h ad m > m
                    )
                  OR
                    (
                      TRUNC(s.schedule_date ) = TRUNC( s1.schedule_arrival_date_zulu)
                    AND s.schedule_depart_hour_zulu > s1.schedule_arrival_hour_zulu -- d=d and  h > h
                    )
                  )
                OR
                  (
                    TRUNC( s.schedule_date) > TRUNC( s1.schedule_arrival_date_zulu )
                  ) -- d > d
                )
              AND s.origin = s1.destination              
              AND s.ac     = s1.AC
              ORDER BY
                s.schedule_date ,
                s.schedule_depart_hour_zulu ,
                s.schedule_depart_minute_zulu ASC
                )
                
    WHERE rownum = 1;
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;
    
    RETURN FLIGHT_INFO;
  END GET_NEXT_FLIGHT;
  
   FUNCTION GET_NEXT_FLIGHT(s_flight VARCHAR2, sched_date DATE, s_type VARCHAR2) return VARCHAR2   
  AS
   FLIGHT_INFO VARCHAR2(100);  
   FLIGHT_ID NUMBER(30);
   next_flight VARCHAR2(100);
   time_flight VARCHAR2(100);
   destination VARCHAR2(100);
   gate VARCHAR2(100);
   next_date VARCHAR2(100);
   
  BEGIN
  
    BEGIN
      SELECT MAX("ID")
      INTO FLIGHT_ID
      FROM FLIGHT_SCHEDULE
      WHERE   FLIGHT_SCHEDULE.FLIGHT = s_flight           
          AND sched_date > 
              PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(FLIGHT_SCHEDULE.SCHEDULE_ARRIVAL_DATE_ZULU,FLIGHT_SCHEDULE.SCHEDULE_ARRIVAL_HOUR_ZULU,FLIGHT_SCHEDULE.SCHEDULE_ARRIVAL_MINUTE_ZULU);
        --  AND ROWNUM = 1;
    EXCEPTION WHEN OTHERS THEN
      NULL;
    END;
  BEGIN
    SELECT flight,  departTime, destLoc, deptGate, depDate
    INTO next_flight,  time_flight , destination, gate, next_date
    FROM (
              SELECT s.flight , s.schedule_depart_hour_zulu || ':' || s.schedule_depart_minute_zulu as departTime , s.destination as destLoc, s.DEPARTURE_GATE   as deptGate,
                    to_char(PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s.schedule_date,s.schedule_depart_hour_zulu,s.schedule_depart_minute_zulu),'DD-MON-YYYY HH24:MI') as depDate
              FROM
                flight_schedule s,
                flight_schedule s1
              WHERE
                s1."ID" = flight_id AND              
                (
                  (
                    (
                      TRUNC( s.schedule_date ) = TRUNC(s1.schedule_arrival_date_zulu )
                    AND s.schedule_depart_hour_zulu   = s1.schedule_arrival_hour_zulu
                    AND s.schedule_depart_minute_zulu > s1.schedule_arrival_minute_zulu --d=d and h=h ad m > m
                    )
                  OR
                    (
                      TRUNC(s.schedule_date ) = TRUNC( s1.schedule_arrival_date_zulu)
                    AND s.schedule_depart_hour_zulu > s1.schedule_arrival_hour_zulu -- d=d and  h > h
                    )
                  )
                OR
                  (
                    TRUNC( s.schedule_date) > TRUNC( s1.schedule_arrival_date_zulu )
                  ) -- d > d
                )
              AND s.origin = s1.destination              
              AND s.ac     = s1.AC
              ORDER BY
                s.schedule_date ,
                s.schedule_depart_hour_zulu ,
                s.schedule_depart_minute_zulu ASC
                )
                
    WHERE rownum = 1;
  EXCEPTION WHEN OTHERS THEN
    NULL;
  END;
    if s_type = 'GATE' then
      RETURN gate;
    elsif s_type = 'TIME' then
      return time_flight;
    elsif s_type = 'LOCATION'  then
      return  destination;
    elsif s_type = 'DATE' then
      return next_date;
    else    
      return next_flight;
    end if;
  END GET_NEXT_FLIGHT;
  
  FUNCTION GET_PLAIN_TEXT(RTF_TEXT VARCHAR2) RETURN VARCHAR2
   IS
    C_PLAIN_ITEM_TEXT clob;
   BEGIN
    if INSTR(RTF_TEXT,'{\rtf') > 0 then
            C_PLAIN_ITEM_TEXT := NULL;
            CTX_DDL.CREATE_PREFERENCE('test_inso_filter', 'INSO_FILTER');
            CTX_DDL.CREATE_POLICY( 'test_policy', 'test_inso_filter' );                        
            CTX_DOC.POLICY_FILTER( 'test_policy', RTF_TEXT, C_PLAIN_ITEM_TEXT, TRUE );             
            CTX_DDL.DROP_PREFERENCE('test_inso_filter');
            CTX_DDL.DROP_POLICY('test_policy');
       return C_PLAIN_ITEM_TEXT;     
    else
      return RTF_TEXT;
    end if;   
    
   END GET_PLAIN_TEXT;

FUNCTION GET_ROW_LETTERS(s_ac VARCHAR2)  return VARCHAR2
IS
    seatConfig VARCHAR2(50);
    seatConfigEnd VARCHAR2(50);
    letter VARCHAR2(10);
    lastLetter NUMBER;
    position NUMBER;
    width NUMBER;

BEGIN
position := 1;
lastLetter := 65;

SELECT row_length
INTO width
FROM ac_type_configuration,ac_master
WHERE ac_master.ac = s_ac and ac_master.ac_type = ac_type_configuration.ac_type
 and ac_type_configuration.ac_series = ac_master.ac_series
AND rownum = 1;

FOR position IN 1..width
LOOP

SELECT DECODE(instr(listagg(  config,',') within group (order by config),'A'),0,' ',null,' ','A')
INTO letter
FROM 
(
SELECT distinct  SUBSTR(config,position,1) as config
FROM
  ac_type_configuration, ac_master
WHERE
  ac_master.ac = s_ac and ac_master.ac_type = ac_type_configuration.ac_type
 and ac_type_configuration.ac_series = ac_master.ac_series
);
seatConfig := seatConfig || letter;

END LOOP;

for position in 1..width
loop
  if substr(seatConfig,position,1) = 'A' then
    seatConfigEnd := seatConfigEnd || CHR(lastLetter);
    lastLetter := lastLetter + 1;
  else
    seatConfigEnd := seatConfigEnd || substr(seatConfig,position,1);
  end if;
end loop;

return seatConfigEnd;

      
END GET_ROW_LETTERS;


  FUNCTION GET_NEXT_FLIGHT_EX(
    s_previous_destination VARCHAR2 ,
    s_ac                   VARCHAR2 ,
    previous_arrival_date  DATE)
  RETURN DATE
IS
next_departure date;


BEGIN
  SELECT PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s1.schedule_date,s1.schedule_depart_hour_zulu,s1.schedule_depart_minute_zulu)
  into next_departure
  FROM flight_schedule s1
  WHERE  s1.ac   =  s_ac
  AND PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s1.schedule_date,s1.schedule_depart_hour_zulu,s1.schedule_depart_minute_zulu) =
    (SELECT MIN( PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s.schedule_date,s.schedule_depart_hour_zulu,s.schedule_depart_minute_zulu))
    FROM flight_schedule s
    WHERE     s.ac   = s_ac
    AND PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s.schedule_date,s.schedule_depart_hour_zulu,s.schedule_depart_minute_zulu) > previous_arrival_date
    ) ;
    
    return next_departure ;
exception when others then
return null;  
    
END GET_NEXT_FLIGHT_EX; 


function get_flights_range(s_location varchar2 , fromDate DATE , toDate DATE ) return VARCHAR2
is

s_id varchar2(32000 char) ; 

begin

s_id := ''; 

for x in (
    select S1.ID   
    from flight_schedule s1
    where s1.destination = s_location and
    (
    --everything landing between the range
    (
      PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s1.schedule_arrival_date_zulu ,s1.schedule_arrival_hour_zulu,s1.schedule_arrival_minute_zulu) between fromDate and toDate
    )
    --or everything that landed before range and next fligth is within or after the range
    or
    (
      PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s1.schedule_arrival_date_zulu ,s1.schedule_arrival_hour_zulu,s1.schedule_arrival_minute_zulu) < fromDate
      and  pkg_prod_control.get_next_flight_ex(s1.destination , s1.ac , PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s1.schedule_arrival_date_zulu ,s1.schedule_arrival_hour_zulu,s1.schedule_arrival_minute_zulu) ) > fromDate
    )
    
    --or everything that landed  and has not more fligths 
    or
    (
    PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s1.schedule_arrival_date_zulu ,s1.schedule_arrival_hour_zulu,s1.schedule_arrival_minute_zulu) < fromDate
    and  pkg_prod_control.get_next_flight_ex(s1.destination , s1.ac , PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s1.schedule_arrival_date_zulu ,s1.schedule_arrival_hour_zulu,s1.schedule_arrival_minute_zulu) ) is null 
    )
    
    )
    ) loop

    s_id := s_id || x.id || ',' ;
    
    end loop; 
    
    if LENGTH(s_id) > 0 then
      
      return substr(s_id , 0 , LENGTH(s_id) - 1 );
    
    end if ; 
    
    return '';
    

end get_flights_range ;


PROCEDURE clean_notification_queue
AS

older_than_number number;

begin

begin

 SELECT "CONFIG_NUMBER"
 into older_than_number
 FROM "SYSTEM_TRAN_CONFIG" 
 WHERE "SYSTEM_TRANSACTION" =  'CONFIGURATION'
 AND  "SYSTEM_CODE" = 'CLEANIOS';

exception when others then 
    older_than_number := 3; 
end ; 


 DELETE FROM ios_notification_queue 
 WHERE trunc(create_date) < trunc(sysdate) - older_than_number;
 COMMIT;

end clean_notification_queue;


PROCEDURE ASSIGN_TASK_CARD_INSP( s_employee TASK_CARD_EMPLOYEE_ASSIGNED.EMPLOYEE%TYPE, l_wo WO_TASK_CARD.WO%TYPE, s_task_card WO_TASK_CARD.TASK_CARD%TYPE ,
                              s_ac TASK_CARD_EMPLOYEE_ASSIGNED.AC%TYPE, s_pn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN%TYPE, s_sn TASK_CARD_EMPLOYEE_ASSIGNED.TASK_CARD_PN_SN%TYPE,
                              s_user VARCHAR2 )     
   AS
    s_result VARCHAR2(10);
    l_count NUMBER;
    s_skill LOCATION_SITE_ASSIGNED.SKILL%TYPE;
   BEGIN
      l_count := 0;
      SELECT COUNT(*)
      INTO l_count
      FROM "TASK_CARD_EMPLOYEE_ASSIGNED"
      WHERE ( "TASK_CARD_EMPLOYEE_ASSIGNED"."WO" = l_wo ) AND  
            ( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD" = s_task_card ) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."AC"),' ') = NVL(TRIM(s_ac ),' ')) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN"),' ') = NVL(TRIM(s_pn ),' ')) AND  
            (NVL(TRIM( "TASK_CARD_EMPLOYEE_ASSIGNED"."TASK_CARD_PN_SN"),' ') = NVL(TRIM(s_sn ),' ')) AND
            "TASK_CARD_EMPLOYEE_ASSIGNED"."EMPLOYEE" = s_employee;
      IF l_COUNT = 0 THEN
      
        INSERT INTO
          "TASK_CARD_EMPLOYEE_ASSIGNED"
          ( 
          "WO", 
          "TASK_CARD",
          "AC",
          "TASK_CARD_PN",
          "TASK_CARD_PN_SN",
          "EMPLOYEE",
          "CREATED_BY",
          "CREATED_DATE",
          "MODIFIED_BY",
          "MODIFIED_DATE"	,
          "INSPECTION_FLAG"
          )
        VALUES
          (
          l_wo,
          s_task_card,
          s_ac,
          s_pn,
          s_sn,
          s_employee,
          s_user,
          SYSDATE,
          s_user,
          SYSDATE,
          'Y'
          );
        END IF;
      l_count := 0;
      SELECT COUNT(*)
      INTO l_count
      FROM "LOCATION_SITE_ASSIGNED"
      WHERE ( "LOCATION_SITE_ASSIGNED"."WO" = l_wo ) AND  
            ( "LOCATION_SITE_ASSIGNED"."TASK_CARD" = s_task_card ) AND  
            (NVL(TRIM( "LOCATION_SITE_ASSIGNED"."AC"),' ') = NVL(TRIM(s_ac ),' ')) AND  
            ( NVL(TRIM("LOCATION_SITE_ASSIGNED"."TASK_CARD_PN"), ' ') = NVL(TRIM(s_pn ),' ')) AND  
            ( NVL(TRIM("LOCATION_SITE_ASSIGNED"."TASK_CARD_PN_SN"), ' ') = NVL(TRIM(s_sn ),' ')) AND
            ( "LOCATION_SITE_ASSIGNED"."EMPLOYEE" = s_employee );
      if l_count = 0 then
        BEGIN
          SELECT WO_TASK_CARD_ITEM.SKILL
          INTO s_skill
          FROM WO_TASK_CARD_ITEM
          WHERE WO_TASK_CARD_ITEM.WO = l_wo AND
                WO_TASK_CARD_ITEM.TASK_CARD = s_task_card AND
                WO_TASK_CARD_ITEM.TASK_CARD_PN = s_pn AND
                WO_TASK_CARD_ITEM.TASK_CARD_PN_SN = s_sn AND
                WO_TASK_CARD_ITEM.MAIN_SKILL = 'YES' AND
                rownum = 1;
        EXCEPTION WHEN OTHERS THEN
          s_skill := '          ';
        END;
        BEGIN
        INSERT INTO 
				"LOCATION_SITE_ASSIGNED" 
				(
				"WO",
				"TASK_CARD",
				"AC",
				"TASK_CARD_PN",
				"TASK_CARD_PN_SN",
				"EMPLOYEE",
				"SKILL",
				"MANHOURS", 
				"NOTES", 
				"CREATED_BY", 
				"CREATED_DATE", 
				"MODIFIED_BY", 
				"MODIFIED_DATE" )
			VALUES 
				(
				l_wo,
				s_task_card,
				s_ac,
				s_pn,
				s_sn,
				s_employee,
				s_skill,
				0,
				Null,
				s_user,
        SYSDATE,
        s_user,
        SYSDATE);
        EXCEPTION WHEN OTHERS 
        THEN 
          NULL;
        END;
      end if;
      COMMIT;
   END ASSIGN_TASK_CARD_INSP;
   
   
   
PROCEDURE UNASSIGN_FLIGHT AS --log 256601

t_flight VARCHAR2(10);
t_employee VARCHAR2(10);

cursor tc_cursor is  Select DISTINCT s.flight, a.employee
                       from flight_assignments a, flight_schedule s 
                       where a.flight = s.flight 
                       and GET_NEXT_FLIGHT_EX(s.destination, s.ac, 
                       PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(s.SCHEDULE_ARRIVAL_DATE_ZULU, s.SCHEDULE_ARRIVAL_HOUR_ZULU, s.SCHEDULE_ARRIVAL_MINUTE_ZULU)) 
                       < "PKG_APPLICATION_FUNCTION"."CURRENTDATETIME";      

BEGIN

   OPEN tc_cursor;
      
   LOOP 
   FETCH tc_cursor into t_flight ,t_employee;
   EXIT WHEN tc_cursor%notfound;
  
       --DBMS_OUTPUT.put_line('After the scheduled flight '||t_flight ||' finished, the employee '||t_employee||' was unassignment.');   
          
    delete from flight_assignments where flight = t_flight and employee = t_employee;
    commit;
    END LOOP;
   
   CLOSE tc_cursor;
  
END UNASSIGN_FLIGHT;
   
    
procedure getDefectDueAt(
    v_defect_type in "PLANNING"."DEFECT_TYPE"%TYPE,
    v_defect in "PLANNING"."DEFECT"%TYPE,
    l_defect_item in "PLANNING"."DEFECT_ITEM"%TYPE,
    dt_forcasted_due_date out nocopy date,
    d_due_at_ac_hours out nocopy number,
    d_due_at_ac_minutes out nocopy number,
    d_due_at_ac_cycles out nocopy number,   
    d_remaining_hours out nocopy number,
    d_remaining_minutes out nocopy number,
    d_remaining_cycles out nocopy number,  
    d_remaining_days out nocopy number   
    )
  AS
     v_transaction "PLANNING"."TRANSACTION"%TYPE;
     dt_today date;   
     d_remain_days number;
     v_ac "AC_MASTER"."AC"%TYPE;
     s_LivePlan varchar2(10);
  BEGIN
    -- Jing Huang 219679
    s_LivePlan := pkg_application_function.config_flag('LivePlan');
    if nvl(s_LivePlan, ' ') = 'Y' then
      if trim(v_defect_type) is null or trim(v_defect) is null or l_defect_item = 0 then
        return;
      end if;
      
      begin
        SELECT P."DUE_AT_AC_HOURS", P."DUE_AT_AC_MINUTES", P."DUE_AC_CYCLES", P."DUE_DATE", 
        P.REMAIN_HOURS , P.REMAIN_MINUTES ,P.REMAIN_CYCLES , P.REMAIN_DAYS
          INTO d_due_at_ac_hours, d_due_at_ac_minutes, d_due_at_ac_cycles,  dt_forcasted_due_date, 
          d_remaining_hours , d_remaining_minutes, d_remaining_cycles ,  d_remaining_days  
          FROM "PLANNING" P
         WHERE P."TRANSACTION" = 'LivePlan'
           AND P."DEFECT_TYPE" = v_defect_type
           AND P."DEFECT" = v_defect
           AND P."DEFECT_ITEM" = l_defect_item
           AND P."RECORD_TYPE" = 'Defect'
           AND ROWNUM <= 1;

        if d_due_at_ac_minutes > 0 then
           d_due_at_ac_hours := floor(d_due_at_ac_hours + d_due_at_ac_minutes/60);
        end if;
        RETURN;
      exception
        when no_data_found then
          NULL;
      end;
    end if;
    -- 219679
    
    dt_today := "PKG_APPLICATION_FUNCTION"."CURRENTDATETIME";
    begin
      v_transaction := to_char(PKG_APPLICATION_FUNCTION.config_number('PLNTRNNO'));
    exception
              when others then
                v_transaction := 'IF_DR_' || to_char(dt_today,'RRMMDDHH24MISSSSS');
    end;

    begin
    SELECT D."AC"
      INTO v_ac
      FROM DEFECT_REPORT D
      WHERE D.DEFECT_TYPE = v_defect_type
        AND D.DEFECT = v_defect
        AND D.DEFECT_ITEM = l_defect_item ;
    exception
      when no_data_found then
        v_ac := null;
    end;

    INSERT INTO "PLANNING_PARAMETER"
             ( "V_TRANSACTION",
               "DT_TODAY",
               "FROM_AC",
               "TO_AC",
               "DEFECT_SEL", "EC_SEL", "PN_EC_SEL", "PN_CONTROL_SEL", "SPARE_FORECAST",
               "DEFECT_TYPE",
               "DEFECT",
               "DEFECT_ITEM")
      VALUES ( v_transaction,
               dt_today,
              v_ac,
              v_ac,
               'Y','N','N','N','N',
              v_defect_type,
              v_defect,
              l_defect_item)  ;

    PKG_PLANNING_ASYNC.LOAD_PLANNING_without_Jobs(v_transaction);

    begin
      SELECT P."DUE_AT_AC_HOURS", P."DUE_AT_AC_MINUTES", P."DUE_AC_CYCLES", P."DUE_DATE", 
        P.REMAIN_HOURS , P.REMAIN_MINUTES ,P.REMAIN_CYCLES , P.REMAIN_DAYS
          INTO d_due_at_ac_hours, d_due_at_ac_minutes, d_due_at_ac_cycles,  dt_forcasted_due_date, 
          d_remaining_hours , d_remaining_minutes, d_remaining_cycles ,  d_remaining_days  
      FROM "PLANNING" P
      WHERE P."TRANSACTION" = v_transaction ;

      if d_due_at_ac_minutes > 0 then
         d_due_at_ac_hours := floor(d_due_at_ac_hours + d_due_at_ac_minutes/60);
      end if;
    exception
      when no_data_found then
        return;
    end;
  EXCEPTION
    WHEN OTHERS THEN
      RAISE_APPLICATION_ERROR(-20111, 'Exception in getDefectDueAt for defect ' || v_defect_type || ' ' || v_defect || ' ' || to_char(l_defect_item) || sqlerrm || Chr(10) || 'Backtrace...' || Chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(), TRUE);
  END getDefectDueAt;
  
  
  PROCEDURE AUTO_ASSIGN_EMPLOYEES(loc VARCHAR2, empHours NUMBER, wDate DATE)
AS
    l_wo WO_TASK_CARD.WO%TYPE;
    s_task_card WO_TASK_CARD.TASK_CARD%TYPE;
    s_ac WO_TASK_CARD.AC%TYPE;
    s_pn WO_TASK_CARD.PN%TYPE;
    s_pn_sn WO_TASK_CARD.PN_SN%TYPE;
    s_skill WO_TASK_CARD.SKILL%TYPE;    
    skillCount NUMBER;
    jump boolean;
BEGIN    
    for t in ( SELECT DISTINCT WTC.task_card,  
                              (SELECT LISTAGG( WTI.SKILL,',') WITHIN GROUP (ORDER BY WTI.SKILL) FROM WO_TASK_CARD_ITEM WTI   
                                  WHERE WTC.WO = WTI.WO AND   
                                        WTC.TASK_CARD = WTI.TASK_CARD AND   
                                        WTC.AC = WTI.AC AND   
                                        WTC.PN = WTI.TASK_CARD_PN AND   
                                        WTC.PN_SN = WTI.TASK_CARD_PN_SN ) AS SKILL,  
                                W.SITE,   
                                DECODE(WTC.AC,'          ',W.AC,WTC.AC) as AC,   
                                WTC.PN,   
                                WTC.PN_SN,   
                                WTC.WO,           
                                (SELECT SUM(WTI.MAN_HOURS) FROM WO_TASK_CARD_ITEM WTI   
                                  WHERE WTC.WO = WTI.WO AND   
                                        WTC.TASK_CARD = WTI.TASK_CARD AND   
                                        WTC.AC = WTI.AC AND   
                                        WTC.PN = WTI.TASK_CARD_PN AND   
                                        WTC.PN_SN = WTI.TASK_CARD_PN_SN ) AS MAN_HOURS,         
                                WTC.STATUS
                                FROM WO_TASK_CARD WTC, WO W , PN_INVENTORY_DETAIL P
                                WHERE WTC.WO = W.WO AND  W.STATUS NOT IN ('CLOSED','COMPLETED','POSTCMPLT') AND   
                                        W.LOCATION = loc AND                  
                                        W.MODULE = 'PRODUCTION' AND   
                                        WTC.STATUS NOT IN ('CLOSED','CANCEL','DEFER') AND   
                                        P.INSTALLED_AC(+) = WTC.AC AND   
                                        P.PN(+) = WTC.PN AND   
                                        P.SN(+) = WTC.PN_SN AND   
                                        ((SELECT COUNT(*) FROM TASK_CARD_EMPLOYEE_ASSIGNED TCEA WHERE TCEA.WO = WTC.WO AND TCEA.TASK_CARD = WTC.TASK_CARD AND ( ( TCEA.AC = WTC.AC AND TCEA.TASK_CARD_PN = WTC.PN AND TCEA.TASK_CARD_PN_SN = WTC.PN_SN)   
                                        OR ( TCEA.TASK_CARD_PN = WTC.PN  AND TCEA.TASK_CARD_PN_SN = WTC.PN_SN AND TCEA.AC = '          ')  OR ( TCEA.AC  = WTC.AC  AND TRIM(TCEA.TASK_CARD_PN) IS NULL ))   ) = 0 ) AND	  
                                        (wDate) BETWEEN PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(WTC.SCHEDULE_START_DATE,WTC.SCHEDULE_START_HOUR,WTC.SCHEDULE_START_MINUTE) AND PKG_APPLICATION_FUNCTION.GETCOMBINEDDATE(WTC.SCHEDULE_END_DATE,WTC.SCHEDULE_END_HOUR,WTC.SCHEDULE_END_MINUTE) )
            loop            
               for emp in (SELECT DISTINCT  LSC.EMPLOYEE, 
                            NVL((SELECT SUM(WTCI.MAN_HOURS)
                             FROM WO_TASK_CARD_ITEM WTCI,TASK_CARD_EMPLOYEE_ASSIGNED TCEA,WO_TASK_CARD WTC
                             WHERE WTCI.WO = TCEA.WO AND WTCI.TASK_CARD = TCEA.TASK_CARD AND WTCI.AC = TCEA.AC 
                                    AND WTCI.TASK_CARD_PN =  TCEA.TASK_CARD_PN AND WTCI.TASK_CARD_PN_SN = TCEA.TASK_CARD_PN_SN AND TCEA.EMPLOYEE = LSC.EMPLOYEE
                                    AND WTCI.WO = WTC.WO AND WTCI.TASK_CARD = WTC.TASK_CARD AND WTCI.AC = WTC.AC 
                                    AND WTCI.TASK_CARD_PN =  WTC.PN AND WTCI.TASK_CARD_PN_SN = WTC.PN_SN                                   
                                    AND TRUNC(wDate) between TRUNC(WTC.SCHEDULE_START_DATE) AND WTC.SCHEDULE_END_DATE),0) as mh,
                            LISTAGG(SM.SKILL, ',') WITHIN GROUP (ORDER BY SM.SKILL) as skills
                            FROM LOCATION_SITE_CAPACITY LSC,EMPLOYEE_SKILL SM 
                            WHERE LSC.EMPLOYEE = SM.EMPLOYEE AND TRUNC(LSC.WORK_DATE) = TRUNC(wDate) AND LSC.LOCATION = loc GROUP BY LSC.EMPLOYEE)
               loop
                    -- validate if employee is not assigned more than what he can work on.
                    if emp.mh < empHours  then
                        -- validate if adding this card will no go over what he can work
                        if emp.mh + t.man_hours < empHours then
                            -- validate skill
                            for skl in (WITH DATA AS
                                          ( SELECT t.SKILL str FROM dual
                                          )
                                        SELECT DISTINCT trim(regexp_substr(str, '[^,]+', 1, LEVEL)) str
                                        FROM DATA
                                        CONNECT BY instr(str, ',', 1, LEVEL - 1) > 0)
                            loop
                                SELECT COUNT(*) INTO skillCount
                                FROM DUAL
                                WHERE skl.str IN (WITH DATA AS
                                          ( SELECT emp.skills str FROM dual
                                          )
                                        SELECT DISTINCT trim(regexp_substr(str, '[^,]+', 1, LEVEL)) str
                                        FROM DATA
                                        CONNECT BY instr(str, ',', 1, LEVEL - 1) > 0);
                                
                                if skillCount > 0 then 
                                     -- assign the card to the employee
                                    ASSIGN_TASK_CARD(emp.EMPLOYEE, t.WO, t.TASK_CARD,t.AC, t.PN, t.PN_SN,'AUTOASSIGN');
                                    jump := true;
                                    EXIT;
                                end if;
                            
                            end loop;
                            
                            
                           
                        end if;                    
                    end if;
                    if jump then
                        jump := false;
                        EXIT;
                    end if;
               end loop;
               
            end loop;

        
END AUTO_ASSIGN_EMPLOYEES; 

FUNCTION GET_PLANNING_REMAINING( s_defect_type VARCHAR2, s_defect VARCHAR2, l_defect_item NUMBER , unit VARCHAR2) return NUMBER
AS
 l_remain_hour NUMBER;
  l_remain_minutes NUMBER;
  l_remain_days NUMBER;
  l_remain_cycles NUMBER;
BEGIN
  BEGIN 
  SELECT REMAIN_HOURS, REMAIN_MINUTES, REMAIN_DAYS, REMAIN_CYCLES 
  INTO l_remain_hour, l_remain_minutes, l_remain_days, l_remain_cycles
  FROM (
    SELECT REMAIN_HOURS, REMAIN_MINUTES, REMAIN_DAYS, REMAIN_CYCLES
    FROM PLANNING ACPD  
    WHERE   ACPD.DEFECT_TYPE  = s_defect_type AND ACPD.DEFECT =s_defect AND ACPD.DEFECT_ITEM = l_defect_item
    ORDER BY  AS_OF_DATE DESC )
  WHERE rownum = 1;  
  EXCEPTION WHEN OTHERS THEN 
     l_remain_hour := 0;
     l_remain_minutes := 0;
     l_remain_days := 0;
     l_remain_cycles := 0; 
  END;
  
  if unit = 'H' then 
    return l_remain_hour;
  elsif unit = 'M' then
    return l_remain_minutes;
  elsif unit = 'D' then
    return l_remain_days;
  else
    return l_remain_cycles;
  end if; 
END GET_PLANNING_REMAINING;

END PKG_PROD_CONTROL;


/ 

  CREATE OR REPLACE PACKAGE "PKG_IFACE_INVENTORY_SERVICE" As 

  Type Rt_Picklist_Reservation
  Is Record (Wo Number,
             Ac Varchar2(100),
             Task_Card Varchar2(100),
             Task_Card_Pn WO_TASK_CARD.PN%TYPE,
             Task_Card_Sn WO_TASK_CARD.PN_SN%TYPE,
             Company_Multi Varchar2(100),
             User_Id Varchar2(100),
             "Location" Varchar2(100),
             Delivery_Location Varchar2(100),
             Site Varchar2(100),
             Shortage_Print_Only Varchar2(100),
             Priority Varchar2(100),
             "Type" Varchar2(100),
             Require_Date Date,
             "Hour" Number,
             "Minute" Number , 
             defect "DEFECT_REPORT"."DEFECT"%type , 
             defectType "DEFECT_REPORT"."DEFECT_TYPE"%type , 
             defectItem "DEFECT_REPORT"."DEFECT_ITEM"%type 
             );
  
  Type Rt_Inventory_Query_Element
  Is Record ( "Location" Varchar2(100), 
              Bin Varchar2(100),
              Sn Varchar2(100),
              Batch Number,
              Owner Varchar2(100),
              Company Varchar2(100),
              Vendor_Lot Varchar2(100),
              Pn Varchar2(100), 
              Pn_Main Varchar2(100),
              Shelf_Life_Expiration Date,
              Tool_Life_Expiration Date,
              Installed_Ac Varchar2(100),
              Installed_Position Varchar2(100),
              Loan_Category Varchar2(100),
              Goods_Rcvd_Batch Number,
              Chapter Number,
              Section Number,
              Paragraph Number,
              Inventory_Type Varchar2(100),
              Tag_No Number,
              Legacy_Batch Number,
              Tool_Checked_Out Varchar2(100),
              Pending varchar(100),
              Issued_To_User varchar2(100),
              Issued_To_Employee varchar2(100),
              Issued_To_Location varchar2(100),
              Issued_To_Date Date);
  
  type rt_picklist_qe
  is record ( s_status varchar2(100),
              s_location varchar2(100),
              s_picklist varchar2(100),
              s_created_by varchar2(100),
              s_pn varchar2(100),
              s_pn_category varchar2(100),
              dt_required_date date,
              n_wo number,
              s_task_Card varchar2(100),
              s_priority varchar2(100),
              dt_from_date date,
              dt_to_date date,
              s_ac varchar2(100) );
              
  type rt_requisition_qe
  IS record ( 
      s_AC varchar2(100),
      s_AC_SERIES varchar2(100),
      s_AC_TYPE varchar2(100),
      s_ASSIGN_TO varchar2(100),
      s_ASSIGN_TO_STATUS varchar2(100),
      s_AUTHORIZATION varchar2(100),
      s_AUTHORIZED_BY varchar2(100),
      dt_AUTHORIZED_FROM_DATE DATE,
      dt_AUTHORIZED_TO_DATE DATE,
      s_CATEGORY varchar2(100),
      n_CHAPTER NUMBER,
      s_CREATED_BY varchar2(100),
      s_DEFECT varchar2(100),
      n_DEFECT_ITEM NUMBER,
      s_DEFECT_TYPE varchar2(100),
      s_EO varchar2(100),
      s_INVENTORY_TYPE varchar2(100),
      s_IPC varchar2(100),
      n_PARAGRAPH NUMBER,
      s_PN varchar2(100),
      s_pn_group varchar2(100),
      s_PRIORITY varchar2(100),
      s_REQUESTER_LOCATION varchar2(100),
      dt_REQUIRE_FROM_DATE DATE,
      dt_REQUIRE_TO_DATE DATE,
      n_REQUISITION NUMBER,
      s_REQUISTION_TYPE varchar2(100),
      n_SECTION NUMBER,
      s_STATUS varchar2(100),
      s_sub_category varchar2(100),
      s_TASK_CARD varchar2(100),
      s_VENDOR varchar2(100),
      n_WO NUMBER
        
  )   ;       
  
  
  Function Parse_Picklist_Reservation(Input Xmltype, Trax_Message_Box In Out Nocopy Pkg_Type_Structures.T_Trax_Message_Box) Return Rt_Picklist_Reservation;
  
  Function Parse_Inventory_Query_Element(Xml_Query_Element Xmltype, Trax_Message_Box In Out Nocopy Pkg_Type_Structures.T_Trax_Message_Box) Return Rt_Inventory_Query_Element;
  
  Function Picklist_Reservation(Wo Number,
             S_Ac VARCHAR2,
             S_Task_Card VARCHAR2,
             Task_Card_Pn WO_TASK_CARD.PN%TYPE,
             Task_Card_Sn WO_TASK_CARD.PN_SN%TYPE,
             S_Company_Multi VARCHAR2,
             S_User_Id VARCHAR2,
             S_Location VARCHAR2,
             S_Site VARCHAR2,
             Shortage_Print_Only VARCHAR2,
             S_Priority VARCHAR2,
             Require_Date Date,
             L_Hour Number,
             L_Minute Number) Return VARCHAR2;
  
  Function Picklist_Reservation(Input Xmltype) Return Xmltype;
  
  
  
  Function Picklist_Reservation_Cancel(Input Xmltype) Return Xmltype;
  
  Function Picklist_Reservation_Cancel(Wo Number,
             S_Task_Card VARCHAR2,
             S_User_Id VARCHAR2) return VARCHAR2;
             
  Function Picklist_Cancel_By_Defect(defect VARCHAR2, defect_type VARCHAR2, defect_item Number) return VARCHAR2;
  
  Function Requisition_Cancelation(Input Xmltype) Return Xmltype;
  
  function get_picklist_array(input xmltype) return xmltype;
  
  function get_requisition_array(input xmltype) return xmltype;
  
  Function Get_Pn_Inventory_Detail_Array(Xml_Query_Element Xmltype) Return Xmltype;
  
  Procedure Proc_Get_Pn_Inv_Detail_Array(Xml_Output Out Xmltype, Xml_Stc_Query_Element Xmltype);
  
  Function Get_Pn_Inventory_Summary_Array(Xml_Query_Element Xmltype) Return Xmltype;
  
  Function get_Pn_Inv_Sum_Company_Array(Xml_Query_Element Xmltype) Return Xmltype;
  
  Function Get_Inventory_Tool_Array(Xml_Query_Element Xmltype) Return Xmltype;
  
  Function Get_Pn_Availability_Array(Xml_Query_Element Xmltype) Return Xmltype;
  
  Procedure Proc_Get_Pn_Availability_Array(Xml_Output Out Xmltype, Xml_Query_Element Xmltype);
  
  
  --- CALLED BY PROC_...
 
  FUNCTION GET_PN_INVENTORY_INSTALL(Xml_Query_Element Xmltype) RETURN XMLTYPE;

  FUNCTION GET_PN_INVENTORY_REMOVE(Xml_Query_Element Xmltype) RETURN XMLTYPE;
  
  function GET_FOR_INVENTORY_INSTALL(XML_QUERY_ELEMENT xmltype) return xmltype;
 
  function GET_PN_MASTER_EFFECTIVITY_DD(XML_QUERY_ELEMENT xmltype) return xmltype;
  
  --- CALLED BY VS
  
  Procedure PROC_GET_PN_INVENTORY_INSTALL(Xml_Output Out Xmltype, Xml_Query_Element Xmltype);
  
  Procedure PROC_GET_PN_INVENTORY_REMOVE(Xml_Output Out Xmltype, Xml_Query_Element Xmltype);
  
  PROCEDURE PROC_GET_FOR_INVENTORY_REMOVE(Xml_Output Out Xmltype, Xml_Query_Element Xmltype);
  
  PROCEDURE PROC_GET_FOR_INVENTORY_INSTALL(Xml_Output Out Xmltype, Xml_Query_Element Xmltype);
  
  PROCEDURE Proc_Picklist_Reservation(Xml_Output Out Xmltype, Input Xmltype);
  
  procedure PROC_CHECK_PN_SPARE(S_OUTPUT OUT varchar2, S_PN varchar2, L_QTY in OUT NOCOPY number, S_LOCATION in OUT NOCOPY varchar2);
  
  PROCEDURE PROC_GET_PN_MASTER_EFFECTIVITY(XML_OUTPUT in out nocopy xmltype, XML_QUERY_ELEMENT xmltype);
  
  ----- Picklist Creation ----------------------------------
  
  function Set_Picklist_Header(input xmltype) return xmltype; 
  
  PROCEDURE PROC_Set_Picklist_Header(XML_OUTPUT IN out nocopy XMLTYPE, input XMLTYPE);
  
  function Set_Picklist_Detail(input xmltype) return xmltype; 
  
  procedure proc_set_picklist_detail(xml_output in out nocopy xmltype, input xmltype);
  
  function Delete_Picklist_Line(input xmltype) return xmltype; 
  
  procedure proc_delete_picklist_line(xml_output in out nocopy xmltype, input xmltype);
  
  function exit_picklist_detail(input xmltype) return xmltype; 
  
  procedure proc_exit_picklist_detail(XML_OUTPUT IN out nocopy XMLTYPE, input XMLTYPE); 
  
  FUNCTION GET_PICKLIST_PN_DD(Xml_Query_Element Xmltype) RETURN XMLTYPE;
  
  PROCEDURE PROC_GET_PICKLIST_PN_DD(XML_OUTPUT in out nocopy xmltype, XML_QUERY_ELEMENT xmltype);
End Pkg_Iface_Inventory_Service;

/

CREATE OR REPLACE PACKAGE BODY "PKG_IFACE_INVENTORY_SERVICE" as
  
  Function Parse_Picklist_Reservation(Input Xmltype, Trax_Message_Box In Out Nocopy Pkg_Type_Structures.T_Trax_Message_Box) Return Rt_Picklist_Reservation
  As
    Picklist_Reservation Rt_Picklist_Reservation;
  begin
    
    begin select extractvalue(input, '*/Wo') into Picklist_Reservation.Wo from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Wo'; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
    begin select extractvalue(input, '*/Ac') into Picklist_Reservation.Ac from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Ac'; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
    Begin Select Extractvalue(Input, '*/Task_Card') Into Picklist_Reservation.Task_Card From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid S_Task_Card'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    Begin Select Extractvalue(Input, '*/taskcardPn') Into Picklist_Reservation.Task_Card_Pn From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid TaskCardPn'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    Begin Select Extractvalue(Input, '*/taskcardSn') Into Picklist_Reservation.Task_Card_Sn From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid TaskCardSn'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    begin select pkg_interface.getyn(extractvalue(input, '*/Company_Multi')) into Picklist_Reservation.Company_Multi from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Company_Multi'; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
    Begin Select Extractvalue(Input, '*/User_Id') Into Picklist_Reservation.User_Id From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid User_Id'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    begin select extractvalue(input, '*/Location') into Picklist_Reservation."Location" from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Location'; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
    begin select extractvalue(input, '*/Delivery_Location') into Picklist_Reservation.Delivery_Location from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Delivery_Location'; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
    Begin Select Extractvalue(Input, '*/Site') Into Picklist_Reservation.Site From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Site'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    begin select pkg_interface.getyn(extractvalue(input, '*/Shortage_Print_Only')) into Picklist_Reservation.Shortage_Print_Only from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Shortage_Print_Only'; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
    Begin Select Extractvalue(Input, '*/Priority') Into Picklist_Reservation.Priority From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Priority'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    Begin Select Extractvalue(Input, '*/Type') Into Picklist_Reservation."Type" From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Type'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    Begin Select Pkg_Interface.Getdatefromxmlstring(Extractvalue(Input, '*/Require_Date')) Into Picklist_Reservation.Require_Date From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Require_Date'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    Begin Select Extractvalue(Input, '*/Hour') Into Picklist_Reservation."Hour" From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Hour'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    Begin Select Extractvalue(Input, '*/Minute') Into Picklist_Reservation."Minute" From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Minute'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    
    --defects for quick turn
    Begin Select Extractvalue(Input, '*/defect') Into Picklist_Reservation.defect From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Minute'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    Begin Select Extractvalue(Input, '*/defectType') Into Picklist_Reservation.defectType From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Minute'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
    Begin Select Extractvalue(Input, '*/defectItem') Into Picklist_Reservation.defectItem From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Minute'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;

    
    return Picklist_Reservation;
    
  end Parse_Picklist_Reservation;
  
  Function Parse_Inventory_Query_Element(xml_query_element Xmltype, Trax_Message_Box In Out Nocopy Pkg_Type_Structures.T_Trax_Message_Box) Return Rt_Inventory_Query_Element
  As
    Query_Element Rt_Inventory_Query_Element;
  begin
    
    begin select extractvalue(xml_query_element, '*/Location') into query_element."Location" from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Location', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Bin') into query_element.Bin from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Bin', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Sn') into query_element.Sn from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Sn', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Batch') into query_element.Batch from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Batch', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Owner') into query_element.Owner from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Owner', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Company') into query_element.Company from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Company', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Vendor_Lot') into query_element.Vendor_Lot from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Vendor_Lot', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Pn') into query_element.Pn from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Pn ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    Begin Select Extractvalue(Xml_Query_Element, '*/Pn_Main') Into Query_Element.Pn_Main From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Pn_Main', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Pkg_Interface.Getdatefromxmlstring(Extractvalue(Xml_Query_Element, '*/Shelf_Life_Expiration')) Into Query_Element.Shelf_Life_Expiration From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Shelf_Life_Expiration,', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    begin select pkg_interface.getdatefromxmlstring(extractvalue(xml_query_element, '*/Tool_Life_Expiration')) into query_element.Tool_Life_Expiration from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Tool_Life_Expiration,', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Installed_Ac') into query_element.Installed_Ac from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Installed_Ac', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Installed_Position') into query_element.Installed_Position from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Installed_Position', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Loan_Category') into query_element.Loan_Category from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Loan_Category', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Goods_Rcvd_Batch') into query_element.Goods_Rcvd_Batch from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Goods_Rcvd_Batch', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Chapter') into query_element.Chapter from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Chapter', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Section') into query_element.Section from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Section', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Paragraph') into query_element.Paragraph from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Paragraph', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Inventory_Type') into query_element.Inventory_Type from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Inventory_Type', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Tag_No') into query_element.Tag_No from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Tag_No', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    Begin Select Extractvalue(Xml_Query_Element, '*/Legacy_Batch') Into Query_Element.Legacy_Batch From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Legacy_Batch', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Pkg_Interface.Getyn(Extractvalue(Xml_Query_Element, '*/Tool_Checked_Out')) Into Query_Element.Tool_Checked_Out From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Tool_Checked_Out', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Extractvalue(Xml_Query_Element, '*/Pending') Into Query_Element.Pending From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Pending', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Extractvalue(Xml_Query_Element, '*/Issued_To_User') Into Query_Element.Issued_To_User From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Issued_To_User', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Extractvalue(Xml_Query_Element, '*/Issued_To_Employee') Into Query_Element.Issued_To_Employee From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Issued_To_Employee', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Extractvalue(Xml_Query_Element, '*/Issued_To_Location') Into Query_Element.Issued_To_Location From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Issued_To_Location', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Pkg_Interface.Getdatefromxmlstring(Extractvalue(Xml_Query_Element, '*/Issued_To_Date')) Into Query_Element.Issued_To_Date From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'Issued_To_Date', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
        
    return Query_Element;
    
  end Parse_Inventory_Query_Element;
  
  function picklist_reservation(Wo Number,
             S_Ac VARCHAR2,
             S_Task_Card VARCHAR2,
             Task_Card_Pn WO_TASK_CARD.PN%TYPE,
             Task_Card_Sn WO_TASK_CARD.PN_SN%TYPE,
             S_Company_Multi VARCHAR2,
             S_User_Id VARCHAR2,
             S_Location VARCHAR2,
             S_Site VARCHAR2,
             Shortage_Print_Only VARCHAR2,
             S_Priority VARCHAR2,
             Require_Date Date,
             L_Hour Number,
             L_Minute Number) return VARCHAR2
  as
    Xml_Tmb Xmltype;
   -- Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
    MS_LOCATION_SITE PKG_TYPE_STRUCTURES.ST_LOCATION_SITE;
    ms_location_site_req PKG_TYPE_STRUCTURES.ST_LOCATION_SITE; 
    l_num number;
    S_Company_Multi_V VARCHAR2(100);
    S_User_Id_V VARCHAR2(100);
    Shortage_Print_Only_V VARCHAR2(100);
  begin
    if S_Company_Multi = 'false' then
        S_Company_Multi_V := 'N';
    else
        S_Company_Multi_V := 'Y';
    end if;
    
    if Shortage_Print_Only = 'false' then
        Shortage_Print_Only_V := 'N';
    else
        Shortage_Print_Only_V := 'Y';
    end if;    
    S_User_Id_V := S_User_Id;
    
  --  If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
   -- and TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) is null then
      MS_LOCATION_SITE.S_LOCATION := S_Location;
      MS_LOCATION_SITE.S_DELIVERY_LOCATION := S_Location;
      Ms_Location_Site.S_Site := S_Site;
      MS_LOCATION_SITE.S_SHORTAGE_PRINT_ONLY := Shortage_Print_Only_V;
      Ms_Location_Site.S_Priority := S_Priority;
    --  MS_LOCATION_SITE.S_TYPE := S_Type;
      MS_LOCATION_SITE.DT_REQUIRE_DATE := Require_Date;
      MS_LOCATION_SITE.L_HOUR := L_Hour;
      MS_LOCATION_SITE.L_MINUTE := L_Minute;
      
      ms_location_site_req.S_LOCATION := S_Location;
      ms_location_site_req.S_DELIVERY_LOCATION := S_Location;
      ms_location_site_req.S_Site := S_Site;
      ms_location_site_req.S_SHORTAGE_PRINT_ONLY := Shortage_Print_Only_V;
      ms_location_site_req.S_Priority := S_Priority;
   --   ms_location_site_req.S_TYPE := S_Type;
      ms_location_site_req.DT_REQUIRE_DATE := Require_Date;
      ms_location_site_req.L_Hour := L_Hour;
      ms_location_site_req.L_MINUTE := L_Minute;
      begin
        Pkg_Iface_Picklist.Wf_Picklist_Reservation(Wo, S_Ac, Ms_Location_Site, Ms_Location_Site_Req, S_Task_Card,       
        Task_Card_Pn, Task_Card_Sn, Null, Null, Null, S_Company_Multi_V, S_User_Id_V, 2);
      end;
 --   end if;
    
    --xml_tmb := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
   -- if xml_tmb is not null then
     return 'OK';
    
  end picklist_reservation;
  
  
  
  function picklist_reservation(input xmltype) return xmltype
  as
    Xml_Tmb Xmltype;
    Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
    Picklist_Reservation Rt_Picklist_Reservation;
    MS_LOCATION_SITE PKG_TYPE_STRUCTURES.ST_LOCATION_SITE;
    ms_location_site_req PKG_TYPE_STRUCTURES.ST_LOCATION_SITE; 
    l_num number; 
  begin
        
 
    
    Picklist_Reservation := Parse_Picklist_Reservation(input, Trax_Message_Box);
    
    If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
    and TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) is null then
      
      MS_LOCATION_SITE.S_LOCATION := Picklist_Reservation."Location";
      MS_LOCATION_SITE.S_DELIVERY_LOCATION := Picklist_Reservation."Location";
      Ms_Location_Site.S_Site := Picklist_Reservation.Site;
      MS_LOCATION_SITE.S_SHORTAGE_PRINT_ONLY := Picklist_Reservation.SHORTAGE_PRINT_ONLY;
      Ms_Location_Site.S_Priority := Picklist_Reservation.Priority;
      MS_LOCATION_SITE.S_TYPE := Picklist_Reservation."Type";
      MS_LOCATION_SITE.DT_REQUIRE_DATE := Picklist_Reservation.Require_Date;
      MS_LOCATION_SITE.L_HOUR := Picklist_Reservation."Hour";
      MS_LOCATION_SITE.L_MINUTE := Picklist_Reservation."Minute";
      
      ms_location_site_req.S_LOCATION := Picklist_Reservation."Location";
      ms_location_site_req.S_DELIVERY_LOCATION := Picklist_Reservation."Location";
      ms_location_site_req.S_Site := Picklist_Reservation.Site;
      ms_location_site_req.S_SHORTAGE_PRINT_ONLY := Picklist_Reservation.SHORTAGE_PRINT_ONLY;
      ms_location_site_req.S_Priority := Picklist_Reservation.Priority;
      ms_location_site_req.S_TYPE := Picklist_Reservation."Type";
      ms_location_site_req.DT_REQUIRE_DATE := Picklist_Reservation.Require_Date;
      ms_location_site_req.L_Hour := Picklist_Reservation."Hour";
      ms_location_site_req.L_MINUTE := Picklist_Reservation."Minute";
      
      begin
        Pkg_Iface_Picklist.Wf_Picklist_Reservation(Picklist_Reservation.Wo, Picklist_Reservation.Ac, Ms_Location_Site, Ms_Location_Site_Req, Picklist_Reservation.Task_Card,       
        Picklist_Reservation.Task_Card_Pn,  Picklist_Reservation.Task_Card_Sn, 
        Picklist_Reservation.defect , Picklist_Reservation.defectType, Picklist_Reservation.defectItem ,       
        Picklist_Reservation.Company_Multi, Picklist_Reservation.User_Id, 2);
--      Exception
--      When Others Then
--        Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
      end;
    end if;
    
    xml_tmb := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
    return xml_tmb;
    
  end picklist_reservation;
  
  Function Picklist_Reservation_Cancel(Input xmltype) Return Xmltype
  As
    Xml_Tmb Xmltype;
    Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
    Picklist_Reservation Rt_Picklist_Reservation;
  begin
    
    Picklist_Reservation := Parse_Picklist_Reservation(input, Trax_Message_Box);
    
    If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
    and TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) is null then
      
      Begin
        Pkg_Iface_Picklist.WF_PICKLIST_RESERVATION_CANCEL(Picklist_Reservation.Wo, Picklist_Reservation.Task_Card, Picklist_Reservation.User_Id);
      Exception
      When Others Then
        Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
      end;
      
    end if;
    
    xml_tmb := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
    return xml_tmb;
    
  End Picklist_Reservation_Cancel;
  
  
  Function Picklist_Reservation_Cancel(Wo Number,
             S_Task_Card VARCHAR2,
             S_User_Id VARCHAR2) return VARCHAR2
  As
    Xml_Tmb Xmltype;
    Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
    V_Task_Card VARCHAR2(100);
    V_User_Id VARCHAR2(100);
  begin
    
    V_Task_Card := S_Task_Card;
    V_User_Id := S_User_Id;
   
    
    If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
    and TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) is null then
      
      Begin
        Pkg_Iface_Picklist.WF_PICKLIST_RESERVATION_CANCEL(Wo, V_Task_Card, V_User_Id);
      Exception
      When Others Then
        Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
      end;
      
    end if;
    
   -- xml_tmb := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
    return 'OK';
    
  End Picklist_Reservation_Cancel;
  
   Function Picklist_Cancel_By_Defect(defect VARCHAR2, defect_type VARCHAR2, defect_item Number) return VARCHAR2
  As
    Xml_Tmb Xmltype;
    Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
  begin
    
    
      if (pkg_application_function.config_flag('QTCANCLREQ') = 'Y') then
    
    
          If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
          and TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) is null then
            
            Begin
              Pkg_Iface_Picklist.PICKLIST_CANCEL_Defect(defect, defect_type, defect_item);
            Exception
            When Others Then
              Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
            end;
            
          end if;
    
   -- xml_tmb := pkg_interface.get_xml_trax_msg_box(trax_message_box);
      end if; 
    return 'OK';
    
  End Picklist_Cancel_By_Defect;
  
  function Requisition_Cancelation(Input xmltype) Return Xmltype
  As
    Xml_Tmb Xmltype;
    Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
    Picklist_Reservation Rt_Picklist_Reservation;
  begin
    
    Picklist_Reservation := Parse_Picklist_Reservation(input, Trax_Message_Box);
    
    If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
    and TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) is null then
      
      Begin
        Pkg_Iface_Picklist.WF_REQUISITION_CANCELATION(Picklist_Reservation.Wo, Picklist_Reservation.Task_Card);
      Exception
      When Others Then
        Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
      end;
      
    end if;
    
    xml_tmb := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
    return xml_tmb;
    
  End REQUISITION_CANCELATION;
  
  function get_picklist_array(input xmltype) return xmltype
  as
    output xmltype;
    qe rt_picklist_qe;
    trax_message_box pkg_type_Structures.t_trax_message_box;
    dw pkg_dw_picklist_sel_qry.tt_dw_picklist_sel_qry;
  begin
    
    begin select extractvalue(input, '*/Status') into qe.s_status from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Status', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Location') into qe.s_location from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Location', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Picklist') into qe.s_picklist from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Picklist', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Created_By') into qe.s_created_by from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Created_By', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Pn') into qe.s_pn from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Pn', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Pn_Category') into qe.s_pn_category from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Pn_Category', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select pkg_interface.getdatefromxmlstring(extractvalue(input, '*/Required_Date')) into qe.dt_required_date from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Required_Date', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Wo') into qe.n_wo from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Wo', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Task_Card') into qe.s_task_Card from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Task_Card', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Priority') into qe.s_priority from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Priority', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select pkg_interface.getdatefromxmlstring(extractvalue(input, '*/From_Date')) into qe.dt_from_date from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'From_Date', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select pkg_interface.getdatefromxmlstring(extractvalue(input, '*/To_Date')) into qe.dt_to_date from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'To_Date', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Ac') into qe.s_ac from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Ac', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Cast_Error(Trax_Message_Box);
    end if;
    
    dw := pkg_dw_picklist_sel_qry.retrieve(qe.s_status, qe.s_location, qe.s_picklist,
                                           qe.s_created_by, qe.s_pn, qe.s_pn_category,
                                           qe.dt_required_date, qe.n_wo, qe.s_task_Card,
                                           qe.s_priority, qe.dt_from_date, qe.dt_to_date,
                                           qe.s_ac);
    
    output := pkg_dw_picklist_sel_qry.get_xml(dw);
    
    if output is not null then
      
      select xmlelement("Picklist_Array", output)
      into output
      from dual;
      
    end if;
    
    return output;
    
  END get_picklist_array;
  
  
  FUNCTION get_requisition_array(input XMLTYPE) RETURN XMLTYPE
  AS
    output XMLTYPE;
    qe rt_requisition_qe;
    Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
    dw pkg_dw_requisition_qry.tt_dw_requisition_sel_qry;
  BEGIN
    
    begin select extractvalue(input, '*/Ac') into qe.s_AC from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AC', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Ac_Series') into qe.s_AC_SERIES from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AC_SERIES', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Ac_Type') into qe.s_AC_TYPE from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AC_TYPE', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Assign_To') into qe.s_ASSIGN_TO from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'ASSIGN_TO', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Assign_To_Status') into qe.s_ASSIGN_TO_STATUS from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'ASSIGN_TO_STATUS', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    Begin Select Extractvalue(Input, '*/Authorization') Into Qe.S_Authorization From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'AUTHORIZATION', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Extractvalue(Input, '*/Authorized_By') Into Qe.S_Authorized_By From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'AUTHORIZED_BY', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Pkg_Interface.Getdatefromxmlstring(Extractvalue(Input, '*/Authorized_From_Date')) Into Qe.Dt_Authorized_From_Date From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'AUTHORIZED_FROM_DATE', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    begin select pkg_interface.getdatefromxmlstring(extractvalue(input, '*/Authorized_To_Date')) into qe.dt_AUTHORIZED_TO_DATE from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AUTHORIZED_TO_DATE', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Category') into qe.s_CATEGORY from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'CATEGORY', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Chapter') into qe.n_CHAPTER from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'CHAPTER', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Created_By') into qe.s_CREATED_BY from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'CREATED_BY', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Defect') into qe.s_DEFECT from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'DEFECT', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Defect_Item') into qe.n_DEFECT_ITEM from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'DEFECT_ITEM', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Defect_Type') into qe.s_DEFECT_TYPE from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'DEFECT_TYPE', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Eo') into qe.s_EO from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'EO', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Inventory_Type') into qe.s_INVENTORY_TYPE from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'INVENTORY_TYPE', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Ipc') into qe.s_IPC from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'IPC', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Paragraph') into qe.n_PARAGRAPH from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'PARAGRAPH', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Pn') into qe.s_PN from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'PN', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Pn_Group') into qe.s_pn_group from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'pn_group', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Priority') into qe.s_PRIORITY from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'PRIORITY', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    Begin Select Extractvalue(Input, '*/Requester_Location') Into Qe.S_Requester_Location From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'REQUESTER_LOCATION', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Pkg_Interface.Getdatefromxmlstring(Extractvalue(Input, '*/Require_From_Date')) Into Qe.Dt_Require_From_Date From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'REQUIRE_FROM_DATE', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    begin select Pkg_Interface.Getdatefromxmlstring(extractvalue(input, '*/Require_To_Date')) into qe.dt_REQUIRE_TO_DATE from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'REQUIRE_TO_DATE', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Requisition') into qe.n_REQUISITION from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'REQUISITION', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Requistion_Type') into qe.s_REQUISTION_TYPE from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'REQUISTION_TYPE', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Section') into qe.n_SECTION from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'SECTION', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Status') into qe.s_STATUS from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'STATUS', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Sub_Category') into qe.s_sub_category from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'sub_category', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Task_Card') into qe.s_TASK_CARD from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'TASK_CARD', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Vendor') into qe.s_VENDOR from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'VENDOR', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(input, '*/Wo') into qe.n_WO from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'WO', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    
            
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
       Pkg_Interface.Raise_Cast_Error(Trax_Message_Box);
    end if;
        
        dw := pkg_dw_requisition_qry.retrieve(
          qe.s_AC,
          qe.s_AC_SERIES,
          qe.s_AC_TYPE,
          qe.s_ASSIGN_TO,
          qe.s_ASSIGN_TO_STATUS,
          qe.s_AUTHORIZATION,
          qe.s_AUTHORIZED_BY,
          qe.dt_AUTHORIZED_FROM_DATE,
          qe.dt_AUTHORIZED_TO_DATE,
          qe.s_CATEGORY,
          qe.n_CHAPTER,
          qe.s_CREATED_BY,
          qe.s_DEFECT,
          qe.n_DEFECT_ITEM,
          qe.s_DEFECT_TYPE,
          qe.s_EO,
          qe.s_INVENTORY_TYPE,
          qe.s_IPC,
          qe.n_PARAGRAPH,
          qe.s_PN,
          qe.s_pn_group,
          qe.s_PRIORITY,
          qe.s_REQUESTER_LOCATION,
          qe.dt_REQUIRE_FROM_DATE,
          qe.dt_REQUIRE_TO_DATE,
          qe.n_REQUISITION,
          qe.s_REQUISTION_TYPE,
          qe.n_SECTION,
          qe.s_STATUS,
          qe.s_sub_category,
          qe.s_TASK_CARD,
          qe.s_VENDOR,
          qe.n_WO
        );
       
        output := pkg_dw_requisition_qry.get_xml(dw);
       
        if output is not null then
          
          select xmlelement("Requisition_Array", output)
          into output
          from dual;
          
        end if;
        
    return output;
  
  
  END get_requisition_array;
  
  
  Function get_Pn_Inventory_Detail_Array(Xml_Query_Element Xmltype) Return Xmltype
  as
    output xmltype;
    dw Pkg_Dw_Inventory_Qry.tt_Dw_Inventory_Qry;
    Query_Element Rt_Inventory_Query_Element;
    TRAX_MESSAGE_BOX pkg_type_structures.t_TRAX_MESSAGE_BOX;
  Begin
    
    query_element := Parse_Inventory_Query_Element(xml_query_element, Trax_Message_Box);
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Cast_Error(Trax_Message_Box);
    end if;
    
    Begin
    
      Dw := Pkg_Dw_Inventory_Qry.Retrieve(Query_Element."Location",
                                          Query_Element.Bin,
                                          Query_Element.Sn,
                                          Query_Element.Batch,
                                          Query_Element.Owner,
                                          Query_Element.Company,
                                          Query_Element.Vendor_Lot,
                                          Query_Element.Pn,
                                          Query_Element.Pn_Main,
                                          Query_Element.Shelf_Life_Expiration,
                                          Query_Element.Tool_Life_Expiration,
                                          Query_Element.Installed_Ac,
                                          Query_Element.Loan_Category,
                                          Query_Element.Goods_Rcvd_Batch,
                                          Query_Element.Chapter,
                                          Query_Element.Section,
                                          Query_Element.Paragraph,
                                          Query_Element.Inventory_Type,
                                          Query_Element.Tag_No,
                                          Query_Element.Legacy_Batch,
                                          Query_Element.Pending);
      
      output := Pkg_Dw_Inventory_Qry.Get_Xml(Dw);
      
      Select Xmlelement("Pn_Inventory_Detail_Array",
                        output)
      Into output
      From Dual;
      
    Exception
    When Others Then
      Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
    End;
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Error(Trax_Message_Box);
    end if;
    
    return output;
    
  End get_Pn_Inventory_Detail_Array;
  
 
  Function get_Pn_Inventory_Summary_Array(Xml_Query_Element Xmltype) Return Xmltype
  as
    output xmltype;
    dw Pkg_Dw_Inventory_Summary_Qry.tt_Dw_Inventory_Summary_Qry;
    Query_Element Rt_Inventory_Query_Element;
    TRAX_MESSAGE_BOX pkg_type_structures.t_TRAX_MESSAGE_BOX;
  Begin
    
    query_element := Parse_Inventory_Query_Element(xml_query_element, Trax_Message_Box);
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Cast_Error(Trax_Message_Box);
    end if;
    
    Begin
    
      Dw := Pkg_Dw_Inventory_Summary_Qry.Retrieve(Query_Element.Pn,
                                                  Query_Element.Owner);
      
      output := Pkg_Dw_Inventory_Summary_Qry.Get_Xml(Dw);
      
      Select Xmlelement("Pn_Inventory_Summary_Array",
                        output)
      Into output
      From Dual;
      
    Exception
    When Others Then
      Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
    End;
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Error(Trax_Message_Box);
    end if;
    
    return output;
    
  End get_Pn_Inventory_Summary_Array;
  
  Function get_Pn_Inv_Sum_Company_Array(Xml_Query_Element Xmltype) Return Xmltype
  as
    output xmltype;
    Query_Element Rt_Inventory_Query_Element;
    Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
    W_Inventory_Qry Pkg_W_Inventory_Qry.T_W_Inventory_Qry;
    Gloval Pkg_Global_Variables.T_Global_Variables;
  Begin
    
    query_element := Parse_Inventory_Query_Element(xml_query_element, Trax_Message_Box);
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Cast_Error(Trax_Message_Box);
    end if;
    
    Begin
      
      pkg_W_Inventory_Qry.wf_summary_company(W_Inventory_Qry, gloval, query_element.pn);
      
      output := Pkg_Dw_Inv_Summary_Company_Qry.Get_Xml(W_Inventory_Qry.dw_inv_summary_company_qry);
      
      Select Xmlelement("Pn_Inventory_Summary_Array",
                        output)
      Into output
      From Dual;
      
    Exception
    When Others Then
      Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
    End;
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Error(Trax_Message_Box);
    end if;
    
    return output;
    
  End get_Pn_Inv_Sum_Company_Array;
  
  Function get_Inventory_Tool_Array(Xml_Query_Element Xmltype) Return Xmltype
  as
    output xmltype;
    dw pkg_dw_inventory_tools_locator.tt_dw_inventory_tools_locator;
    Query_Element Rt_Inventory_Query_Element;
    TRAX_MESSAGE_BOX pkg_type_structures.t_TRAX_MESSAGE_BOX;
  Begin
    
    query_element := Parse_Inventory_Query_Element(xml_query_element, Trax_Message_Box);
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Cast_Error(Trax_Message_Box);
    end if;
    
    Begin
    
      Dw := pkg_dw_inventory_tools_locator.Retrieve(Query_Element."Location",
                                                    Query_Element.Bin,
                                                    Query_Element.Sn,
                                                    Query_Element.Batch,
                                                    Query_Element.Owner,
                                                    Query_Element.Vendor_Lot,
                                                    Query_Element.Pn,
                                                    Query_Element.Shelf_Life_Expiration,
                                                    Query_Element.Tool_Life_Expiration,
                                                    Query_Element.Installed_Ac,
                                                    Query_Element.Loan_Category,
                                                    Query_Element.Goods_Rcvd_Batch,
                                                    Query_Element.Chapter,
                                                    Query_Element.Section,
                                                    Query_Element.Paragraph,
                                                    Query_Element.Tag_No,
                                                    Query_Element.Legacy_Batch,
                                                    Query_Element.Tool_Checked_Out,
                                                    Query_Element.Issued_To_User,
                                                    Query_Element.Issued_To_Employee,
                                                    Query_Element.Issued_To_Location,
                                                    Query_Element.Issued_To_Date);
      
      output := pkg_dw_inventory_tools_locator.Get_Xml(Dw);
      
      Select Xmlelement("Inventory_Tool_Array",
                        output)
      Into output
      From Dual;
      
    Exception
    When Others Then
      Pkg_Interface.Set_Error(Trax_Message_Box, Sqlerrm, Dbms_Utility.Format_Error_Backtrace());
    End;
    
    if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is not null then
      Pkg_Interface.Raise_Error(Trax_Message_Box);
    end if;
    
    return output;
    
  End get_Inventory_Tool_Array;
  
  Procedure Proc_Get_Pn_Inv_Detail_Array(Xml_Output Out Xmltype, Xml_Stc_Query_Element Xmltype)
  As
  Begin
    Xml_Output := Get_Pn_Inventory_Detail_Array(Xml_Stc_Query_Element);
  end Proc_Get_Pn_Inv_Detail_Array;
  
  Function Get_Pn_Availability_Array(Xml_Query_Element Xmltype) Return Xmltype
  As
    Xml_Output Xmltype;
    Ms_Pn Pkg_Type_Structures.St_Pn;
    Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
    Gloval Pkg_Global_Variables.T_Global_Variables;
    w_inv_summary_qry_sdi PKG_W_INV_SUMMARY_QRY_SDI.t_w_inv_summary_qry_sdi;
  Begin
    begin select extractvalue(xml_query_element, '*/Pn') into ms_pn.S_Pn from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Pn ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
  
    If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
    And Trim(Trax_Message_Box.S_Err_Msg) Is Null Then
      
      Pkg_W_Inv_Summary_Qry_Sdi.Ue_Open(w_inv_summary_qry_sdi, ms_pn, gloval, Trax_Message_Box);
      
      If Trim(Trax_Message_Box.S_Info_Hdr) Is Null
      And Trim(Trax_Message_Box.S_Info_Msg) Is Null Then
        Xml_Output := pkg_dw_inv_summary_order_qry.get_xml(w_inv_summary_qry_sdi.dw_eu);
        
        Select Xmlelement("Pn_Inventory_Summary_Array",
                        Xml_Output)
        Into Xml_Output
        From Dual;
      end if;
    End If;
    
    Return Xml_Output;
    
  End Get_Pn_Availability_Array;
  
  Procedure Proc_Get_Pn_Availability_Array(Xml_Output Out Xmltype, Xml_Query_Element Xmltype)
  As
  Begin
    Xml_Output := Get_Pn_Availability_Array(Xml_Query_Element);
    
  end Proc_Get_Pn_Availability_Array;
  
  
  
  --- CALLED BY PROC...
  FUNCTION GET_PN_INVENTORY_INSTALL(Xml_Query_Element Xmltype) RETURN XMLTYPE
  as
  output xmltype;
  DW PKG_DW_INVENTORY_QRY.Tt_Dw_Inv_PN_Qry ;
  Query_Element Rt_Inventory_Query_Element;
  TRAX_MESSAGE_BOX pkg_type_structures.t_TRAX_MESSAGE_BOX;
  PN_INTERCHANGEABLE varchar2(100);
  AC VARCHAR(100);
  
  BEGIN
 -- Xml_Query_Element:= '<Pn_Issued_Query_Element><Ac>N317JB</Ac><Pn_Interchangeable>APU</Pn_Interchangeable></Pn_Issued_Query_Element>';
    BEGIN select extractvalue(Xml_Query_Element, '*/Pn_Interchangeable') into PN_INTERCHANGEABLE from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'PN_INTERCHANGEABLE ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    
    BEGIN select extractvalue(Xml_Query_Element, '*/Ac') into AC from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AC ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
     
     if PN_INTERCHANGEABLE is null then PN_INTERCHANGEABLE :='%'; end if;
      
      Dw :=Pkg_Dw_Inventory_Qry.RETRIVE_PN_FOR_INSTALL(PN_INTERCHANGEABLE,AC);
      output := PKG_DW_INVENTORY_QRY.GET_XML_PN_INSTALL_REMOVE(Dw);
      
      Select Xmlelement("Pn_Issue_Install_Array",
                        output)
      Into output
      From Dual;
  
  RETURN output;
  END GET_PN_INVENTORY_INSTALL;
  
  FUNCTION GET_PN_INVENTORY_REMOVE(Xml_Query_Element Xmltype) RETURN XMLTYPE
  as
  output xmltype;
  DW PKG_DW_INVENTORY_QRY.Tt_Dw_Inv_PN_Qry ;
  Query_Element Rt_Inventory_Query_Element;
  TRAX_MESSAGE_BOX pkg_type_structures.t_TRAX_MESSAGE_BOX;
  PN_INTERCHANGEABLE varchar2(100);
  AC VARCHAR(100);
  
  BEGIN
 -- Xml_Query_Element:= '<Pn_Issued_Query_Element><Ac>N317JB</Ac><Pn_Interchangeable>APU</Pn_Interchangeable></Pn_Issued_Query_Element>';
    BEGIN select extractvalue(Xml_Query_Element, '*/Pn_Interchangeable') into PN_INTERCHANGEABLE from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'PN_INTERCHANGEABLE ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    
    BEGIN select extractvalue(Xml_Query_Element, '*/Ac') into AC from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AC ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
     
       if PN_INTERCHANGEABLE is null then PN_INTERCHANGEABLE :='%'; end if;
      Dw :=Pkg_Dw_Inventory_Qry.RETRIVE_PN_FOR_REMOVE(PN_INTERCHANGEABLE,AC);
      output := PKG_DW_INVENTORY_QRY.GET_XML_PN_INSTALL_REMOVE(Dw);
      
      Select Xmlelement("Pn_Issue_Remove_Array",
                        output)
      Into output
      From Dual;
  
  RETURN output;
  END GET_PN_INVENTORY_REMOVE;
  
 FUNCTION GET_FOR_INVENTORY_INSTALL(Xml_Query_Element Xmltype) RETURN XMLTYPE
    as
      output xmltype;
      DW PKG_DW_INVENTORY_QRY.Tt_Dw_for_Inventory_Qry ;
      Query_Element Rt_Inventory_Query_Element;
      TRAX_MESSAGE_BOX pkg_type_structures.t_TRAX_MESSAGE_BOX;
      s_PN varchar2(100);
      s_AC VARCHAR(100);
      s_SN VARCHAR(100);
      S_BATCH VARCHAR(100);
    
    BEGIN
       
      BEGIN select extractvalue(Xml_Query_Element, '*/Installed_Ac') into s_AC from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AC ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
      BEGIN select extractvalue(Xml_Query_Element, '*/Pn') into s_PN from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'PN  ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
      BEGIN select extractvalue(Xml_Query_Element, '*/Sn') into s_SN from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'SN ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
      BEGIN select extractvalue(Xml_Query_Element, '*/Batch') into S_BATCH from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Batch ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    
      if S_BATCH = '0' then
        S_BATCH:='';
      end if;
            
        Dw :=Pkg_Dw_Inventory_Qry.RETRIVE_INVENTORY_FOR_INSTALL(S_AC, S_PN, S_SN,S_BATCH);
        output := PKG_DW_INVENTORY_QRY.GET_XML_INV_FOR_REMOVE(Dw);
        
        Select Xmlelement("Inv_for_Install_Array",
                          output)
        Into output
        From Dual;
    
    RETURN output;
  end GET_FOR_INVENTORY_INSTALL;
  
  FUNCTION GET_FOR_INVENTORY_REMOVE(Xml_Query_Element Xmltype) RETURN XMLTYPE
    as
      output xmltype;
      DW PKG_DW_INVENTORY_QRY.Tt_Dw_for_Inventory_Qry ;
      Query_Element Rt_Inventory_Query_Element;
      TRAX_MESSAGE_BOX pkg_type_structures.t_TRAX_MESSAGE_BOX;
      s_PN varchar2(100);
      s_AC VARCHAR(100);
      s_SN VARCHAR(100);
      S_BATCH VARCHAR(100);
    
    BEGIN
      -- Xml_Query_Element:= '<Pn_Issued_Query_Element><Ac>N317JB</Ac><Pn_Interchangeable>APU</Pn_Interchangeable></Pn_Issued_Query_Element>';
       
      BEGIN select extractvalue(Xml_Query_Element, '*/Installed_Ac') into s_AC from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AC ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
      BEGIN select extractvalue(Xml_Query_Element, '*/Pn') into s_PN from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'PN  ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
      BEGIN select extractvalue(Xml_Query_Element, '*/Sn') into s_SN from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'SN ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
      BEGIN select extractvalue(Xml_Query_Element, '*/Batch') into S_BATCH from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'Batch ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    
      if S_BATCH = '0' then
        S_BATCH:='';
      end if;
            
        Dw :=Pkg_Dw_Inventory_Qry.RETRIVE_INVENTORY_FOR_REMOVE(S_AC, S_PN, S_SN,S_BATCH);
        output := PKG_DW_INVENTORY_QRY.GET_XML_INV_FOR_REMOVE(Dw);
        
        Select Xmlelement("Inv_for_remove_Array",
                          output)
        Into output
        From Dual;
    
    RETURN output;
  end GET_FOR_INVENTORY_REMOVE;
  
    --- CALLED BY VS
 
   Procedure PROC_GET_PN_INVENTORY_INSTALL(Xml_Output Out Xmltype, Xml_Query_Element Xmltype)
    As
    Begin
      Xml_Output := GET_PN_INVENTORY_INSTALL(Xml_Query_Element);
      
    end PROC_GET_PN_INVENTORY_INSTALL;
  
   Procedure PROC_GET_PN_INVENTORY_REMOVE(Xml_Output Out Xmltype, Xml_Query_Element Xmltype)
    As
    Begin
      Xml_Output := GET_PN_INVENTORY_REMOVE(Xml_Query_Element);
      
    end PROC_GET_PN_INVENTORY_REMOVE;
  
   Procedure PROC_GET_FOR_INVENTORY_REMOVE(Xml_Output Out Xmltype, Xml_Query_Element Xmltype)
  As
  Begin
    Xml_Output := GET_FOR_INVENTORY_REMOVE(Xml_Query_Element);
    
  end PROC_GET_FOR_INVENTORY_REMOVE;
  
  Procedure PROC_GET_FOR_INVENTORY_INSTALL(Xml_Output Out Xmltype, Xml_Query_Element Xmltype)
  As
  Begin
    Xml_Output := GET_FOR_INVENTORY_INSTALL(Xml_Query_Element);
    
  end PROC_GET_FOR_INVENTORY_INSTALL;
  
  PROCEDURE Proc_Picklist_Reservation(Xml_Output Out Xmltype, Input Xmltype)
  As
  begin
    Xml_Output := Picklist_Reservation(input);
    
  end Proc_Picklist_Reservation;
  
   procedure Proc_Check_Pn_Spare(s_output out varchar2, s_pn varchar2, l_qty in out nocopy number, s_location in out nocopy varchar2)
   as
   begin
    s_output := pkg_application_gf.gf_check_pn_spare(s_pn, l_qty, s_location);
   end Proc_Check_Pn_Spare;
   
   --- CALLED BY PROC...
  FUNCTION GET_PN_MASTER_EFFECTIVITY_DD(Xml_Query_Element Xmltype) RETURN XMLTYPE
  as
  output xmltype;
  DW PKG_DW_INVENTORY_QRY.Tt_Dw_Inv_PN_Qry ;
  Query_Element Rt_Inventory_Query_Element;
  TRAX_MESSAGE_BOX pkg_type_structures.t_TRAX_MESSAGE_BOX;
  ac varchar(100);
  pn_interchangeable varchar(100);
  BEGIN

    BEGIN select extractvalue(Xml_Query_Element, '*/Ac') into AC from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'AC ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    begin select extractvalue(xml_query_element, '*/Pn_Interchangeable') into pn_interchangeable from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'PN_INTERCHANGEABLE ', sqlerrm, dbms_utility.format_error_backtrace()); end;
      
      Dw := Pkg_Dw_Inventory_Qry.GET_PN_MASTER_EFFECTIVITY_DD(AC, pn_interchangeable);
      output := PKG_DW_INVENTORY_QRY.GET_XML_PN_INSTALL_REMOVE(Dw);
      
      Select Xmlelement("Pn_Master_Effectivity_Array",
                        output)
      Into output
      From Dual;
  
  return OUTPUT;
  END GET_PN_MASTER_EFFECTIVITY_DD;
  
  --- Callec by VS
  PROCEDURE PROC_GET_PN_MASTER_EFFECTIVITY(XML_OUTPUT in out nocopy xmltype, XML_QUERY_ELEMENT xmltype)
  as
  begin
    XML_OUTPUT := GET_PN_MASTER_EFFECTIVITY_DD(XML_QUERY_ELEMENT);
  end PROC_GET_PN_MASTER_EFFECTIVITY;
  
  
  function set_picklist_header(input xmltype) return xmltype
  as
    output xmltype;
    trax_message_box pkg_type_structures.t_trax_message_box;
    gloval pkg_global_variables.t_global_variables;
    w_picklist_header_eu pkg_w_picklist_header_eu.t_w_picklist_header_eu;
    message pkg_type_structures.st_wo;
    b_new boolean := true;
    n_edit number := 0;
    n_count number := 0;
    l_picklist number;
  begin
  
    b_new := true;
    w_picklist_header_eu.iparent.is_current_object_name := 'w_picklist_header_eu';
    
    begin select extractvalue(input, '*/Picklist') into w_picklist_header_eu.il_picklist from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Picklist'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
    
    if trim(trax_message_box.s_err_hdr) is null
    and trim(trax_message_box.s_err_msg) is null then
    
      if nvl(w_picklist_header_eu.il_picklist, 0) <> 0 then
        b_new := false;
      end if;
      
      pkg_w_picklist_header_eu.ue_open(w_picklist_header_eu, gloval, trax_message_box, message);
      
      if trim(trax_message_box.s_err_hdr) is null
      and trim(trax_message_box.s_err_msg) is null then
        
        begin select extractvalue(input, '*/Location') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).location from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Location'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Wo') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).wo from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Wo'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Ac') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).ac from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Ac'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Task_Card') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).task_card from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Task_Card'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Task_Card_Pn') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).task_card_pn from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Task_Card Pn'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        BEGIN SELECT EXTRACTVALUE(INPUT, '*/Task_Card_Sn') INTO W_PICKLIST_HEADER_EU.DW_EU(W_PICKLIST_HEADER_EU.DW_EU.LAST).TASK_CARD_SN FROM DUAL; EXCEPTION WHEN OTHERS THEN TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Task_Card Sn'; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); END;
        begin select pkg_interface.getdatefromxmlstring(extractvalue(input, '*/Require_On')) into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).require_on from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Require_On'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Require_Hour') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).require_hour from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Require_Hour'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Require_Minute') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).require_minute from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Require_Minute'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Delivery_Location') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).delivery_location from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Delivery Location'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Site') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).site from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Site'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Priority') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).priority from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Priority'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/Inventory_Type') into w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).inventory_type from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Inventory Type'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        begin select extractvalue(input, '*/User_Id') into gloval.gs_user from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid User Id'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        
        if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is null
        and TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) is null then
          
          gloval.gs_status := 'SAVE';
          gloval.gi_err := 1;
     
          n_edit := pkg_w_picklist_header_eu.ue_edit(w_picklist_header_eu, gloval, trax_message_box);
          
          gloval.gs_status := ' ';
          gloval.gi_over := 0;
          
          if n_edit > 0
          and trim(w_picklist_header_eu.iparent.is_errfld) is not null
          and TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is null then
            
            TRAX_MESSAGE_BOX.S_ERR_HDR := w_picklist_header_eu.iparent.is_errfld;
            
            if Trim(Trax_Message_Box.S_Err_Msg) Is Null then Trax_Message_Box.S_Err_Msg := 'Not valid'; end if;
            
          end if;
          
          if nvl(gloval.gi_err, 0) = 0
          and nvl(n_edit, 0) = 0
          and TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is null
          and trim(trax_message_box.s_err_msg) is null then
            
            pkg_w_picklist_header_eu.ue_save(w_picklist_header_eu, gloval, trax_message_box);

            if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is null
            and trim(trax_message_box.s_err_msg) is null then

              trax_message_box.output.extend;
              trax_message_box.output(trax_message_box.output.last).s_name := 'PICKLIST_ID'; 
              TRAX_MESSAGE_BOX.OUTPUT(TRAX_MESSAGE_BOX.OUTPUT.LAST).S_VALUE := w_picklist_header_eu.dw_eu(w_picklist_header_eu.dw_eu.last).picklist; 
              
              
            end if;
        
          end if;
          
        end if;
        
      end if;
      
    end if;
    
    output := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
    return output;
    
  end set_picklist_header;
  
  PROCEDURE PROC_Set_Picklist_Header(XML_OUTPUT in out nocopy xmltype, input xmltype)
  as
  begin
    xml_output := set_picklist_header(input);
  END proc_set_picklist_header;
  
  FUNCTION Set_Picklist_Detail(input XMLTYPE) RETURN XMLTYPE
  AS
    output xmltype;
    trax_message_box pkg_type_structures.t_trax_message_box;
    gloval pkg_global_variables.t_global_variables;
    w_picklist_detail_eu pkg_w_picklist_detail_eu.t_w_picklist_detail_eu;
    message pkg_type_structures.st_wo;
    b_new boolean := TRUE;
    n_edit number := 0;
    n_count NUMBER := 0;
    l_picklist number;
  BEGIN
    
     b_new := TRUE;
     w_picklist_detail_eu.iparent.is_current_object_name := 'w_picklist_detail_eu';
    
    BEGIN SELECT extractvalue(input, '*/PICKLIST') INTO w_picklist_detail_eu.ims_pn.n_picklist FROM dual; exception WHEN others THEN trax_message_box.s_err_hdr := 'Invalid Picklist'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); END;
    BEGIN SELECT EXTRACTVALUE(INPUT, '*/PICKLIST_LINE') INTO w_picklist_detail_eu.ims_pn.n_picklist_line FROM DUAL; EXCEPTION WHEN OTHERS THEN TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Picklist Line'; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); END;
    
     if trim(trax_message_box.s_err_hdr) is null
    and trim(trax_message_box.s_err_msg) is null then
      
      if nvl(w_picklist_detail_eu.ims_pn.n_picklist, 0) <> 0 then
        select ac
        into w_picklist_detail_eu.ims_pn.s_ac
        from picklist_header
        where picklist = w_picklist_detail_eu.ims_pn.n_picklist;
      end if;
      
      if nvl(w_picklist_detail_eu.ims_pn.n_picklist_line, 0) <> 0 then
        B_NEW := FALSE;
      end if;
      
      pkg_w_picklist_detail_eu.ue_open(w_picklist_detail_eu, gloval, trax_message_box);
      
      if trim(trax_message_box.s_err_hdr) is null
      AND TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) IS NULL THEN
        
        BEGIN SELECT EXTRACTVALUE(INPUT, '*/PN') INTO W_PICKLIST_DETAIL_EU.DW_EU(W_PICKLIST_DETAIL_EU.DW_EU.LAST).PN FROM DUAL; EXCEPTION WHEN OTHERS THEN TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Pn'; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); END;
        BEGIN SELECT EXTRACTVALUE(INPUT, '*/QTY') INTO W_PICKLIST_DETAIL_EU.DW_EU(W_PICKLIST_DETAIL_EU.DW_EU.LAST).QTY FROM DUAL; EXCEPTION WHEN OTHERS THEN TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Qty'; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); END;
        begin select extractvalue(input, '*/USER_ID') into gloval.gs_user from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid User Id'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        
        if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is null
        and TRIM(TRAX_MESSAGE_BOX.S_ERR_MSG) is null then
          
          gloval.gs_status := 'SAVE';
          gloval.gi_err := 1;
     
          n_edit := pkg_w_picklist_detail_eu.ue_edit(w_picklist_detail_eu, gloval, trax_message_box);
          
          gloval.gs_status := ' ';
          gloval.gi_over := 0;
          
          IF N_EDIT > 0
          and trim(w_picklist_detail_eu.iparent.is_errfld) is not null
          and TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is null then
            
            TRAX_MESSAGE_BOX.S_ERR_HDR := w_picklist_detail_eu.iparent.is_errfld;
            
            if Trim(Trax_Message_Box.S_Err_Msg) Is Null then Trax_Message_Box.S_Err_Msg := 'Not valid'; end if;
            
          end if;
          
          if nvl(gloval.gi_err, 0) = 0
          and nvl(n_edit, 0) = 0
          and TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is null
          and trim(trax_message_box.s_err_msg) is null then
            
            pkg_w_picklist_detail_eu.ue_save(w_picklist_detail_eu, gloval, trax_message_box);

            if TRIM(TRAX_MESSAGE_BOX.S_ERR_HDR) is null
            and trim(trax_message_box.s_err_msg) is null then

              trax_message_box.output.EXTEND;
              trax_message_box.output(trax_message_box.output.LAST).s_name := 'PICKLIST_LINE'; 
              TRAX_MESSAGE_BOX.OUTPUT(TRAX_MESSAGE_BOX.OUTPUT.LAST).S_VALUE := w_picklist_detail_eu.dw_eu(w_picklist_detail_eu.dw_eu.last).picklist_line; 
              
              
            end if;
        
          end if;
          
        end if;
        
      end if;
      
    end if;
    
    output := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
    RETURN output;
    
  end Set_Picklist_Detail;
  
  PROCEDURE PROC_Set_Picklist_Detail(XML_OUTPUT IN out nocopy XMLTYPE, input XMLTYPE)
  AS
  BEGIN
    XML_OUTPUT := SET_PICKLIST_DETAIL(INPUT);
  end PROC_Set_Picklist_Detail;
  
  function Delete_Picklist_Line(input xmltype) return xmltype
  as
    output xmltype;
    trax_message_box pkg_type_structures.t_trax_message_box;
    gloval pkg_global_variables.t_global_variables;
    w_picklist_detail_eu pkg_w_picklist_detail_eu.t_w_picklist_detail_eu;
    message pkg_type_structures.st_wo;
    b_found boolean := TRUE;
    n_count NUMBER := 0;
  begin
     
     b_found := false;
     w_picklist_detail_eu.iparent.is_current_object_name := 'w_picklist_detail_eu';
    
    BEGIN SELECT extractvalue(input, '*/PICKLIST') INTO w_picklist_detail_eu.ims_pn.n_picklist FROM dual; exception WHEN others THEN trax_message_box.s_err_hdr := 'Invalid Picklist'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); END;
    BEGIN SELECT EXTRACTVALUE(INPUT, '*/PICKLIST_LINE') INTO w_picklist_detail_eu.ims_pn.n_picklist_line FROM DUAL; EXCEPTION WHEN OTHERS THEN TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Picklist Line'; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); END;
    begin select extractvalue(input, '*/USER_ID') into gloval.gs_user from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid User Id'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
        
     if trim(trax_message_box.s_err_hdr) is null
    and trim(trax_message_box.s_err_msg) is null then
      
      begin
        select count(picklist_line)
        into n_count
        from picklist_distribution
        where "PICKLIST_DISTRIBUTION"."PICKLIST" = w_picklist_detail_eu.ims_pn.n_picklist and 
              "PICKLIST_DISTRIBUTION"."PICKLIST_LINE" = w_picklist_detail_eu.ims_pn.n_picklist_line and
              "PICKLIST_DISTRIBUTION"."TRANSACTION" = 'REQUIRE';
        b_found := true;
      exception when no_data_found then
        b_found := false;
      end;
      
      if b_found = true then
      
        select ac
        into w_picklist_detail_eu.ims_pn.s_ac
        from picklist_header
        where picklist = w_picklist_detail_eu.ims_pn.n_picklist;
        
        
        pkg_w_picklist_detail_eu.ue_open(w_picklist_detail_eu, gloval, trax_message_box);
        
        if trim(trax_message_box.s_err_hdr) is null
        and trim(trax_message_box.s_err_msg) is null then
          
          pkg_w_picklist_detail_eu.ue_delete(w_picklist_detail_eu, gloval, trax_message_box);
          
        end if;
      
      else
        
        trax_message_box.s_err_hdr := 'Picklist Line';
        trax_message_box.s_err_msg := 'Not found.';
      end if;
      
    end if;
    
    output := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
    return output;
    
  end delete_picklist_line;
  
  PROCEDURE PROC_delete_picklist_line(XML_OUTPUT IN out nocopy XMLTYPE, input XMLTYPE)
  AS
  BEGIN
    xml_output := delete_picklist_line(input);
  end proc_delete_picklist_line;
  
  function exit_picklist_detail(input xmltype) return xmltype
  as
  output xmltype;
    trax_message_box pkg_type_structures.t_trax_message_box;
    gloval pkg_global_variables.t_global_variables;
    w_picklist_detail_eu pkg_w_picklist_detail_eu.t_w_picklist_detail_eu;
    message pkg_type_structures.st_wo;
    b_new boolean := TRUE;
    n_edit number := 0;
    n_count NUMBER := 0;
    l_picklist number;
    n_answer1 number;
    n_answer2 number;
  BEGIN
    
     b_new := TRUE;
     w_picklist_detail_eu.iparent.is_current_object_name := 'w_picklist_detail_eu';
    
    begin select extractvalue(input, '*/PICKLIST') into w_picklist_detail_eu.il_picklist from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Picklist'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
    begin select extractvalue(input, '*/USER_ID') into gloval.gs_user from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid User Id'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
    begin select extractvalue(input, '*/ANSWER_1') into n_answer1 from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Answer 1'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
    begin select extractvalue(input, '*/ANSWER_2') into n_answer2 from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Answer 2'; trax_message_box.s_err_msg := sqlerrm || chr(10) || dbms_utility.format_error_backtrace(); end;
    
     if trim(trax_message_box.s_err_hdr) is null
     and trim(trax_message_box.s_err_msg) is null then
      
      if nvl(w_picklist_detail_eu.ims_pn.n_picklist, 0) <> 0 then
        select location
        into w_picklist_detail_eu.is_location
        from picklist_header
        where picklist = w_picklist_detail_eu.il_picklist;
      end if;
      
      pkg_w_picklist_detail_eu.closequery(w_picklist_detail_eu, gloval, trax_message_box, n_answer1, n_answer2);
      
      
    end if;
    
    output := pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
    return output;
    
  end exit_picklist_detail;
  
  procedure proc_exit_picklist_detail(XML_OUTPUT IN out nocopy XMLTYPE, input XMLTYPE)
  AS
  BEGIN
    xml_output := exit_picklist_detail(input);
  end proc_exit_picklist_detail;
  
   --- CALLED BY PROC...
  FUNCTION GET_PICKLIST_PN_DD(Xml_Query_Element Xmltype) RETURN XMLTYPE
  as
    output xmltype;
    DW PKG_DW_INVENTORY_QRY.Tt_Dw_Inv_PN_Qry ;
    Query_Element Rt_Inventory_Query_Element;
    trax_message_box pkg_type_structures.t_trax_message_box;
    Inventory_Type Varchar(100);
    S_Pn Varchar2(100);
    s_ac varchar2(100);
  BEGIN

    BEGIN select extractvalue(Xml_Query_Element, '*/Inventory_Type') into inventory_type from dual; exception when others then pkg_interface.set_cast_error(trax_message_box, 'INVENTORY_TYPE ', sqlerrm, DBMS_UTILITY.FORMAT_ERROR_BACKTRACE()); end;
    Begin Select Extractvalue(Xml_Query_Element, '*/Pn_Interchangeable') Into S_Pn From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'PN  ', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
    Begin Select Extractvalue(Xml_Query_Element, '*/Ac') Into S_Ac From Dual; Exception When Others Then Pkg_Interface.Set_Cast_Error(Trax_Message_Box, 'PN  ', Sqlerrm, Dbms_Utility.Format_Error_Backtrace()); End;
        
      Dw := Pkg_Dw_Inventory_Qry.GET_PICKLIST_PN_DD(inventory_type, s_Ac, s_pn);
      output := PKG_DW_INVENTORY_QRY.GET_XML_PN_INSTALL_REMOVE(Dw);
      
      Select Xmlelement("Pn_Master_Effectivity_Array",
                        output)
      Into output
      From Dual;
  
  return OUTPUT;
  END GET_PICKLIST_PN_DD;
  
  --- Callec by VS
  procedure proc_get_picklist_pn_dd(xml_output in out nocopy xmltype, xml_query_element xmltype)
  as
  begin
    xml_output := get_picklist_pn_dd(xml_query_element);
  end proc_GET_PICKLIST_PN_DD;
  
end pkg_iface_inventory_service;

/


create or replace
Package Pkg_Iface_Ac_Pn_Tran_Service As 
  
  Function Set_Ac_Pn_Transaction(Input Xmltype) Return Xmltype;
  
  PROCEDURE Proc_Set_Ac_Pn_Transaction(XML_OUTPUT OUT XMLTYPE, INPUT XMLTYPE);
  Function Is_Nha(S_Pn Varchar2) Return Boolean;
  Procedure Set_Ac_Pn_Trans_Async(Input Xmltype);
  
end pkg_iface_ac_pn_tran_service;

/

create or replace
Package Body Pkg_Iface_Ac_Pn_Tran_Service As
  
  Function Set_Ac_Pn_Transaction(Input Xmltype) Return Xmltype
  As
    message AC_PN_TRNS_HIST_TRNS_STRUCT%ROWTYPE;
    Gloval Pkg_Global_Variables.T_Global_Variables;
    window Pkg_W_Ac_Pn_Tran_History_Eu.T_W_Ac_Pn_Tran_History_Eu;
    trax_message_box pkg_type_structures.t_trax_message_box;
    N_EDIT NUMBER := 0;
    WoField number;
  Begin
    
    pkg_dw_ac_pn_tran_history_sel.insertrow(window.dw_sel);
    
    Begin
      Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/User')
      Into Gloval.Gs_User
      From Dual;
    Exception
    When Others Then
      Trax_Message_Box.S_Err_Hdr := 'User';
      Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) ||
                                    Dbms_Utility.Format_Error_Backtrace();
    End;
    
    If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
    And Trim(Trax_Message_Box.S_Err_Msg) Is Null Then
      
      Pkg_W_Ac_Pn_Tran_History_Eu.ue_open(window, gloval, trax_message_box, message);
      
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Transaction_Type') Into Window.Dw_Sel( Window.Dw_Sel.First).Transaction_Type From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Transaction_Type'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Ac') Into Window.Dw_Sel( Window.Dw_Sel.First).Ac From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Ac'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select PKG_INTERFACE.GETDATEFROMXMLSTRING(Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Date')) Into Window.Dw_Sel( Window.Dw_Sel.First)."date" From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Date'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Hour') Into Window.Dw_Sel( Window.Dw_Sel.First)."hour" From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Hour'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Minute') Into Window.Dw_Sel( Window.Dw_Sel.First)."minute" From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Minute'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Station') Into Window.Dw_Sel( Window.Dw_Sel.First)."station" From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Station'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Defect_Type') Into Window.Dw_Sel( Window.Dw_Sel.First).Defect_Type From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Defect_Type'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Defect') Into Window.Dw_Sel( Window.Dw_Sel.First).Defect From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Defect'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      begin select extractvalue(input, '*/Ac_Pn_Transaction_Header_Element/Defect_Item') into window.dw_sel( window.dw_sel.first).Defect_Item from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Defect_Item'; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
      
      BEGIN 
       --   SELECT EXTRACTVALUE(INPUT, '*/Ac_Pn_Transaction_Header_Element/Wo') 
       --   INTO WINDOW.DW_SEL( WINDOW.DW_SEL.FIRST).WO FROM DUAL; 
       
       SELECT EXTRACTVALUE(INPUT, '*/Ac_Pn_Transaction_Header_Element/Wo') INTO WoField FROM DUAL;
       
       if WoField <> 0 then 
          SELECT EXTRACTVALUE(INPUT, '*/Ac_Pn_Transaction_Header_Element/Wo') 
          INTO WINDOW.DW_SEL( WINDOW.DW_SEL.FIRST).WO FROM DUAL; 
       end if;
      
       IF WOFIELD = 0 THEN 
          SELECT null 
          INTO WINDOW.DW_SEL( WINDOW.DW_SEL.FIRST).WO FROM DUAL; 
       end if;
      
       
      Exception 
        When Others Then 
            TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Wo'; 
            TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); 
      End;
      
      
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Task_Card') Into Window.Dw_Sel( Window.Dw_Sel.First).Task_Card From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Task_Card'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Task_Card_Pn') Into Window.Dw_Sel( Window.Dw_Sel.First).Task_Card_Pn From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Task_Card_Pn'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Task_Card_Sn') Into Window.Dw_Sel( Window.Dw_Sel.First).Task_Card_Sn From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Task_Card_Sn'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
      
      If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
      And Trim(Trax_Message_Box.S_Err_Msg) Is Null Then
        
        Pkg_W_Ac_Pn_Tran_History_Eu.ue_new(window, gloval, trax_message_box);
        
        If Window.Dw_Eu Is Not Null And Window.Dw_Eu.Count > 0 Then
        
          For I In Window.Dw_Eu.First..Window.Dw_Eu.Last
          Loop
          
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Transaction_Date') into WINDOW.DW_EU(I).TRANSACTION_DATE from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Transaction Date   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Transaction_Hour') into WINDOW.DW_EU(I).TRANSACTION_HOUR from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Transaction Hour   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Transaction_Minute') into WINDOW.DW_EU(I).TRANSACTION_MINUTE from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Transaction Minute   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Pn') into WINDOW.DW_EU(I).PN from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Pn   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Sn') into WINDOW.DW_EU(I).SN from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Sn   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select NVL(TRIM(EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Position')), WINDOW.DW_EU(I).POSITION) into WINDOW.DW_EU(I).POSITION from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Position   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Reason_Category') into WINDOW.DW_EU(I).REASON_CATEGORY from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Reason_Category   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Schedule_Category') into WINDOW.DW_EU(I).SCHEDULE_CATEGORY from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Schedule_Category   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Nha_Sn') into WINDOW.DW_EU(I).NHA_SN from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Nha Sn  '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Nha_Pn') into WINDOW.DW_EU(I).Nha_Pn from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Nha Pn  '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;       
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Notes') into WINDOW.DW_EU(I).NOTES from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Notes   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Batch') into WINDOW.DW_EU(I).BATCH from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Batch   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Tag_No') into WINDOW.DW_EU(I).TAG_NO from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Tag_No   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select EXTRACTVALUE(INPUT, '//Ac_Pn_Transaction_Detail_Element['||I||']/Nla_Position') into WINDOW.DW_EU(I).NLA_POSITION from DUAL; EXCEPTION when OTHERS then TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Nla Position   '; TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select extractvalue(input, '//Ac_Pn_Transaction_Detail_Element['||i||']/Blob_No') into window.dw_eu(i).Blob_No from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Blob_No   '; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select extractvalue(input, '//Ac_Pn_Transaction_Detail_Element['||i||']/Removal_Reason') into window.dw_eu(i).Removal_Reason from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Removal_Reason   '; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;
          begin select extractvalue(input, '//Ac_Pn_Transaction_Detail_Element['||i||']/Remove_As_Serviceable') into window.dw_eu(i).Remove_As_Serviceable from dual; exception when others then trax_message_box.s_err_hdr := 'Invalid Remove_As_Serviceable   '; TRAX_MESSAGE_BOX.S_ERR_MSG := sqlerrm || chr(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); end;           
          Begin Select Extractvalue(Input, '//Ac_Pn_Transaction_Detail_Element['||I||']/Document_No') Into Window.Dw_Eu(I).Document_No From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Document_No   '; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
            
            
            window.dw_eu(i).transaction_date := Window.Dw_Sel(Window.Dw_Sel.First)."date";  
            window.dw_eu(i).transaction_hour := Window.Dw_Sel(Window.Dw_Sel.First)."hour";
            window.dw_eu(i).transaction_minute := Window.Dw_Sel(Window.Dw_Sel.First)."minute";
            
          End Loop;
          
        End If;
        
        If Trim(Trax_Message_Box.S_Err_Hdr) Is Null
        And Trim(Trax_Message_Box.S_Err_Msg) Is Null Then
          
          gloval.gs_status := 'SAVE';
          gloval.gi_err := 1;
          
          n_edit := Pkg_W_Ac_Pn_Tran_History_Eu.ue_edit(window, gloval, trax_message_box);
          gloval.gs_status := ' ';
          gloval.gi_over := 0;
          
          if GLOVAL.GI_ERR <= 0 and N_EDIT <= 0 then 
              PKG_W_AC_PN_TRAN_HISTORY_EU.UE_SAVE(WINDOW, GLOVAL, TRAX_MESSAGE_BOX); 
          else
              PKG_W_AC_PN_TRAN_HISTORY_EU.ue_hold(WINDOW, GLOVAL, TRAX_MESSAGE_BOX); 
          end if;
        
        end if;
        
      End If;
      
    End If;
    
    return pkg_interface.get_xml_trax_msg_box(trax_message_box);
    
  end Set_Ac_Pn_Transaction;
  
  Procedure Set_Ac_Pn_Trans_Async(Input Xmltype)
    As    
     S_User Varchar2(100);
     S_Ac Varchar2(100);
     S_Pn Varchar2(100);
     S_Sn Varchar2(100);
     S_Note Varchar2(32000);
     Xml_Output xmltype;
     trax_message_box pkg_type_structures.t_trax_message_box;
    Begin
    
--      Get User's info
      Begin
        Select Extractvalue(Input, '//Ac_Pn_Transaction_Detail_Element[1]/User') 
          INTO s_user
          FROM DUAL; 
          Exception When Others Then 
            TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid User   '; 
            TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); 
            Xml_Output:= Pkg_Interface.Get_Xml_Trax_Msg_Box(Trax_Message_Box);          
       End;

-- Call the Functionality    
     Xml_Output := Set_Ac_Pn_Transaction(Input);
     
     If Trim(S_User) Is Null Then
        S_User := 'ADM';
     End If;
       
--     Notify the User
        Begin Select Extractvalue(Input, '*/Ac_Pn_Transaction_Header_Element/Ac') Into S_Ac From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Ac'; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
        Begin Select Extractvalue(Input, '//Ac_Pn_Transaction_Detail_Element[1]/Pn') Into S_Pn From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Pn   '; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
        Begin Select Extractvalue(Input, '//Ac_Pn_Transaction_Detail_Element[1]/Sn') Into S_Sn From Dual; Exception When Others Then Trax_Message_Box.S_Err_Hdr := 'Invalid Sn   '; Trax_Message_Box.S_Err_Msg := Sqlerrm || Chr(10) || Dbms_Utility.Format_Error_Backtrace(); End;
         
        S_Note := 'Pending AC/PN Transaction Terminated. Ac: '||S_Ac||' Pn: '|| S_Pn ||' Sn: '||S_Sn;
        S_Note := S_Note || chr(10) || chr(13) || Xml_Output.GetStringVal();
        PKG_APPLICATION_FUNCTION.send_note_to_user('TraxM', S_User, S_Note);

    
    End Set_Ac_Pn_Trans_Async;
  
 Procedure Proc_Set_Ac_Pn_Transaction(Xml_Output Out Xmltype, Input Xmltype)
  AS
  S_Pn Varchar2(100);
  Param Varchar2(1000); 
  Trax_Message_Box Pkg_Type_Structures.T_Trax_Message_Box;
  s_input varchar2(32000);
  BEGIN
    
     Begin
      Select Extractvalue(Input, '//Ac_Pn_Transaction_Detail_Element[1]/Pn') 
        INTO s_pn 
        FROM DUAL; 
        Exception When Others Then 
          TRAX_MESSAGE_BOX.S_ERR_HDR := 'Invalid Pn   '; 
          TRAX_MESSAGE_BOX.S_ERR_MSG := SQLERRM || CHR(10) || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE(); 
          Xml_Output:= pkg_interface.get_xml_trax_msg_box(trax_message_box);          
     End;     
    
     If Trim(S_Pn) Is Not Null And Is_Nha(S_Pn) and false Then -- Remove "and false" to use the job for NLAs.
      S_Input := Input.Getstringval;
      Pkg_Iface_Async_Util.LAUNCH_JOB('AC_PN_TRANSACTION_ASYNC', 'pkg_iface_ac_pn_tran_service.Set_Ac_Pn_Trans_Async(xmltype('''||s_input||'''));'); 
      TRAX_MESSAGE_BOX.S_ERR_HDR := 'AC PN Transaction In Progress'; 
      Xml_Output:= pkg_interface.get_xml_trax_msg_box(trax_message_box);
     ELSE 
      Xml_Output := Set_Ac_Pn_Transaction(Input); 
     end if;
     
 end Proc_Set_Ac_Pn_Transaction;  
  
  function Is_NHA(s_PN varchar2) return boolean
  AS
    has_nla number:= 0;
  Begin
  
    SELECT COUNT (*) 
    into has_nla
    FROM "PN_NEXT_LOWER_ASSEMBLY",   
         "PN_INTERCHANGEABLE",   
         "PN_MASTER"  
   WHERE ( pn_next_lower_assembly.nla_pn = pn_interchangeable.pn_interchangeable (+)) and  
         ( "PN_MASTER"."PN" = "PN_INTERCHANGEABLE"."PN" ) AND  
         ( ( "PN_NEXT_LOWER_ASSEMBLY"."NHA_PN" = s_pn ) AND  
         ( "PN_NEXT_LOWER_ASSEMBLY"."RECORDS_TYPE" = 'ASSEMBLY' ) );
    
    return has_nla > 0;
    
 end Is_NHA;  
 
  
  
end pkg_iface_ac_pn_tran_service;

/


create or replace
package pkg_w_ac_pn_tran_history_eu as 
--w_ac_pn_transaction_history_eu

  PROCEDURE sendRemoveTagToPrintQueue(
    s_transaction varchar2) ;
  
  Type T_W_Ac_Pn_Tran_History_Eu
  is RECORD ( IPARENT PKG_W_STANDARD_EU.T_W_STANDARD_EU,
              DW_EU PKG_DW_AC_PN_TRAN_HISTORY_EU.TT_DW_AC_PN_TRAN_HISTORY_EU,
              DW_PKG PKG_DW_AC_PN_TRAN_HIST_AUDIT.TT_DW_AC_PN_TRAN_HIST_AUDIT,
              dw_Sel pkg_dw_ac_pn_tran_history_sel.tt_dw_ac_pn_tran_history_sel,
              dw_ac_pn_transaction_check pkg_dw_ac_pn_tran_check.tt_dw_ac_pn_tran_check,
              Is_Find Varchar2(32000),
              is_transaction_type Varchar2(32000),
              is_ac Varchar2(32000),
              is_asblychk Varchar2(32000),
              is_perfect Varchar2(32000),
              is_select_nha Varchar2(32000),
              is_nla_perfect Varchar2(32000),
              Is_Rmvrtsauto Varchar2(32000),
              Idt_Date Date,
              Il_Hour Number,
              il_minute Number,
              Il_Batch_Removal_Tag Number,
              MS_DEFECT_AC_TRANSACTION AC_PN_TRNS_HIST_TRNS_STRUCT%ROWTYPE,
              is_tech_only Varchar2(32000),
              is_audit Varchar2(32000),
              is_select_nha_pn Varchar2(32000),
              is_select_nha_sn Varchar2(32000),
              is_select_nha_pos Varchar2(32000),
              is_select_nla_pos Varchar2(32000),
              Is_Defectorwo Varchar2(32000),
              Is_Print_Us_Tag Varchar2(32000),
              Is_Trn Varchar2(32000),
              Is_Acpnedit Varchar2(32000),
              Is_Flag_Removal_Tag Varchar2(32000),
              Is_Perfect_No_Pos Varchar2(32000),
              Is_Acpntranspkg Varchar2(32000),
              Is_Auto_Quarantine_Location Varchar2(32000),
              Is_Auto_Quarantine_Bin Varchar2(32000),
              Is_Auto_Quarantine_Us_Code Varchar2(32000),
              Is_Accknlaeff Varchar2(32000),
              Is_Acpndtbk Varchar2(32000),
              L_Trn_Auto_Rst Number,
              Il_Transaction_Item Number,
              Ims_Pn Pkg_Type_Structures.St_Pn,
              is_ac_ownership_control Varchar2(32000),
              Is_Tpo_Owner Varchar2(32000),
              Is_Station_Mandatory Varchar2(32000),
              Is_Acpinsrmv Varchar2(32000),
              Is_Pn_Eo_Removal Varchar2(32000),
              Is_Remservchk Varchar2(32000),
              ib_enable_fields boolean,
              ib_pn_check boolean,
              Ib_Removing_Flag Boolean,
              Ib_Make_It_And_Nla_Part Boolean Default False,
              Is_Pn_Prev Varchar2(32000) Default ' ',
              Is_Acpntrsndd Varchar2(32000),
              Is_Dfscpremvl Varchar2(32000),
              Is_Transfer_Owner Varchar2(32000),
              Is_Acpneditrot Varchar2(32000),
              Is_Transaction_Key Varchar2(32000),
              IS_TRANSACTION_TYPE_KEY VARCHAR2(32000));
  
  --wf_insert_ac_pn_trans_hist_track
  procedure wf_insert_acpn_tran_hist_track(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables,
                                           s_transaction varchar2, s_transaction_type varchar2);
                                           
  function wf_copy_from_struct(this in out nocopy T_W_Ac_Pn_Tran_History_Eu, gloval in out nocopy pkg_global_Variables.t_global_variables) return boolean;
  
  procedure WF_COPY_TO_TRNS_AUDIT(this in out nocopy T_W_Ac_Pn_Tran_History_Eu, gloval in out nocopy pkg_global_Variables.t_global_variables);
  
  PROCEDURE WF_SET_UPDATED_FIELDS(this in out nocopy T_W_Ac_Pn_Tran_History_Eu, gloval in out nocopy pkg_global_Variables.t_global_variables);
  
  --Wf_Populate_Removal_Text_From_Task
  procedure WF_POP_REMOVAL_TEXT_FROM_TASK(this in out nocopy T_W_Ac_Pn_Tran_History_Eu, gloval in out nocopy pkg_global_Variables.t_global_variables);
 
  procedure WF_TIME(THIS in OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, GLOVAL in OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES,
                    s_transaction varchar2);

  FUNCTION wf_hold_records_delete_pkg(This IN Out Nocopy T_W_Ac_Pn_Tran_History_Eu, Gloval IN Out Nocopy Pkg_Global_Variables.T_Global_Variables,
                                      trax_message_box IN out nocopy pkg_type_Structures.t_trax_message_box) RETURN boolean;
  
  PROCEDURE Wf_Call_Pkg(This IN Out Nocopy T_W_Ac_Pn_Tran_History_Eu, Gloval IN Out Nocopy Pkg_Global_Variables.T_Global_Variables,
                        trax_message_box IN OUT NOCOPY pkg_type_structures.t_trax_message_box);
  
  PROCEDURE ue_save(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                    trax_message_box in out nocopy pkg_type_structures.t_trax_message_box);
  
  PROCEDURE UE_POSTOPEN(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                        Trax_Message_Box In Out Nocopy Pkg_Type_Structures.T_Trax_Message_Box);
  
  Procedure Ue_New(This In Out Nocopy T_W_Ac_Pn_Tran_History_Eu, Gloval In Out Nocopy Pkg_Global_Variables.T_Global_Variables,
                   trax_message_box in out nocopy pkg_type_structures.t_trax_message_box);
  
  function ue_edit(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                   trax_message_box in out nocopy pkg_type_structures.t_trax_message_box) return number;
  
  function wf_installed_remove_edit(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                                    trax_message_box in out nocopy pkg_type_structures.t_trax_message_box) return number;
  
  procedure ue_open(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                    trax_message_box IN out nocopy pkg_type_structures.t_trax_message_box,
                    message AC_PN_TRNS_HIST_TRNS_STRUCT%ROWTYPE);
  
  PROCEDURE ue_setup_control(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables);
  
  function WF_NHA_PN_SN_VALIDATION(THIS in OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, GLOVAL in OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES, S_NHA_PN_ENT varchar2, S_NHA_SN_ENT varchar2) return number;
  
  function WF_SWAP_EDIT(THIS in OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, GLOVAL in OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES) return number;
  
  function wf_check_etops_consist_assembl(THIS in OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, GLOVAL in OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES, TRAX_MESSAGE_BOX in OUT NOCOPY PKG_TYPE_STRUCTURES.T_TRAX_MESSAGE_BOX, s_nha_pn varchar2, s_nha_sn varchar2) return number;
  
  
  FUNCTION wf_is_nla(this IN OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, 
                    gloval IN OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES, 
                    TRAX_MESSAGE_BOX in OUT NOCOPY PKG_TYPE_STRUCTURES.T_TRAX_MESSAGE_BOX,
                    s_pn IN OUT NOCOPY VARCHAR2) 
                    RETURN BOOLEAN;

  function wf_edit_main(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables,
                        trax_message_box IN OUT NOCOPY pkg_type_structures.t_trax_message_box, ss_ac in out nocopy varchar2, S_CAT in out nocopy varchar2) return number;

  function wf_ac_edit(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables,
                        trax_message_box in out nocopy pkg_type_structures.t_trax_message_box, optional in out nocopy number, ss_ac in out nocopy varchar2 ) return number;
  
  function wf_edit_tpo(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables, trax_message_box in out nocopy pkg_type_structures.t_trax_message_box) return number;                      
  
  procedure wf_removal_check_date(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables, trax_message_box in out nocopy pkg_type_structures.t_trax_message_box, s_pn varchar2, s_position varchar2);
  
  PROCEDURE ue_hold(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                    trax_message_box in out nocopy pkg_type_structures.t_trax_message_box);
  
end pkg_w_ac_pn_tran_history_eu;

/
create or replace
Package Body PKG_W_AC_PN_TRAN_HISTORY_EU As
  

  
  function wf_copy_from_struct(this in out nocopy T_W_Ac_Pn_Tran_History_Eu, gloval in out nocopy pkg_global_Variables.t_global_variables) return boolean
  As
  Begin
    if this.dw_eu is not null and this.dw_eu.count > 0 then
      For L_Row In This.Dw_Eu.First..This.Dw_Eu.Last
      Loop
        begin
          INSERT INTO "AC_PN_TRNS_HIST_TRNS_STRUCT" 
                     ("TRANSACTION", 
                      "AC", 
                      "DEFECT_TYPE", 
                      "DEFECT", 
                      "DEFECT_ITEM", 
                      "TRANSACTION_DATE", 
                      "TRANSACTION_HOUR" , 
                      "TRANSACTION_MINUTE" , 
                      "TRANSACTION_ITEM" , 
                      "TRANSACTION_TYPE" , 
                      "WO" , 
                      "TASK_CARD" , 
                      "STATION" , 
                      "FLIGHT", 
                      "PN" , 
                      "SN" , 
                      "AUTO_REMOVE_INTALLED" , 
                      "FUNCTION" , 
                      "AUDIT" , 
                      "EXIT" , 
                      "AUTO_INSTALL_POSITION" , 
                      "ASC" , 
                      "BLOB_NO" , 
                      "REPORTED_BY" , 
                      "REPORTED_DATE" , 
                      "WALL_REQUIRE" , 
                      "WALL_PASSWORD" , 
                      "DEFECT_WINDOW" , 
                      "COMPARE" , 
                      "INDIVIDUAL_PRINT" , 
                      "TASK_CARD_PN" , 
                      "TASK_CARD_SN" , 
                      "CONTACT" )
               Values ( This.Is_Trn,   
                        this.dw_eu(l_row).ac,     
                        this.dw_eu(l_row).defect_type,   
                        this.dw_eu(l_row).defect,
                        this.dw_eu(l_row).defect_item,   
                        this.dw_eu(l_row).transaction_date,     
                        this.dw_eu(l_row).transaction_hour,   
                        this.dw_eu(l_row).transaction_minute,
                        this.dw_eu(l_row).transaction_item,   
                        this.dw_eu(l_row).transaction_type,     
                        this.dw_eu(l_row).wo,   
                        this.dw_eu(l_row).task_card,
                        This.Dw_Eu(L_Row).Station,   
                        this.ms_defect_ac_transaction.flight,     
                        this.dw_eu(l_row).pn,   
                        This.Dw_Eu(L_Row).Sn,
                        This.Ms_Defect_Ac_Transaction.Auto_Remove_Intalled,   
                        This.Ms_Defect_Ac_Transaction."FUNCTION",     
                        This.Ms_Defect_Ac_Transaction."AUDIT",   
                        this.ms_defect_ac_transaction."EXIT",
                        This.Ms_Defect_Ac_Transaction.Auto_Install_Position,
                        this.ms_defect_ac_transaction."ASC",   
                        this.ms_defect_ac_transaction.blob_no,     
                        this.ms_defect_ac_transaction.reported_by,   
                        this.ms_defect_ac_transaction.reported_date,
                        this.ms_defect_ac_transaction.wall_require,   
                        this.ms_defect_ac_transaction.wall_password,     
                        this.ms_defect_ac_transaction.defect_window,   
                        this.ms_defect_ac_transaction.compare,
                        this.ms_defect_ac_transaction.individual_print,   
                        this.dw_eu(l_row).task_card_pn,     
                        This.Dw_Eu(L_Row).Task_Card_Sn,   
                        this.ms_defect_ac_transaction.contact);
            Exception
            WHEN others THEN
              ROLLBACK;
              return false;
            end;
        End Loop;
      end if;
    return true;
  end WF_COPY_FROM_STRUCT;
  
  procedure WF_COPY_TO_TRNS_AUDIT(this in out nocopy T_W_Ac_Pn_Tran_History_Eu, gloval in out nocopy pkg_global_Variables.t_global_variables)
  as
  BEGIN
    if this.dw_eu is not null and this.dw_eu.count > 0 then
      For L_Row In This.Dw_Eu.First..This.Dw_Eu.Last
      Loop
        PKG_DW_AC_PN_TRAN_HIST_AUDIT.insertrow(This.Dw_Pkg); 
        This.Dw_Pkg(L_Row).Transaction := This.Is_Trn;
        This.Dw_Pkg(L_Row).Transaction_Item := This.Dw_Eu(L_Row).Transaction_Item;
        This.Dw_Pkg(L_Row).Transaction_Type := This.Dw_Eu(L_Row).Transaction_Type;
        This.Dw_Pkg(L_Row).Ac := This.Dw_Eu(L_Row).Ac;
        This.Dw_Pkg(L_Row).Transaction_Date := This.Dw_Eu(L_Row).Transaction_Date;
        This.Dw_Pkg(L_Row).Transaction_Hour := This.Dw_Eu(L_Row).Transaction_Hour;
        This.Dw_Pkg(L_Row).Transaction_Minute := This.Dw_Eu(L_Row).Transaction_Minute;
        This.Dw_Pkg(L_Row).Defect_Type := This.Dw_Eu(L_Row).Defect_Type;
        This.Dw_Pkg(L_Row).Defect:= This.Dw_Eu(L_Row).Defect;
        This.Dw_Pkg(L_Row).Defect_Item:= This.Dw_Eu(L_Row).Defect_Item;
        This.Dw_Pkg(L_Row).Wo := This.Dw_Eu(L_Row).Wo;
        This.Dw_Pkg(L_Row).Task_Card:= This.Dw_Eu(L_Row).Task_Card;
        This.Dw_Pkg(L_Row).Goods_Rcvd_Batch := This.Dw_Eu(L_Row).Goods_Rcvd_Batch;
        This.Dw_Pkg(L_Row).Pn := This.Dw_Eu(L_Row).Pn;
        This.Dw_Pkg(L_Row).Sn := This.Dw_Eu(L_Row).Sn;
        This.Dw_Pkg(L_Row).Position := This.Dw_Eu(L_Row).Position;
        This.Dw_Pkg(L_Row).Reason_Category := This.Dw_Eu(L_Row).Reason_Category;
        This.Dw_Pkg(L_Row).Schedule_Category := This.Dw_Eu(L_Row).Schedule_Category;
        This.Dw_Pkg(L_Row).Hours_Installed  := This.Dw_Eu(L_Row).Hours_Installed;
        This.Dw_Pkg(L_Row).Minutes_Installed  := This.Dw_Eu(L_Row).Minutes_Installed;
        This.Dw_Pkg(L_Row).Cycles_Installed := This.Dw_Eu(L_Row).Cycles_Installed;
        This.Dw_Pkg(L_Row).Days_Installed  := This.Dw_Eu(L_Row).Days_Installed;
        This.Dw_Pkg(L_Row).Nha_Pn := This.Dw_Eu(L_Row).Nha_Pn;
        This.Dw_Pkg(L_Row).Nha_Sn := This.Dw_Eu(L_Row).Nha_Sn;
        This.Dw_Pkg(L_Row).Nla := This.Dw_Eu(L_Row).Nla;
        This.Dw_Pkg(L_Row).Notes := This.Dw_Eu(L_Row).Notes;
        This.Dw_Pkg(L_Row).Created_By := This.Dw_Eu(L_Row).Created_By;
        This.Dw_Pkg(L_Row).Created_Date := This.Dw_Eu(L_Row).Created_Date;
        This.Dw_Pkg(L_Row).Modified_By := This.Dw_Eu(L_Row).Modified_By;
        This.Dw_Pkg(L_Row).Modified_Date := This.Dw_Eu(L_Row).Modified_Date;
        This.Dw_Pkg(L_Row).Batch := This.Dw_Eu(L_Row).Batch;
        This.Dw_Pkg(L_Row).non_sn := This.Dw_Eu(L_Row).non_sn;
        This.Dw_Pkg(L_Row).Station := This.Dw_Eu(L_Row).Station;
        This.Dw_Pkg(L_Row).recurrent := This.Dw_Eu(L_Row).recurrent;
        This.Dw_Pkg(L_Row).Status  := This.Dw_Eu(L_Row).Status;
        This.Dw_Pkg(L_Row).Transaction_Type_Control := This.Dw_Eu(L_Row).Transaction_Type_Control;
        This.Dw_Pkg(L_Row).Chapter := This.Dw_Eu(L_Row).Chapter;
        This.Dw_Pkg(L_Row).Section  := This.Dw_Eu(L_Row).Section;
        This.Dw_Pkg(L_Row).paragraph := This.Dw_Eu(L_Row).paragraph;
        This.Dw_Pkg(L_Row).Tag_No := This.Dw_Eu(L_Row).Tag_No;
        This.Dw_Pkg(L_Row).removal_reason := This.Dw_Eu(L_Row).removal_reason;
        This.Dw_Pkg(L_Row).Nla_Position  := This.Dw_Eu(L_Row).Nla_Position;
        This.Dw_Pkg(L_Row).remove_as_serviceable := This.Dw_Eu(L_Row).remove_as_serviceable;
        This.Dw_Pkg(L_Row).Nha_Pn_Prorated := This.Dw_Eu(L_Row).Nha_Pn_Prorated;
        This.Dw_Pkg(L_Row).task_card_pn  := This.Dw_Eu(L_Row).task_card_pn;
        This.Dw_Pkg(L_Row).document_no  := This.Dw_Eu(L_Row).document_no;
        This.Dw_Pkg(L_Row).Blob_No := This.Dw_Eu(L_Row).Blob_No;
        This.Dw_Pkg(L_Row).Task_Card_Sn:= This.Dw_Eu(L_Row).Task_Card_Sn;
        This.Dw_Pkg(L_Row).import_status:= 'PENDING';
      END loop;
    end if;
  end WF_COPY_TO_TRNS_AUDIT;
  
  PROCEDURE WF_SET_UPDATED_FIELDS(THIS IN OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, GLOVAL IN OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES)
  As
    
  Begin
    
    If This.Is_Audit = 'YES' Then
     For L_Row In Reverse This.Dw_Eu.first..this.dw_eu.last
     Loop
      This.Dw_Eu(L_Row).Transaction_Date := This.Idt_Date;
      This.Dw_Eu(L_Row).Transaction_Hour := This.Il_Hour;
      This.Dw_Eu(L_Row).Transaction_Minute := This.Il_Minute;
      This.Dw_Eu(L_Row).Wo := This.Dw_Sel(This.Dw_Sel.First).Wo;
      This.Dw_Eu(L_Row).Task_Card := This.Dw_Sel(This.Dw_Sel.FIRST).Task_Card;
      This.Dw_Eu(L_Row).Task_Card_Pn := This.Dw_Sel(This.Dw_Sel.First).Task_Card_Pn;
      this.dw_eu(l_row).task_card_sn := this.dw_sel(this.dw_sel.first).task_card_sn;
      This.Dw_Eu(L_Row).station := This.Dw_Sel(This.Dw_Sel.First)."station";
     end loop;
    End If;
    
  end WF_SET_UPDATED_FIELDS;
  
  procedure wf_insert_acpn_tran_hist_track(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables,
                                           s_transaction varchar2, s_transaction_type varchar2)
  AS
  Begin
    
    INSERT INTO "AC_PN_TRANSACTION_HIST_TRACK"  
		( "TRANSACTION",   
		  "TRANSACTION_TYPE",   
		  "CREATED_BY",   
		  "CREATED_DATE")  
    Values ( s_transaction,   
			  s_transaction_type,     
			  gloval.gs_user,   
			  Pkg_Application_Function.Currentdatetime); 
        
  end Wf_Insert_Acpn_Tran_Hist_Track;
  
  procedure WF_POP_REMOVAL_TEXT_FROM_TASK(this in out nocopy T_W_Ac_Pn_Tran_History_Eu, gloval in out nocopy pkg_global_Variables.t_global_variables) as
    S_DEFECT_TYPE varchar2(100);
    s_defect varchar2(100);
    S_TASK_CARD VARCHAR2(100);
     S_TASK_CARD_PN varchar2(100);
    S_TASK_CARD_SN VARCHAR2(100);
    S_REMOVAL_TEXT varchar2(2000 char);
    L_WO number;
    l_defect_item number;
  
  begin

    if 	THIS.IS_AUDIT = 'YES' then return; end if;
    
    S_DEFECT_TYPE := THIS.DW_SEL(THIS.DW_SEL.first).DEFECT_TYPE;
    S_DEFECT := THIS.DW_SEL(THIS.DW_SEL.first).DEFECT;
    L_DEFECT_ITEM := THIS.DW_SEL(THIS.DW_SEL.first).DEFECT_ITEM;
    L_WO := THIS.DW_SEL(this.dw_Sel.first).WO;
    S_TASK_CARD := THIS.DW_SEL(this.dw_Sel.first).TASK_CARD;
    S_TASK_CARD_PN := THIS.DW_SEL(THIS.DW_SEL.first).TASK_CARD_PN;
    if NVL(S_TASK_CARD_PN, ' ') = ' '  then S_TASK_CARD_PN := RPAD(' ',35); end if;
    s_task_card_sn := THIS.DW_SEL(THIS.DW_SEL.first).task_card_sn;
    if NVL(S_TASK_CARD_SN, ' ') = ' '  then S_TASK_CARD_SN := RPAD(' ',35); end if;
    
    if nvl(s_defect_type,'null') <> 'null' then
		
        SELECT D."DEFECT_DESCRIPTION"
        INTO s_removal_text
        from "DEFECT_REPORT"  D
        WHERE D."DEFECT_TYPE" = s_defect_type AND  
              D."DEFECT" = S_DEFECT and  
                  D."DEFECT_ITEM" = l_defect_item;
		
    elsif nvl(l_wo,0) > 0 and nvl(s_task_card,'null') <> 'null' then
		
    plog.debug(to_char(l_wo) || s_task_card || S_TASK_CARD_PN || ',' ||s_task_card_sn );
    
        SELECT DISTINCT TC."TASK_CARD_DESCRIPTION" 
        INTO s_removal_text
        FROM "WO_TASK_CARD" TC 
        WHERE TC."WO" = l_wo AND
                    TC."TASK_CARD" = s_task_card AND
               TC."PN" = S_TASK_CARD_PN and
               TC."PN_SN" = s_task_card_sn;
			
    end if;
    
    this.dw_eu(this.dw_eu.first).removal_reason := s_removal_text;
      
  end WF_POP_REMOVAL_TEXT_FROM_TASK;

  procedure WF_TIME(THIS in OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, GLOVAL in OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES,
                     S_TRANSACTION varchar2)
   As
   L_Time Number;
   dt_today date;
  BEGIN
    
    if this.IS_AUDIT is null or this.IS_AUDIT <= '0' then this.IS_AUDIT := 'NO'; end if; 
    
    if this.IS_AUDIT = 'NO' then
        
        If s_transaction = 'INITIAL' Then
            
            If Pkg_Application_Function.config_flag('ACPNTRNT') = 'N' Then
               
                L_Time := null;
                This.Dw_Sel(This.Dw_Sel.First)."hour" := L_Time;
                this.DW_SEL(This.Dw_Sel.First)."minute" := l_time;
                
            Else
                Dt_Today := Pkg_Application_Function.Currentdatetime;
                This.Dw_Sel(This.Dw_Sel.First)."date" :=  Dt_Today;
                This.Dw_Sel(This.Dw_Sel.First)."hour" := To_Number(To_Char(Dt_Today, 'HH'));
                This.dw_sel(This.Dw_Sel.First)."minute" := TO_NUMBER(TO_CHAR(Dt_Today, 'MI'));
                
            End If;
            
        End If; 
        
    end if; 
  
  end WF_TIME;                  
                     
  Procedure Wf_Call_Pkg(This In Out Nocopy T_W_Ac_Pn_Tran_History_Eu, Gloval In Out Nocopy Pkg_Global_Variables.T_Global_Variables,
                        trax_message_box IN OUT NOCOPY pkg_type_structures.t_trax_message_box)
  AS
    b_temp boolean;
    l_wo number;
    l_def_item NUMBER;
    l_delete_hold NUMBER := 0;
    s_task_card varchar2(100);
    s_stat varchar2(100);
    s_def VARCHAR2(100);
    s_def_type VARCHAR2(100);
    s_cat VARCHAR2(100);
    s_import_status VARCHAR2(32000);
    s_import_excep VARCHAR2(32000);
    b_delete_hold boolean;
    b_swap boolean;
    ms_pn pkg_type_Structures.st_pn;
    s_pn VARCHAR2(100);
    S_SCHEDULE_CATEGORY VARCHAR2(100);
    s_ac VARCHAR2(100);
    s_sn VARCHAR2(100);
    s_transaction VARCHAR2(100);
    s_transaction_type VARCHAR2(100);
    s_position VARCHAR2(100);
    s_ac_installed VARCHAR2(100);
    l_transaction_item NUMBER;
    s_email_all VARCHAR2(100);
    s_remove_as_serv varchar2(100);
  Begin
    If This.Ib_Enable_Fields Then Wf_Set_Updated_Fields(This, Gloval); End If;
    This.Dw_Pkg := pkg_dw_ac_pn_tran_hist_audit.Retrieve(this.Is_Trn);
    IF This.Dw_Pkg.Count = 0 THEN
      Wf_Copy_To_Trns_Audit(This, Gloval);
      If Not Wf_Copy_From_Struct(this, gloval) Then 
        Trax_Message_Box.S_Err_Hdr := 'Error';
        Trax_Message_Box.S_Err_Msg := 'Unable to save using PKG';
        Return;
      End If;
      BEGIN
        Pkg_Dw_Ac_Pn_Tran_Hist_Audit.Gf_Save(this.Dw_Pkg);
      Exception
      when others then
        Trax_Message_Box.S_Err_Hdr := 'Error';
        Trax_Message_Box.S_Err_Msg := 'Unable to save using PKG';
        Return;
      END;
    End If;
    
    l_wo := this.dw_sel(this.dw_sel.first).wo;
    s_task_card := this.dw_sel(this.dw_sel.FIRST).task_card;
    b_delete_hold := wf_hold_records_delete_pkg(this, gloval, trax_message_box);
    s_stat := this.dw_sel(this.dw_sel.first)."station";
    s_def := this.dw_sel(this.dw_sel.first).defect;
    s_def_type := this.dw_sel(this.dw_sel.first).defect_type;
    l_def_item := this.dw_sel(this.dw_sel.FIRST).defect_item; 
    s_cat := this.dw_eu(this.dw_eu.first).reason_category;
    
    if b_delete_hold then l_delete_hold := 1; end if;
    
    If nvl(this.is_transaction_type,' ') = 'SWAP' Then b_swap := true; end if;
    
    begin
      PKG_AC_PN_TRANSACTION.PRE_SAVE(this.is_trn, gloval.gs_user, this.is_ac_ownership_control,
                                     this.is_transfer_owner, this.idt_date, this.IL_HOUR,
                                     this.il_minute, this.is_ac, this.is_tpo_owner,
                                     this.is_audit, this.is_transaction_type, l_wo,
                                     s_task_card, this.is_select_nha, this.is_auto_quarantine_us_code,
                                     this.is_auto_quarantine_bin, this.is_auto_quarantine_location, l_delete_hold,
                                     gloval.gs_user, s_stat, s_def,
                                     s_def_type, l_def_item, this.is_pn_eo_removal,
                                     s_cat);
    exception
    WHEN others THEN
      trax_message_box.s_err_hdr := sqlerrm;
      TRAX_MESSAGE_BOX.S_ERR_MSG := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();
      return;
    end;
    
    begin
    
      SELECT "IMPORT_STATUS", "IMPORT_EXCEPTIONS"
      INTO s_import_status, s_import_excep
      FROM "AC_PN_TRNS_HIST_TRNS_AUDIT"
      Where "TRANSACTION" = This.Is_Trn
      and "TRANSACTION_ITEM" = 1;
      
      IF s_import_status = 'ERROR' THEN
        trax_message_box.s_err_hdr := 'Error';
        TRAX_MESSAGE_BOX.S_ERR_MSG := S_IMPORT_EXCEP;
        RETURN;
      end if;
    
    EXCEPTION
    when NO_DATA_FOUND then
    NULL;
      --trax_message_box.s_err_hdr := sqlerrm;
      --TRAX_MESSAGE_BOX.S_ERR_MSG := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();
      
    end;
   
    
    BEGIN
      SELECT "IMPORT_STATUS", "IMPORT_EXCEPTIONS"
      INTO s_import_status, s_import_excep
      FROM "AC_PN_TRNS_HIST_TRNS_AUDIT"
      Where "TRANSACTION" = This.Is_Trn
      and "TRANSACTION_ITEM" = 2;
      
      IF s_import_status = 'ERROR' THEN
        trax_message_box.s_err_hdr := 'Error';
        TRAX_MESSAGE_BOX.S_ERR_MSG := s_import_excep;
        Return;
      ENd if;
    
    EXCEPTION
    when NO_DATA_FOUND then
    NULL;
      --trax_message_box.s_err_hdr := sqlerrm;
      --TRAX_MESSAGE_BOX.S_ERR_MSG := DBMS_UTILITY.FORMAT_ERROR_BACKTRACE();
      
    end;
    
    IF this.dw_eu IS NOT NULL AND this.dw_eu.count > 0 THEN
      FOR i IN this.dw_eu.FIRST..this.dw_eu.LAST
      loop
        IF b_swap THEN this.dw_eu(i).transaction_type := 'INTERCHG'; END IF;
        s_ac := this.dw_eu(i).ac;
        s_pn := this.dw_eu(i).pn;
        s_sn := this.dw_eu(i).sn;
        s_transaction := this.dw_eu(i).TRANSACTION;
        l_transaction_item := this.dw_eu(i).transaction_item;
        s_transaction_type := this.dw_eu(i).transaction_type;
        s_schedule_category := this.dw_eu(i).schedule_category;
        s_position := this.dw_eu(i).position;
        if trim(s_position) is null then s_position := rpad(' ', 10); end if;
        
        IF S_SCHEDULE_CATEGORY = 'UN/SCHEDULE' THEN
          this.IMS_PN.S_PN := S_PN;
          this.IMS_PN.DT_REMOVAL_DATE := this.IDT_DATE;
         End If;
         
        this.ms_defect_ac_transaction.transaction := s_transaction;
        this.ms_defect_ac_transaction.pn := s_pn;
        
        IF this.is_print_us_tag = 'Y' AND ((this.dw_eu(i).transaction_type = 'REMOVE')
                                            OR (this.dw_eu(i).transaction_type = 'REMOVE/INSTALL')
                                            or (gloval.gs_profile = 'ASTAR' and nvl(this.is_transaction_type,' ') <> 'EXCHANGE'))  then
          s_pn := this.dw_eu(i).pn;
          s_sn := this.dw_eu(i).sn;
          this.is_flag_removal_tag := 'YES';
          
          SELECT "PN_INVENTORY_DETAIL"."BATCH"  
          INTO   this.il_batch_removal_tag  
          FROM   "PN_INVENTORY_DETAIL"  
          WHERE  "PN_INVENTORY_DETAIL"."PN" = s_pn AND
               "PN_INVENTORY_DETAIL"."SN" = s_sn;
          
        End If;
      end loop;
    end if;
    
    --Check For Audit flag on part
    IF this.is_audit = 'BYPASS'  THEN
      this.is_audit := NULL;
      RETURN;
    End If;
    
    if trim(this.ims_pn.s_pn) is not null then
      pkg_application_gf.gf_recurrent_pn(gloval, this.ims_pn);
      this.IMS_PN.S_PN := NULL;
    END IF;
    
    s_email_all := pkg_application_gf.gf_get_sys_tran_config_flag('EMAILPN');
    
    --TODO
--    If s_email_all = 'Y' then
--      OpenWithParm(w_removal_installtion_alert_check,ms_defect_ac_transaction)
--    ElseIf tab_hd.tabpage_gen.dw_eu.RowCount() > 1 Then
--      If gf_nvl(tab_hd.tabpage_gen.dw_eu.GetItemString(1, 'pn'),'') <> gf_nvl(tab_hd.tabpage_gen.dw_eu.GetItemString(2, 'pn'),'') Then
--        OpenWithParm(w_removal_installtion_alert_check,ms_defect_ac_transaction)
--      END IF
--    End If 
    
    --Removed Tag
    If this.is_flag_removal_tag = 'YES' then
      
      gloval.gs_message_check := 'SERVICETAG';
      ms_pn.n_batch := this.il_batch_removal_tag;
      
      IF (gloval.gs_profile = 'ASTAR') THEN 
        ms_pn.l_no_of_copies := 2;
      ELSE
        ms_pn.l_no_of_copies := 1;
      END IF;
      
      ms_pn.s_transaction := s_transaction;
    
      IF gloval.gs_profile = 'GAC' THEN
        if this.is_transaction_type in('REMOVE/INSTALL', 'REMOVE') then	
          ms_pn.s_pn_transaction_type := this.is_transaction_type;
          ms_pn.s_ac := this.dw_Sel(this.dw_sel.first).ac;
          ms_pn.s_position  := this.dw_eu(this.dw_eu.first).position;
          ms_pn.dt_removal_date := this.dw_Sel(this.dw_sel.first)."date";
          ms_pn.s_pn  := this.dw_eu(this.dw_eu.first).pn;
          ms_pn.s_sn  := this.dw_eu(this.dw_eu.first).sn;
          ms_pn.s_message  := this.dw_eu(this.dw_eu.first).reason_category;
          ms_pn.s_location := this.dw_sel(this.dw_sel.first)."station"; 
          if this.is_transaction_type = 'REMOVE/INSTALL' then
            ms_pn.s_nla_position := this.dw_eu(this.dw_eu.first + 1).position;
            ms_pn.s_pn_old := this.dw_eu(this.dw_eu.FIRST + 1).pn;
            ms_pn.l_wo := this.dw_Sel(this.dw_sel.first).wo;
            ms_pn.s_category := this.dw_Sel(this.dw_sel.first).defect_type;
            ms_pn.s_condition := this.dw_Sel(this.dw_sel.FIRST).defect;
            ms_pn.l_order_line := this.dw_Sel(this.dw_sel.first).defect_item;
          end if;
        END IF;
      end if;
      
      this.is_flag_removal_tag := null;
      s_remove_as_serv  := this.dw_eu(this.dw_eu.FIRST).remove_as_serviceable;
      ms_pn.s_remove_as_serviceable := s_remove_as_serv;
       
      
     declare
       s_loc wo.location%type;
       s_site wo.site%type;
       l_wo number ;
      begin
      l_wo := this.dw_Sel(this.dw_sel.first).wo;
      select "LOCATION" , site
      into s_loc , s_site
      from wo where wo = l_wo ;
      
       ms_pn.s_location := s_loc || '*' || s_site ;
      
     
     end ; 
      
        sendRemoveTagToPrintQueue('REMOVED-TAG,' || s_transaction || ',' || this.il_batch_removal_tag || ',' ||  ms_pn.s_location ) ;
      
      IF this.dw_eu(this.dw_eu.FIRST).remove_as_serviceable = 'YES' THEN
        ms_pn.s_remove_as_serviceable := 'YES';
         sendRemoveTagToPrintQueue('FORM-ONE,' || s_transaction || ',' || this.il_batch_removal_tag || ',' ||  ms_pn.s_location ) ;
      end if;
      ms_pn.s_location := this.dw_Sel(this.dw_sel.FIRST)."station";
      
     
    End If;
     
    
    
  end wf_call_pkg;
  
  
PROCEDURE sendRemoveTagToPrintQueue(
    s_transaction varchar2)
AS
l_id number ;
BEGIN

l_id := SEQ_IOS_PRINT_JOBS.nextval ; 
  INSERT
  INTO ios_printing_jobs
    (
      UNIQUE_ID,
      PRINT_WINDOW,
      SELECTED_PRINT,
      PRINT_TITLE,
      COMPARISON_OPERATOR,
      PRINT_STATUS,
      TRAX_USER,
      CREATED_DATE,
      START_DATE,
      FINISH_DATE,
      SAVING_PATH,
      URL_PATH , 
      PRINT_PARAMETERS , 
      OBJECT_PARAMETERS
    )
    VALUES
    (
      l_id      ,
      'w_pn_removed_tag_print',
      NULL,
      'Pn Removed Tag Print',
      NULL,
      'OPEN',
      'TRAXIFACE',
     sysdate,
    null,
     null,
     null,
     null , 
     s_transaction , 
    -- utl_raw.cast_to_raw( to_char( l_picklist ) )
    null
    );
    
    pkg_window_printing_jobs.add_ios_job(l_id); 
    
exception when others then 
plog.debug('Could not send to queue transaction,batch :  ' || s_transaction );  
END sendRemoveTagToPrintQueue ; 
  
  
  
  FUNCTION wf_hold_records_delete_pkg(This IN Out Nocopy T_W_Ac_Pn_Tran_History_Eu, Gloval IN Out Nocopy Pkg_Global_Variables.T_Global_Variables,
                                      trax_message_box in out nocopy pkg_type_Structures.t_trax_message_box) RETURN boolean
  AS
    s_return VARCHAR2(32000);
    s_ac VARCHAR2(100);
    s_pn VARCHAR2(100);
    s_sn VARCHAR2(100);
    s_transaction VARCHAR2(100);
    n_sqlcode number := 0;
  BEGIN
    
    if this.dw_eu is not null and this.dw_eu.count > 0 then
      
      FOR i IN this.dw_eu.FIRST..this.dw_eu.LAST
      loop
        s_ac := this.dw_eu(i).ac;
        s_pn := this.dw_eu(i).pn;
        s_sn := this.dw_eu(i).sn;
        s_transaction := this.dw_eu(i).transaction;
        
        begin
          SELECT "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_TYPE"  
          INTO s_return  
          FROM "AC_PN_TRANSACTION_HISTORY"  
          WHERE ( "AC_PN_TRANSACTION_HISTORY"."AC" = s_ac ) AND  
            ( "AC_PN_TRANSACTION_HISTORY"."PN" = s_pn ) AND  
            ( "AC_PN_TRANSACTION_HISTORY"."SN" = s_sn ) AND  
            ( "AC_PN_TRANSACTION_HISTORY"."STATUS" = 'HOLD' ) AND  
            ( "AC_PN_TRANSACTION_HISTORY"."TRANSACTION" <> s_transaction );
          n_sqlcode := sqlcode;
        exception
        WHEN others THEN
          n_sqlcode := sqlcode;
        END;
        
        IF n_SQLCODE = 0 THEN
          trax_message_box.s_question_hdr := 'P/N and S/N';
          trax_message_box.s_question_msg := 'At least one P/N and S/N in this transaction has other records on Hold on this A/C . Do you want to delete these records for all P/N and S/N?';
--          If MessageBox('P/N and S/N ', 'At least one P/N and S/N in this transaction has other records on Hold on this A/C . Do you want to delete these records for all P/N and S/N?' , Question!, YESNO!, 1) = 1 Then 
--            return true
--          Else
--            return false
--          END if
        
        End if;
      end loop;
      
    END IF;
    
    return false;
    
  end wf_hold_records_delete_pkg;
  
  procedure ue_save(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables,
                    trax_message_box in out nocopy pkg_type_structures.t_trax_message_box)
  AS
    l_count NUMBER;
    s_pn varchar2(100);
    s_sn VARCHAR2(100);
    s_transaction_type VARCHAR2(100);
    s_indicator VARCHAR2(32000);
    s_text VARCHAR2(32676);
  begin
    wf_insert_acpn_tran_hist_track(this, gloval, this.is_trn, 'STARTED');
    this.iparent.is_check_modified := ' ';
    
    if nvl(this.is_ac_ownership_control, 'NO') = 'DRYLEASE' then 
       trax_message_box.s_warn_hdr := 'Warning';
       trax_message_box.s_warn_msg := 'Ownership for Aircraft in AC Master is set to dry lease. The AC PN Transaction will not be saved.';
    end if;
    
    if nvl(this.is_ac_ownership_control, 'NO') = 'DRYLEASE' then
      pkg_dw_ac_pn_tran_history_eu.gf_save(this.dw_eu);
    else
      wf_call_pkg(this, gloval, trax_message_box);
      
      IF this.is_audit = 'YES' THEN
        this.ms_defect_ac_transaction."AUDIT" := 'NO';
        this.is_audit := 'NO';
        pkg_dw_ac_pn_tran_history_eu.gf_save(this.dw_eu);
      end if;
      
    end if;
    
    this.iparent.is_tran := ' ';
    
    s_pn := this.dw_eu(this.dw_eu.first).pn;
    s_sn := this.dw_eu(this.dw_eu.first).sn;
    
    SELECT Count(*)
    INTO l_count
    FROM "PN_POOL_MASTER"
    WHERE "PN_POOL_MASTER"."PN" = s_pn;
    
    s_transaction_type := this.dw_eu(this.dw_eu.first).transaction_type;

    wf_insert_acpn_tran_hist_track(this, gloval, this.is_trn, 'COMPLETED');
    
    IF l_count <> 0 AND s_transaction_type IN ('INTERCHG', 'REMOVE/INSTALL', 'INSTALL', 'REMOVE') THEN 
      s_indicator := rpad(' ', 20);
      s_text := rpad(' ', 32676);
      
      PKG_IFACE_LHT.TRANSMIT_COMPONENT_CHANGE(this.is_trn, s_indicator, s_text) ;
      IF s_indicator = 'ERROR' THEN
        trax_message_box.s_err_hdr := 'LHT COMPONENT CHANGE RESPONSE ERROR';
        trax_message_box.s_err_msg := s_text;
        Return;
      ElsIf s_indicator = 'EXCEPTION' THEN
        trax_message_box.s_err_hdr := 'LHT COMPONENT CHANGE EXCEPTION';
        trax_message_box.s_err_msg := s_text;
        Return;
      ElsIf s_indicator = 'WARNING' THEN
        trax_message_box.s_err_hdr := 'LHT COMPONENT CHANGE RESPONSE WARNING';
        trax_message_box.s_err_msg := s_text;
      END IF;
    End If;
    
  END ue_save;
  
  PROCEDURE ue_new(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                   trax_message_box in out nocopy pkg_type_structures.t_trax_message_box)
  AS
    s_defect_type VARCHAR2(100);
    s_defect VARCHAR2(100);
    s_task_card VARCHAR2(100);
    s_trn VARCHAR2(100);
    s_station VARCHAR2(100);
    s_task_card_pn VARCHAR2(100);
    s_task_card_sn VARCHAR2(100);
    l_wo NUMBER;
    L_TRN number := 0;
    l_defect_item NUMBER;
    I_IROW number;
    S_TRANSACTION_TYPE varchar2(100);
    S_LINE_TYPE varchar2(100);
    s_transaction_type_delete varchar2(100);
    n_temp number;
  BEGIN
    
    this.is_pn_prev := '';
    gloval.gs_status := ' ';
    this.iparent.is_tran := 'NEW';
    
    wf_time(this, gloval, 'UPDATE');
    
    If wf_edit_main(this, gloval, trax_message_box, this.dw_sel(this.dw_sel.first).ac, this.dw_sel(this.dw_sel.first).defect_type) = 1 Then Return; end if;
    
    this.is_transaction_type := this.dw_sel(this.dw_sel.FIRST).transaction_type;
    this.is_ac := this.dw_sel(this.dw_sel.FIRST).ac;
    s_station  := this.dw_sel(this.dw_sel.FIRST)."station";
    s_defect_type := this.dw_sel(this.dw_sel.first).defect_type;
    s_defect := this.dw_sel(this.dw_sel.first).defect;
    l_defect_item := this.dw_sel(this.dw_sel.first).defect_item;
    l_wo := this.dw_sel(this.dw_sel.FIRST).wo;
    s_task_card := this.dw_sel(this.dw_sel.FIRST).task_card;
    s_task_card_pn := this.dw_sel(this.dw_sel.FIRST).task_card_pn;
    If nvl(s_task_card_pn,' ') = ' ' Then s_task_card_pn := rpad(' ', 35); end if;
    s_task_card_sn := this.dw_sel(this.dw_sel.FIRST).task_card_sn;
    IF nvl(s_task_card_sn,' ') = ' ' THEN s_task_card_sn := rpad(' ', 35); END IF;
    s_trn := pkg_application_gf.gf_config_number('ACPNTRSQ');
    this.is_trn := s_trn;
    l_trn := 0;
    
    --Software Upload
    --TODO
    
    --LOAD RECORDS
    If this.is_transaction_type in ('REMOVE/INSTALL', 'REMOVE', 'EXCHANGE', 'SWAP') Then 
      
      pkg_dw_ac_pn_tran_history_eu.insertrow(this.dw_Eu);
      
      i_irow := this.dw_eu.LAST;
      
      IF this.is_remservchk = 'Y'  THEN
        this.dw_eu(i_irow).remove_as_serviceable := 'YES';	
      END IF;
      
      IF this.is_transaction_type = 'SWAP' THEN
        this.dw_eu(i_irow).schedule_category := 'SWAP';
      END IF;
      
      THIS.DW_EU(I_IROW)."TRANSACTION" := S_TRN;	
      L_TRN := L_TRN + 1;
      THIS.DW_EU(I_IROW).TRANSACTION_ITEM := L_TRN;	
      THIS.DW_EU(I_IROW).TRANSACTION_TYPE := 'REMOVE';
      THIS.DW_EU(I_IROW).AC := this.IS_AC;
      THIS.DW_EU(I_IROW).TRANSACTION_DATE := THIS.IDT_DATE;
      THIS.DW_EU(I_IROW).TRANSACTION_HOUR := THIS.IL_HOUR;
      THIS.DW_EU(I_IROW).TRANSACTION_MINUTE := this.IL_MINUTE;
      THIS.DW_EU(I_IROW).DEFECT_TYPE := S_DEFECT_TYPE;
      THIS.DW_EU(I_IROW).DEFECT := S_DEFECT;
      THIS.DW_EU(I_IROW).DEFECT_ITEM := L_DEFECT_ITEM;
      THIS.DW_EU(I_IROW).WO := L_WO;
      THIS.DW_EU(I_IROW).TASK_CARD := S_TASK_CARD;
      THIS.DW_EU(I_IROW).TASK_CARD_PN := S_TASK_CARD_PN;
      THIS.DW_EU(I_IROW).TASK_CARD_SN := S_TASK_CARD_SN;
      THIS.DW_EU(I_IROW).STATION := S_STATION;
      THIS.DW_EU(I_IROW).TRANSACTION_TYPE_CONTROL := this.IS_TRANSACTION_TYPE;
      THIS.DW_EU(I_IROW).CREATED_BY := GLOVAL.GS_USER;
      THIS.DW_EU(I_IROW).CREATED_DATE := PKG_APPLICATION_GF.GF_GET_SYSDATE;
      
    End If;
    
    If this.is_transaction_type in ('REMOVE/INSTALL', 'INSTALL', 'EXCHANGE', 'SWAP') Then 
    
      PKG_DW_AC_PN_TRAN_HISTORY_EU.INSERTROW(THIS.DW_EU);
      
      I_IROW := THIS.DW_EU.last;
      
       IF this.is_transaction_type = 'SWAP' THEN
        this.dw_eu(i_irow).schedule_category := 'SWAP';
      END IF;
      
      THIS.DW_EU(I_IROW)."TRANSACTION" := S_TRN;	
      L_TRN := L_TRN + 1;
      THIS.DW_EU(I_IROW).TRANSACTION_ITEM := L_TRN;	
      THIS.DW_EU(I_IROW).TRANSACTION_TYPE := 'INSTALL';
      THIS.DW_EU(I_IROW).AC := this.IS_AC;
      THIS.DW_EU(I_IROW).TRANSACTION_DATE := THIS.IDT_DATE;
      THIS.DW_EU(I_IROW).TRANSACTION_HOUR := THIS.IL_HOUR;
      THIS.DW_EU(I_IROW).TRANSACTION_MINUTE := this.IL_MINUTE;
      THIS.DW_EU(I_IROW).DEFECT_TYPE := S_DEFECT_TYPE;
      THIS.DW_EU(I_IROW).DEFECT := S_DEFECT;
      THIS.DW_EU(I_IROW).DEFECT_ITEM := L_DEFECT_ITEM;
      THIS.DW_EU(I_IROW).WO := L_WO;
      THIS.DW_EU(I_IROW).TASK_CARD := S_TASK_CARD;
      THIS.DW_EU(I_IROW).TASK_CARD_PN := S_TASK_CARD_PN;
      THIS.DW_EU(I_IROW).TASK_CARD_SN := S_TASK_CARD_SN;
      THIS.DW_EU(I_IROW).STATION := S_STATION;
      THIS.DW_EU(I_IROW).TRANSACTION_TYPE_CONTROL := this.IS_TRANSACTION_TYPE;
      THIS.DW_EU(I_IROW).CREATED_BY := GLOVAL.GS_USER;
      THIS.DW_EU(I_IROW).CREATED_DATE := PKG_APPLICATION_GF.GF_GET_SYSDATE;
      
    End If;
    
    --Update Item On Hold
    if THIS.IS_AUDIT = 'YES' then
      
      this.dw_eu := PKG_DW_AC_PN_TRAN_HISTORY_EU.Retrieve(this.ms_defect_ac_transaction."TRANSACTION");
      
      S_TRANSACTION_TYPE := this.DW_SEL(this.DW_SEL.first).TRANSACTION_TYPE;
      
      if THIS.DW_EU.COUNT = 1 and S_TRANSACTION_TYPE = 'REMOVE/INSTALL' then
        S_LINE_TYPE := THIS.DW_EU(THIS.DW_EU.first).TRANSACTION_TYPE;
        
        if S_LINE_TYPE =  'REMOVE' then
          this.is_transaction_type := 'REMOVE';
        else
          this.is_transaction_type := 'INSTALL';
        end if;
      
        this.DW_SEL(this.DW_SEL.first).transaction_type := this.is_transaction_type;
      end if;
      
      if THIS.DW_EU is not null and THIS.DW_EU.COUNT > 0 then
        for L_CROW in reverse THIS.DW_EU.first..THIS.DW_EU.last
        LOOP
          THIS.DW_EU(L_CROW).AC := THIS.IS_AC;
          THIS.DW_EU(L_CROW).TRANSACTION_DATE := THIS.IDT_DATE;
          THIS.DW_EU(L_CROW).TRANSACTION_HOUR := THIS.IL_HOUR;
          THIS.DW_EU(L_CROW).TRANSACTION_MINUTE := THIS.IL_MINUTE;
          THIS.DW_EU(L_CROW).DEFECT_TYPE := S_DEFECT_TYPE;
          THIS.DW_EU(L_CROW).DEFECT := S_DEFECT;
          this.dw_eu(l_crow).defect_item := l_defect_item;
          THIS.DW_EU(L_CROW).WO := L_WO;
          THIS.DW_EU(L_CROW).TASK_CARD := S_TASK_CARD;
          THIS.DW_EU(L_CROW).TASK_CARD_PN := S_TASK_CARD_PN;
          THIS.DW_EU(L_CROW).TASK_CARD_SN := S_TASK_CARD_SN;
          THIS.DW_EU(L_CROW).MODIFIED_DATE := PKG_APPLICATION_GF.GF_GET_SYSDATE;
          THIS.DW_EU(L_CROW).MODIFIED_BY := GLOVAL.GS_USER;
          THIS.DW_EU(L_CROW).STATION := S_STATION;
          this.dw_eu(l_crow).status := 'CLOSED';
      
          --Reload Transaction
          IF THIS.IS_TRANSACTION_TYPE IN ('REMOVE', 'INSTALL') THEN
            IF THIS.IS_TRANSACTION_TYPE = 'REMOVE' THEN S_TRANSACTION_TYPE_DELETE := 'INSTALL'; END IF;
            If this.is_transaction_type = 'INSTALL' Then s_transaction_type_delete := 'REMOVE'; end if;
            if THIS.DW_EU(L_CROW).TRANSACTION_TYPE = S_TRANSACTION_TYPE_DELETE then
              PKG_DW_AC_PN_TRAN_HISTORY_EU.DELETEROW(THIS.DW_EU, L_CROW);
            end if;
          End If;
          
          n_temp := UE_EDIT(this, gloval, trax_message_box);
        
        end loop;
      end if;
    End If;
    
    IF this.IS_DFSCPREMVL = 'Y' THEN
      IF this.IS_TRANSACTION_TYPE in ('REMOVE/INSTALL', 'REMOVE') THEN
        WF_POP_REMOVAL_TEXT_FROM_TASK(this, gloval);	
      END IF;
    end if;
    
  END UE_NEW;
    
  function ue_edit(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                   trax_message_box in out nocopy pkg_type_structures.t_trax_message_box) return number
  as
    nvo_now1 pkg_nvo_nha_one_way.nvo_nha_one_way;
    is_pn_nha varchar2(100);
    s_pn_found varchar2(100);
    s_pn_inter varchar2(100);
    s_pn_inter_prev varchar2(100);
    s_message_inter varchar2(100);
    s_mess varchar2(100);
    cursor dcl_cursor is
      SELECT  NOTE_PAD.NOTES_TEXT  
      FROM PN_INTERCHANGEABLE, NOTE_PAD  
      WHERE ( PN_INTERCHANGEABLE.CONDITIONAL_NOTES = NOTE_PAD.NOTES ) and  
          ( ( PN_INTERCHANGEABLE.PN_INTERCHANGEABLE = s_pn_inter ));
    type tt_cursor
    is table of dcl_cursor%rowtype;
    t_cursor tt_cursor;
    cursor dcl_cur is
      SELECT  NOTE_PAD.NOTES_TEXT  
      FROM PN_INTERCHG_ONE_WAY, NOTE_PAD  
      WHERE ( PN_INTERCHG_ONE_WAY.CONDITIONAL_NOTES = NOTE_PAD.NOTES ) and  
          ( ( PN_INTERCHG_ONE_WAY.PN_INTERCHANGEABLE = s_pn_inter ));
    type tt_cur
    is table of dcl_cur%rowtype;
    t_cur tt_cur;
    s_type varchar2(100);
    s_cat varchar2(100);
    i_ccrow number;
    i_row number;
    s_pn1 varchar2(100);
    s_pn2 varchar2(100);
    s_sn1 varchar2(100);
    s_sn2 varchar2(100);
    s_nha_pn varchar2(100);
    s_nha_sn varchar2(100);
    s_pn varchar2(100);
    s_sn varchar2(100);
    s_nla_position varchar2(100);
    n_sqlcode number := 0;
    s_return varchar2(100);
    s_transaction_type varchar2(100);
    s_position varchar2(100);
    s_nla_pos varchar2(100);
    s_ac_installed varchar2(100);
    s_etops varchar2(100);
    s_etops_flag varchar2(100);
    s_sch_cat varchar2(100);
    s_main_pn varchar2(100);
    dt_installed_date date;
    l_installed_hour number;
    l_installed_minute number;
    d_qty_available number;
    d_qty_reserved number;
    d_qty_in_transfer number;
    d_qty_pending_ri number;
    d_qty_in_repair number;
    d_qty_in_rental number;
    d_us number;
    s_owner varchar2(100);
    s_position_nla varchar2(100);
    b_nla boolean := false;
    d_nha_nla_position pkg_dw_next_lower_assembly.tt_dw_next_lower_assembly;
    s_all_pn pkg_type_structures.tt_string := pkg_type_structures.tt_string();
    nvo_now4 pkg_nvo_nha_one_way.nvo_nha_one_way;
    i_optional number;
    s_ac varchar2(100);
    s_pn_rem varchar2(100);
    s_pn_ins varchar2(100);
    s_nha_pn_entered varchar2(100);
    s_nha_sn_entered varchar2(100);
    l_batch number;
    dt_removal_date date;
    l_removal_hour number;
    l_removal_minute number;
    dt_inst date;
    dt_remv date;
    l_pn_batch number;
    nvo_now pkg_nvo_nha_one_way.nvo_nha_one_way;
    s_category varchar2(100);
    s_ac_issued varchar2(100);
    dt_issue_created_date date;
    l_return_count number;
    l_wo number;
    i_error number;
    ms_pn_eff pkg_type_structures.st_pn;
    ms_pn pkg_type_structures.st_pn;
    l_trow number;
    N_TEMP number;
    N_pos_temp number;
  begin
    
    n_temp := pkg_w_standard_eu.ue_edit(this.iparent, gloval);
    
    if nvl(this.is_ac_ownership_control, 'NO') = 'DRYLEASE' then
      
      if this.dw_eu.count > 1 then
         this.dw_eu(1).schedule_category := 'SCHEDULE'; 
      end if;
      
      if this.dw_eu.count = 2 then
         this.dw_eu(2).schedule_category := 'SCHEDULE';
      end if;
        
      gloval.gi_err := 0;
      Return 0;
      
    end if;
    
    If this.ib_enable_fields Then
      If wf_edit_main(this, gloval, trax_message_box, this.dw_sel(this.dw_sel.first).ac, this.dw_sel(this.dw_sel.first).defect_type) = 1 Then Return 1; end if;
    End If;
    
    --TODO
--    if gloval.gs_status = 'SAVE' or this.iparent.is_fldnam = 'pn' Then
--      
--      for l_r in this.dw_eu.first..this.dw_eu.last
--      loop
--        is_pn_nha := this.dw_eu(l_r).PN;
--        pkg_nvo_nha_one_way.of_set_pn(nvo_now1, gloval, is_pn_nha);
--        if pkg_nvo_nha_one_way.of_check_nla_loop(nvo_now1, gloval) then
--            s_pn_found := pkg_nvo_nha_one_way.of_get_pn_found(nvo_now1, gloval);
--            trax_Message_box.s_err_hdr := 'Assembly Loop Detected';
--            trax_Message_box.s_err_msg := 'Check your assembly build (PN: ' || s_pn_found || ')';
--            return 1;
--        end if;
--      end loop;	
--    end if;
    
--    if gloval.gs_status = 'SAVE' Then
--      
--      s_message_inter := ' ';
--      s_pn_inter_prev := ' ';
--      for i_c in this.dw_eu.first..this.dw_eu.last
--      loop
--        s_pn_inter := this.dw_eu(i_c).PN;
--        if nvl(s_pn_inter_prev, ' ') <> nvl(s_pn_inter, ' ') then
--          --interchangeable
--          OPEN dcl_cursor;
--          fetch dcl_cursor bulk collect into t_cursor;
--          close dcl_cursor;
--          
--          if t_cursor is not null and t_cursor.count > 0 then
--            
--            for i in t_cursor.first..t_cursor.last
--            loop
--              s_mess := t_cursor(i).notes_text;
--              s_message_inter := s_message_inter||s_mess||chr(10);
--            end LOOP;
--            
--          end if;
--          
--          
--          --Interchangeable one way
--          OPEN dcl_cur;
--          fetch dcl_cur bulk collect into t_cur;
--          close dcl_cur;
--          
--          if t_cur is not null and t_cur.count > 0 then
--            
--            for i in t_cur.first..t_cur.last
--            loop
--              s_mess := t_cur(i).notes_text;	
--              s_message_inter := s_message_inter||s_mess||chr(10);
--            end LOOP;
--          
--          end if;
--          
--        End if;
--        s_pn_inter_prev := this.dw_eu(i_c).PN;
--      end loop;
--      
--      if trim(s_message_inter) is not null then 
--        trax_message_box.s_warn_hdr := 'CONDITIONAL INTERCHANGEABILITY NOTES';
--        trax_message_box.s_warn_msg := s_message_inter;
--      end if;
--      
--    end if;
    
    --Edit schedule_category
    i_ccrow := 1;
    s_cat := this.dw_eu(i_ccrow).reason_category;
    
    begin
      SELECT NVL("SYSTEM_TRAN_CODE"."REMOVAL_TYPE",' ')  
      INTO s_type  
      FROM "SYSTEM_TRAN_CODE"  
      WHERE ( "SYSTEM_TRAN_CODE"."SYSTEM_TRANSACTION" = 'REASONCATEGORY' ) AND  
            ( "SYSTEM_TRAN_CODE"."SYSTEM_CODE" = s_cat );
    exception
    when others then
      s_type := null;
    end;
    
    if trim(s_type) is not null then this.dw_eu(i_ccrow).schedule_category := s_type; end if;
    
    if this.is_transaction_type = 'SWAP' then this.dw_eu(i_ccrow).schedule_category := 'SWAP'; end if;
    
    If gloval.gs_status = 'SAVE' Then	
      this.iparent.is_errfld := ' ';
      i_row := 1;
      if this.dw_eu(i_row).remove_as_serviceable = 'YES'
      and this.dw_eu(i_row).schedule_category = 'UN/SCHEDULE' then
        trax_message_box.s_err_hdr := 'Remove as Serviceable';
        trax_message_box.s_err_msg := 'Only Schedule or Swap';
        this.iparent.is_errfld := 'schedule_category';
        Return 1;
      end if;
    end if;
    
    if gloval.gs_status = 'SAVE' and this.is_transaction_type = 'SWAP'  Then
      
       s_pn1 := this.dw_eu(1).pn;
       s_sn1 := this.dw_eu(1).sn;
       s_pn2 := this.dw_eu(2).pn;
       s_sn2 := this.dw_eu(2).sn;
       
      if  s_pn1 =  s_pn2 and  s_sn1 = s_sn2 then
        trax_message_box.s_err_hdr := 'S/N';
        trax_message_box.s_err_hdr := 'Not Valid.';
        return 1;
      end if;
      
    end if;
    
    --Place the NHA information
    if gloval.gs_status = 'SAVE'  and this.is_transaction_type in ('REMOVE/INSTALL', 'EXCHANGE')  then
      
      s_pn := this.dw_eu(1).pn;
      s_sn := this.dw_eu(1).sn;
      
      begin      
        SELECT	"PN_INVENTORY_DETAIL"."NHA_PN",
              "PN_INVENTORY_DETAIL"."NHA_SN",
              "PN_INVENTORY_DETAIL"."NLA_POSITION"
         INTO s_nha_pn,
            s_nha_sn,
            s_nla_position
         FROM "PN_INVENTORY_DETAIL"  
         WHERE ( "PN_INVENTORY_DETAIL"."PN" = s_pn ) AND  
            ( "PN_INVENTORY_DETAIL"."SN" = s_sn );
      exception
      when others then
        null;
      end;
      
      this.dw_eu(1).nha_pn := s_nha_pn;
      this.dw_eu(1).nha_sn := s_nha_sn;
      this.dw_eu(1).nla_position := s_nla_position;
      
      if this.dw_eu.count = 2 then 
        this.dw_eu(2).nha_pn := s_nha_pn;
        this.dw_eu(2).nha_sn := s_nha_sn;
        this.dw_eu(2).nla_position := s_nla_position;
      end if;
      
    end if;
    
    begin
      
      --Edit W/O Detail Only
      If this.is_ac_ownership_control = 'TPO' Then
        If wf_edit_tpo(this, gloval, trax_message_box) = 1 Then
           gloval.gi_err := 1;
           Return  1;
        Else
          gloval.gi_err := 0;
          Return 0;
        End If;
      End If;
      

      If this.is_transaction_type = 'INSTALL'   Then
        s_pn := this.dw_eu(1).pn;
        b_nla := wf_is_nla(this, gloval, trax_message_box, s_pn);
        
        if this.is_perfect = 'Y' then	
          IF b_nla THEN 
            
            s_nha_pn := this.dw_eu(1).nha_pn;
            s_nha_sn := this.dw_eu(1).nha_sn;
            
            plog.debug('of_set_pn');
            pkg_nvo_nha_one_way.of_set_pn(nvo_now4, gloval, s_pn);
            plog.debug('of_get_pn_found_all_coma_delim');
            pkg_nvo_nha_one_way.of_get_pn_found_all_coma_delim(nvo_now4, gloval, s_pn, 'BACK', s_all_pn);
            
            d_nha_nla_position := pkg_dw_next_lower_assembly.retrieve(s_nha_pn, s_all_pn);
            
            if d_nha_nla_position is not null and d_nha_nla_position.count = 1 then
               s_return := d_nha_nla_position(1).nla_position;
               
               if trim(s_return) is null then 
                null;
               end if;
            else
              null;
            end if;
            
            s_position := this.dw_eu(1).position;
            
            If gloval.gs_status = 'SAVE' and (trim(s_position) is null or length(s_position) > 0) Then 
              
              begin
                SELECT	"PN_INVENTORY_DETAIL"."INSTALLED_POSITION"
                INTO s_position
                FROM "PN_INVENTORY_DETAIL"  
                WHERE ( "PN_INVENTORY_DETAIL"."PN" = s_nha_pn ) AND  
                  ( "PN_INVENTORY_DETAIL"."SN" = s_nha_sn );
                n_sqlcode := sqlcode;
              exception
              when others then
                n_sqlcode := sqlcode;
              end;
              
              If n_SQLCODE = 100 Then
                trax_message_box.s_err_hdr := 'NHA P/N S/N';
                trax_message_box.s_err_msg := 'NHA P/N S/N Not Found.';
                this.iparent.is_errfld := 'nha_pn';
                Return 1;
              End If;
      
              If trim(s_position) is not null Then
                this.dw_eu(1).position := s_position;
              End If;
            End If;
            
          end if;
        end if;
        
      end if;
    
    end;
    
    if this.dw_eu is not null and this.dw_eu.count > 0 then
      
      for i_crow in this.dw_eu.first..this.dw_eu.last
      loop
        
        begin
          
          s_transaction_type := this.dw_eu(i_crow).transaction_type;
	
          --Edit P/N	
          If (this.iparent.is_fldnam = 'pn' or gloval.gs_status = 'SAVE')  Then
            
            this.iparent.is_errfld := ' ';
            i_optional := 1;
            if pkg_application_gf.gf_pn_edit(this.dw_eu(i_crow).pn, i_optional, 'ALL', trax_message_box.s_question_hdr, trax_message_box.s_question_msg, trax_message_box.s_err_hdr, trax_message_box.s_err_msg) = 1 then
              this.iparent.is_errfld := 'pn';
              Return 1;
            End If;
            
            s_pn := this.dw_eu(i_crow).pn;
            s_sn := this.dw_eu(i_crow).sn;
            
            SELECT "PN_MASTER"."ETOPS",   
                "PN_MASTER"."ETOPS_FLAG"  
             INTO s_etops,   
                s_etops_flag  
             FROM "PN_INTERCHANGEABLE",   
                "PN_MASTER"  
            WHERE ( "PN_MASTER"."PN" = "PN_INTERCHANGEABLE"."PN" ) and  
                ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn ));
            
          end if;
          
          if gloval.gs_status = 'SAVE' Then
            if (s_transaction_type <> 'REMOVE') then
              s_ac := this.dw_sel(1).ac;
              s_position := this.dw_eu(1).position;
              if (s_transaction_type = 'INSTALL') then s_pn_ins := this.dw_eu(1).pn; end if;
              if THIS.DW_EU.COUNT = 2 then S_PN_INS := THIS.DW_EU(2).PN;	end if;		
              N_POS_TEMP :=pkg_application_gf_ii.GF_SAME_POSITION_GROUP(GLOVAL, S_AC, S_POSITION, S_PN_INS);
              if N_pos_temp = 1 then
                trax_message_box.s_err_hdr := 'A Position Group Exists for this P/N';
                trax_message_box.s_err_msg := 'P/N ' || s_pn_ins || ' installed. Intermixing not allowed';
                Return 1;
              end if;
            End If;
          end if;
          
          If (gloval.gs_status = 'SAVE') Then
            s_nha_pn_entered := this.dw_eu(i_crow).nha_pn;
            s_nha_sn_entered := this.dw_eu(i_crow).nha_sn;
            If (nvl(s_nha_pn_entered, ' ') <> ' ' and nvl(s_nha_sn_entered, ' ') <> ' ') then
              this.ims_pn.s_pn := this.dw_eu(i_crow).pn;
              this.ims_pn.s_installed_ac :=  this.dw_eu(i_crow).ac;
              If wf_nha_pn_sn_validation(this, gloval, s_nha_pn_entered, s_nha_sn_entered) = 1 then
                trax_message_box.s_err_hdr := 'NHA P/N S/N';
                trax_message_box.s_err_msg := 'Not installed on same A/C: ' || this.ims_pn.s_installed_ac || '.';
                this.iparent.is_errfld := 'nha_pn';
                Return 1;
              End If;
            End If;
          End If;
          
          If this.iparent.is_fldnam = 'removal_reason' or gloval.gs_status = 'SAVE' Then	
            this.iparent.is_errfld := ' ';
            if pkg_application_gf.gf_get_sys_tran_config_flag('REMREASO') = 'Y' then
              if this.dw_eu(i_crow).transaction_type = 'REMOVE' and nvl(this.is_transaction_type,' ') <> 'SWAP' then
                If nvl(this.dw_eu(i_crow).removal_reason, ' ') = ' ' Then
                  trax_message_box.s_err_hdr := 'Removal Reason';
                  trax_message_box.s_err_msg := 'Removal Reason TEXT is mandatory';
                  this.iparent.is_errfld := 'removal_reason';
                  Return  1;
                end if;
              end if;
            end if;
          end if;
          
          --Edit S/N
          If this.iparent.is_fldnam = 'sn' or gloval.gs_status = 'SAVE' Then	
            this.iparent.is_errfld := ' ';
            s_pn := this.dw_eu(i_crow).pn;
            s_sn := this.dw_eu(i_crow).sn;
          
            If trim(s_sn) is null Then
              trax_message_box.s_err_hdr := 'S/N';
              trax_message_box.s_err_msg := 'Not Valid.';
              this.iparent.is_errfld := 'sn';
              Return 1;
            ElsIf (trim(s_pn) is null ) and (trim(s_sn) is not null) Then
              trax_message_box.s_err_hdr := 'P/N';
              trax_message_box.s_err_msg := 'Must enter P/N first.';
              this.iparent.is_errfld := 'pn'; 
              Return 1;
            End If;
            
            begin
              SELECT "PN_INVENTORY_DETAIL"."INSTALLED_AC",   
                  "PN_INVENTORY_DETAIL"."INSTALLED_POSITION",   
                  "PN_INVENTORY_DETAIL"."INSTALLED_DATE",   
                  "PN_INVENTORY_DETAIL"."INSTALLED_HOUR",   
                  "PN_INVENTORY_DETAIL"."INSTALLED_MINUTE",   
                  "PN_INVENTORY_DETAIL"."QTY_AVAILABLE",   
                  "PN_INVENTORY_DETAIL"."QTY_RESERVED",   
                  "PN_INVENTORY_DETAIL"."QTY_IN_TRANSFER",   
                  "PN_INVENTORY_DETAIL"."QTY_PENDING_RI",
                  "PN_INVENTORY_DETAIL"."QTY_IN_REPAIR",
                  "PN_INVENTORY_DETAIL"."QTY_IN_RENTAL",
                  "PN_INVENTORY_DETAIL"."QTY_US",
                  "PN_INVENTORY_DETAIL"."OWNER",
                  "PN_INVENTORY_DETAIL"."NLA_POSITION",
                  "PN_INVENTORY_DETAIL"."BATCH",
                  "PN_INVENTORY_DETAIL"."NHA_PN",
                  "PN_INVENTORY_DETAIL"."NHA_SN"
               INTO s_ac_installed,   
                  s_position,   
                  dt_installed_date,   
                  l_installed_hour,   
                  l_installed_minute,   
                  d_qty_available,   
                  d_qty_reserved,   
                  d_qty_in_transfer,   
                  d_qty_pending_ri,
                  d_qty_in_repair,
                  d_qty_in_rental,
                  d_us,
                  s_owner,
                  s_position_nla,
                  l_batch,
                  s_nha_pn,
                  s_nha_sn
               FROM "PN_INVENTORY_DETAIL"  
               WHERE ( "PN_INVENTORY_DETAIL"."PN" = s_pn ) AND  
                  ( "PN_INVENTORY_DETAIL"."SN" = s_sn );
              n_sqlcode := sqlcode;
             exception
             when others then
              n_sqlcode := sqlcode;
             end;
             
             If n_sqlcode = 100 and (nvl(this.is_transaction_type,' ') <> 'EXCHANGE' AND s_transaction_type = 'INSTALL')  Then
              
              If gloval.gs_status = 'SAVE' Then
                trax_message_box.s_err_hdr := 'P/N and S/N';
                trax_message_box.s_err_msg := 'Not Found.';
              End If;
              
              this.iparent.is_errfld := 'sn';
              Return  1;
              
            End If;
             
            If n_SQLCODE = 0 Then 
              this.dw_eu(i_crow).batch := l_batch;
                
              If s_transaction_type = 'INSTALL' and trim(s_nha_pn) is not null and nvl(this.is_transaction_type,' ') <> 'SWAP'  then 
                If trim(s_nha_sn) is null then s_nha_sn := ' '; end if;
                trax_message_box.s_err_hdr := 'P/N and S/N';
                trax_message_box.s_err_msg := 'Is Already Installed On NHA P/N: ' || s_nha_pn || ' S/N: '|| s_nha_sn ||'.';
                Return 1;
              End If;
            end if;
               
            dt_installed_date := pkg_application_function.getcombineddate(dt_installed_date, l_installed_hour, l_installed_minute);
            this.idt_date := pkg_application_function.getcombineddate(this.idt_date, this.il_hour, this.il_minute);
            
            If d_qty_available is null Then	d_qty_available := 0; end if;
            If d_qty_reserved is null Then d_qty_reserved := 0; end if;
            If d_qty_in_transfer is null Then	d_qty_in_transfer := 0; end if;
            If d_qty_pending_ri is null Then d_qty_pending_ri := 0; end if;
            If d_qty_in_repair is null Then	d_qty_in_repair := 0; end if;
            If d_us is null Then d_us := 0; end if;
            If d_qty_in_rental is null Then	d_qty_in_rental := 0; end if;
               
            If n_SQLCODE <> 100 and this.is_transaction_type = 'EXCHANGE' and s_transaction_type = 'INSTALL' Then
              If gloval.gs_status = 'SAVE' Then
                trax_message_box.s_err_hdr := 'P/N and S/N';
                trax_message_box.s_err_msg := 'Already Exists.';
              End If;
              this.iparent.is_errfld := 'sn';
              Return 1;
            End If;
            
            If s_transaction_type = 'INSTALL'and nvl(this.is_transaction_type,' ') <> 'EXCHANGE' AND nvl(this.is_transaction_type,' ') <> 'SWAP' Then
              --Check For Tech Only
              If nvl(this.is_tech_only, 'N') <> 'Y' Then
                If d_qty_available + d_qty_reserved + d_qty_in_transfer + d_qty_pending_ri + d_qty_in_repair + d_qty_in_rental + d_us > 0 Then
                     
                  If gloval.gs_status = 'SAVE' Then
                    trax_message_box.s_err_hdr := 'P/N and S/N';
                    trax_message_box.s_err_msg := 'Has not been issued.';
                  End If;
                
                  this.iparent.is_errfld := 'sn';
                  Return 1;
                End If;
              End If;
              
              --Check For Tech Only
              If nvl(this.is_tech_only, 'N') <> 'Y' Then
                If trim(s_ac_installed) is not null Then
                
                  If gloval.gs_status = 'SAVE' Then
                    trax_message_box.s_err_hdr := 'P/N and S/N';
                    trax_message_box.s_err_msg := 'Is Already Installed On A/C: ' || s_ac_installed;
                  End If;
                  
                  this.iparent.is_errfld := 'sn';
                  Return 1;
                End If;
              End If;
              plog.debug('ue_edit - 1318');    
              --Check For Last Installed Date
              If s_transaction_type = 'INSTALL' then
                wf_removal_check_date(this, gloval, trax_message_box, s_pn, this.dw_eu(1).position);
              End If;
              
              --Check if the part will be available at the given date
              dt_removal_date := null;	
              l_removal_hour := null;
              l_removal_minute := null;
              
              begin    
                SELECT ACPN."TRANSACTION_DATE",
                        ACPN."TRANSACTION_HOUR",
                        ACPN."TRANSACTION_MINUTE"
                INTO dt_removal_date,   
                     l_removal_hour,   
                     l_removal_minute  
                FROM (SELECT "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_DATE",   
                          "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_HOUR",   
                          "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_MINUTE"  
                      FROM "AC_PN_TRANSACTION_HISTORY"  
                      WHERE ( "AC_PN_TRANSACTION_HISTORY"."PN" = s_pn ) AND  
                          ( "AC_PN_TRANSACTION_HISTORY"."SN" = s_sn ) AND  
                          ( "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_TYPE" like 'REMOVE' )   
                      ORDER BY "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_DATE" DESC,   
                            "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_HOUR" DESC,   
                            "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_MINUTE" DESC ) ACPN
                WHERE ROWNUM = 1;
                n_sqlcode := sqlcode;
              exception
              when others then
                n_sqlcode := sqlcode;
                dt_removal_date := null;
                l_removal_hour := null;
                l_removal_minute := null;
              end;
              
              if dt_removal_date is not null then
                dt_remv := pkg_application_function.getcombineddate(dt_removal_date, l_removal_hour, l_removal_minute);
                dt_inst := pkg_application_function.getcombineddate(this.idt_date, this.il_hour, this.il_minute);
                if ( dt_inst < dt_remv ) then						
                  If gloval.gs_status = 'SAVE' Then
                    trax_message_box.s_err_hdr := 'P/N and S/N';
                    trax_message_box.s_err_msg := 'Install date is prior to last removal date.';
                  End If;
                      
                  this.iparent.is_errfld := 'sn';
                  Return  1;
                end if ;
              end if;		
            End if;
            
            If s_transaction_type = 'REMOVE'  Then
              --Check For Tech Only
              If nvl(this.is_tech_only, 'N') <> 'Y' Then
                If nvl(this.is_ac, ' ') <> nvl(s_ac_installed, ' ') or trim(s_ac_installed) is null Then
            
                  If gloval.gs_status = 'SAVE' Then
                    trax_message_box.s_err_hdr := 'P/N and S/N';
                    trax_message_box.s_err_msg := 'Not installed on A/C.';
                  End If;
                  this.iparent.is_errfld := 'sn';
                  Return 1;
                End If;
            
                If this.idt_date < dt_installed_date Then
              
                  If gloval.gs_status = 'SAVE' Then
                    trax_message_box.s_err_hdr := 'P/N and S/N';
                    trax_message_box.s_err_msg := 'Removal date is prior to installed date.';
                  End If;
                  this.iparent.is_errfld := 'sn';
                  Return 1;
                End If;
                
                --Check if the two parts are interchangeable and can fit onto the other's position
                if wf_swap_edit(this, gloval) <> 0 then
                  trax_message_box.s_err_hdr := 'P/N Interchangeability';
                  trax_message_box.s_err_msg := 'Parts are not Interchangeable';
                  this.iparent.is_errfld := 'pn';
                  return 1;
                End if;
              End If;
        
              this.dw_eu(1).position := s_position;
        
              --Load position
              If this.is_transaction_type in ('REMOVE/INSTALL', 'EXCHANGE') Then
                this.dw_eu(2).position := s_position;
              End if;
            End If;
          End If;
          
          --Load position
          If this.is_transaction_type = 'SWAP' Then
            
            l_pn_batch := this.dw_eu(2).batch;
            
            If nvl(l_pn_batch, 0) <> 0 Then
              
              s_ac := this.dw_sel(1).ac;
              
              s_return := null;
              
              begin
                SELECT "PN_INVENTORY_DETAIL"."PN"  
                INTO s_return  
                FROM "PN_INVENTORY_DETAIL"  
                WHERE ( "PN_INVENTORY_DETAIL"."BATCH" = l_pn_batch ) AND  
                    ( "PN_INVENTORY_DETAIL"."INSTALLED_AC" = s_ac );
              exception
              when others then
                s_return := null;
              end;
              
              If trim(s_return) is null Then 
                trax_message_box.s_err_hdr := 'P/N S/N';
                trax_message_box.s_err_hdr := 'Not installed on same A/C.';
                this.iparent.is_errfld := 'batch';
                return 1;
              End If;
              
              If s_transaction_type = 'REMOVE'  Then
                this.dw_eu(2).position := s_position;			
              Else
                this.dw_eu(1).position := s_position;
              End if;
              
            End If;	
          
          End if;
          
          --TODO
          --Assembly Control
--          If this.is_asblychk = 'Y' and gloval.gs_status = 'SAVE' and s_transaction_type = 'INSTALL'  Then
--            If trim(this.dw_eu(i_crow).sn) is not null Then
--              
--              s_pn := this.dw_eu(i_crow).pn;
--              s_sn := this.dw_eu(i_crow).sn;
--              pkg_nvo_nha_one_way.of_set_pn(nvo_now, gloval, s_pn);
--              if pkg_nvo_nha_one_way.of_check_incomplete(nvo_now, gloval, s_pn, s_sn) then
--                trax_message_box.s_err_hdr := 'P/N and S/N';
--                trax_message_box.s_err_msg := 'Not a perfect assembly.';
--                this.iparent.is_errfld := 'sn';
--                Return  1;
--              end if;
--              
--              --Check ETOPS in the Assembly
--              if wf_check_etops_consist_assembl(this, gloval, trax_message_box, s_pn, s_sn) = 1 then					
--                this.iparent.is_errfld := 'sn';
--                Return 1;
--              end if;
--              
--            End If;
--          End If;
          
          --Check Reason Category
          If this.is_ac_ownership_control <> 'TPO' Then
            
            If this.iparent.is_fldnam = 'reason_category' or gloval.gs_status = 'SAVE' Then	
              this.iparent.is_errfld := ' ';
              i_optional := 0;
              if pkg_application_gf.gf_get_sys_tran_config_flag('IN/RVMAD') = 'Y' then i_optional := 1; end if;
              s_category := 'REASONCATEGORY';
              this.iparent.is_fldnam := 'reason_category';
              If pkg_application_gf.gf_category_edit(gloval, trax_message_box, this.dw_eu(i_crow).reason_category, i_optional, s_category) = 1 Then
                this.iparent.is_errfld := 'reason_category';
                Return 1;
              End If;
            end if;
            
          end if;
          
          --Edit A/C Perfect Mask
          If gloval.gs_status = 'SAVE' and this.is_transaction_type = 'INSTALL' and this.is_perfect = 'Y' Then
            this.iparent.is_errfld := ' ';
            i_optional := 1;
            if not B_NLA then
               If pkg_application_gf.gf_ac_perfect_mask_edit(gloval, trax_message_box, this.is_ac, this.dw_eu(i_crow).pn, this.dw_eu(i_crow).position) = 1 then     
                this.iparent.is_errfld := 'pn';
                Return 1;
              End If;
            END IF;
          End If;
          
          --Edit A/C Perfect Mask for 'REMOVE/INSTALL'
          If gloval.gs_status = 'SAVE' and this.is_transaction_type = 'REMOVE/INSTALL' and this.is_perfect = 'Y' and this.is_ACPINSRMV = 'Y' and s_transaction_type = 'INSTALL'  Then
            this.iparent.is_errfld := ' ';
            i_optional := 1;
            IF NOT b_nla THEN
              If pkg_application_gf.gf_ac_perfect_mask_pos_edit(gloval, trax_message_box, this.is_ac, this.dw_eu(i_crow).pn, this.dw_eu(i_crow).position) = 1 then
                this.iparent.is_errfld := 'pn';
                Return 1;
              End If;
            END IF;
          End If;
          
          
          --Edit Transaction Category
          If gloval.gs_status = 'SAVE'  Then
            this.iparent.is_errfld := ' ';
            i_optional := 1;
            if trim(this.dw_eu(i_crow).schedule_category) is null Then
              trax_message_box.s_err_hdr := 'Schedule';
              trax_message_box.s_err_hdr := 'Not valid.';
              this.iparent.is_errfld := 'schedule_category';
              Return 1;
            End If;
          End If;
          
          --Edit Issue To A/C
          If gloval.gs_status = 'SAVE' and s_transaction_type = 'INSTALL'  Then
            this.iparent.is_errfld := ' ';
            s_pn := this.dw_eu(i_crow).pn;  	
            s_sn := this.dw_eu(i_crow).sn;
            this.dw_ac_pn_transaction_check := pkg_dw_ac_pn_tran_check.Retrieve(s_pn, s_sn);
            if this.dw_ac_pn_transaction_check is not null and this.dw_ac_pn_transaction_check.count > 0 Then
              s_ac_issued := this.dw_ac_pn_transaction_check(1).ac; 
              dt_issue_created_date := this.dw_ac_pn_transaction_check(1).created_date; 
              if trim(s_ac_issued) is null Then
                s_ac_issued := ' ';
              End If;
            
              If nvl(s_ac_issued, ' ') <> nvl(this.is_ac, ' ') Then
                
                SELECT count(*)
                INTO l_return_count
                FROM "AC_PN_TRANSACTION_HISTORY"  
                WHERE ( "AC_PN_TRANSACTION_HISTORY"."PN" = s_pn ) And  ( "AC_PN_TRANSACTION_HISTORY"."SN" = s_sn ) AND  
                     ( "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_TYPE" = 'INSTALL' )   AND ("AC_PN_TRANSACTION_HISTORY"."TRANSACTION_DATE" >= dt_issue_created_date) AND
                   ("AC_PN_TRANSACTION_HISTORY"."AC" = s_ac_issued);
                IF l_return_count = 0  then
                  if pkg_application_gf.gf_get_sys_tran_config_flag('PNISSUEACMAND') = 'Y' then
                    trax_message_box.s_err_hdr := 'Warning A/C Issued ' || s_ac_issued;
                    trax_message_box.s_err_msg := 'Not the same as installed A/C.';
                    return 1;
                  else
                    trax_message_box.s_err_hdr := 'Warning A/C Issued ' || s_ac_issued;
                    trax_message_box.s_err_msg := 'Not the same as installed A/C.';
                  end if;
                End if;
              End If;
            End If;
          End If;
          
          --Edit effectivity
          If gloval.gs_status = 'SAVE' and (s_transaction_type = 'INSTALL') Then
            this.iparent.is_errfld := ' ';
            i_optional := 1;
            l_wo := 0;
            
            ms_pn_eff.s_pn := this.dw_eu(i_crow).pn;
            ms_pn_eff.l_wo := l_wo;
            ms_pn_eff.s_ac := this.dw_eu(i_crow).ac;
        
            i_error := pkg_application_gf.gf_pn_effectivity_edit(gloval, trax_message_box, ms_pn_eff, i_optional);
            
            If i_error = 0 Then
        
              If trim(ms_pn_eff.s_message_error1) is not null Then 
                trax_message_box.s_warn_hdr := ms_pn_eff.s_message_error1;
                trax_message_box.s_warn_msg := ms_pn_eff.s_message_error2;
              end if;
        
            ElsIf i_error = 1 Then
              If trim(ms_pn_eff.s_message_answer) is null Then
                this.iparent.is_errfld := 'pn';
                trax_message_box.s_err_hdr := ms_pn_eff.s_message_error1;
                trax_message_box.s_err_msg := ms_pn_eff.s_message_error2;
                Return 1;  	
              Else
                this.iparent.is_errfld := 'pn';
                trax_message_box.s_warn_hdr := ms_pn_eff.s_message_error1;
                trax_message_box.s_warn_hdr := ms_pn_eff.s_message_error2;
              End If;
            End If;
      
          End If;
          
          --check nla effectivity --TODO
--          if this.is_ACCKNLAEFF = 'Y' and gloval.gs_status = 'SAVE' and (this.is_transaction_type = 'INSTALL' or (this.is_transaction_type = 'REMOVE/INSTALL' and i_crow = 2)) then
--            this.iparent.is_errfld := ' ';
--            i_optional := 1;
--            If pkg_application_gf.gf_pn_nla_effectivity_edit(gloval, trax_message_box, i_optional, this.dw_eu(i_crow).pn, this.dw_eu(i_crow).sn, this.dw_eu(i_crow).ac, this.dw_eu(i_crow).ac) = 1 Then
--              this.iparent.is_errfld := 'pn';
--              Return 1;
--            End If;
--          end if;
          
          --check NHA effectivity --TODO
--          if gloval.gs_status = 'SAVE' and s_transaction_type = 'INSTALL' and nvl(this.is_audit,' ') <> 'YES' then 
--            b_nla := false;
--            s_pn := this.dw_eu(i_crow).pn;
--            b_nla := wf_is_nla(this, gloval, trax_message_box, s_pn);
--            if b_nla then 
--              this.iparent.is_errfld := ' ';
--              i_optional := 1;
--              If pkg_application_gf.gf_pn_nha_effectivity_edit(gloval, trax_message_box, i_optional, this.dw_eu(i_crow).pn, this.dw_eu(i_crow).sn) = 1 Then
--                this.iparent.is_errfld := 'pn';
--                Return 1;
--              End If;	
--            end if;
--          end if;
          
        end;
        
        --Edit P/n Restriction
        If gloval.gs_status = 'SAVE' and s_transaction_type = 'INSTALL'  Then
          ms_pn.s_pn := this.dw_eu(i_crow).pn;
          ms_pn.s_ac := this.is_ac;
          If pkg_application_gf.gf_pn_restriction_edit(gloval, trax_message_box, ms_pn) = 1 Then
            this.iparent.is_errfld := 'pn';
            Return 1;
          End If;
        End If;
        
      end loop;
      
    end if;
    
    begin
      
      If gloval.gs_status = 'SAVE' and this.is_transaction_type = 'REMOVE/INSTALL'Then
        
        If wf_installed_remove_edit(this, gloval, trax_message_box) = 1 Then
          
          trax_message_box.s_err_hdr := 'Installed and Removed P/N';
          trax_message_box.s_err_msg := 'Are Not the same or interchangeable.';
          this.iparent.is_errfld := 'pn';
          Return 1;
        End If;
      End If;
      
      this.is_select_nha_pn := null;
      this.is_select_nha_sn := null;
      this.is_select_nha_pos := null;
      
      --Check for any higher assemblies
      If gloval.gs_status = 'SAVE' and this.is_transaction_type = 'INSTALL' and b_nla Then
    
        this.is_select_nha_pn := this.dw_eu(1).nha_pn; 
        this.is_select_nha_sn := this.dw_eu(1).nha_sn; 
        this.is_select_nha_pos := this.dw_eu(1).position;
        this.is_select_nla_pos := this.dw_eu(1).nla_position;
    
    
        if this.is_perfect = 'Y' and (trim(this.is_select_nha_pn) is null or trim(this.is_select_nha_sn) is null) then
          trax_message_box.s_err_hdr := 'Install Only'; 
          trax_message_box.s_err_msg := s_main_pn || ' is an NLA Part, you must choose an NHA';
          this.iparent.is_errfld := 'pn';
          gloval.gi_err := 1;
          Return 1;
        end if;
        
        if trim(this.is_select_nla_pos) is null then this.is_select_nla_pos := rpad(' ', 20); end if;
    
        --if perfect NLA is chosen, check for room on NHA
        if this.is_nla_perfect = 'Y' Then
          if pkg_application_gf.gf_ac_perfect_mask_edit_nla(gloval, trax_message_box, this.dw_eu(1).pn, this.is_select_nha_pn, this.is_select_nha_sn, this.is_select_nla_pos) = 1 then
            this.iparent.is_errfld := 'pn';
            gloval.gi_err := 1;
            Return 1;
          end if;
        end if;
        this.is_select_nha := 'YES';
    
      end if;
      
      If gloval.gs_status = 'SAVE'  and nvl(this.is_audit,' ') <> 'YES' then 
        l_trow := this.dw_eu.Count;
        
        FOR l_crow in 1..l_trow
        loop
          s_pn := this.dw_eu(l_crow).pn;  	
          s_sn := this.dw_eu(l_crow).sn;  	
          
          begin
            SELECT "AC_PN_TRANSACTION_HISTORY"."AC"  
             INTO s_return  
             FROM "AC_PN_TRANSACTION_HISTORY"  
            WHERE ( "AC_PN_TRANSACTION_HISTORY"."PN" = s_pn ) AND  
                ( "AC_PN_TRANSACTION_HISTORY"."SN" = s_sn ) AND  
                ( "AC_PN_TRANSACTION_HISTORY"."STATUS" = 'HOLD' );
            n_sqlcode := sqlcode;
          exception
          when others then
            n_sqlcode := sqlcode;
          end;
          
          If n_sqlcode <> 100 Then
            trax_message_box.s_warn_hdr := 'Warning P/N: ' || s_pn || ' and S/N: ' || s_sn;
            trax_message_box.s_warn_msg := 'Has a current transaction in hold.';
          End If;
        end loop;
      End If;
      
    end;
    
    gloval.gi_err := 0;
    return 0;
    
  end ue_edit;
  
  function wf_installed_remove_edit(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                                    trax_message_box in out nocopy pkg_type_structures.t_trax_message_box) return number
  as
    s_install_pn varchar2(100);
    s_removed_pn varchar2(100);
    s_transaction_type varchar2(100);
    l_rowcount number;
    l_trow number;
    nvo_now pkg_nvo_nha_one_way.nvo_nha_one_way;
  begin
    
    l_rowcount := this.dw_eu.Count;
    s_transaction_type := this.dw_sel(1).transaction_type;
    
    if nvl(l_rowcount, 0) <> 2 and s_transaction_type = 'REMOVE/INSTALL' then
      trax_message_box.s_err_hdr := 'Partial Transaction';
      trax_message_box.s_err_msg := 'Has been performed already. You must choose INSTALL ONLY or REMOVE ONLY for the transaction.';
    end if;
    
    s_removed_pn := this.dw_eu(1).pn;
    s_install_pn := this.dw_eu(2).pn;
    
    If s_removed_pn = s_install_pn Then Return 0; end if;
    
    SELECT "PN_INTERCHANGEABLE"."PN"  
      INTO s_install_pn  
      FROM "PN_INTERCHANGEABLE"  
     WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_install_pn;
  
    SELECT "PN_INTERCHANGEABLE"."PN"  
      INTO s_removed_pn  
      FROM "PN_INTERCHANGEABLE"  
     WHERE "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_removed_pn;
    
    If s_removed_pn = s_install_pn Then Return 0; end if;
    
    pkg_nvo_nha_one_way.of_set_pn(nvo_now, gloval, s_removed_pn );
    l_trow := pkg_nvo_nha_one_way.of_get_one_way_forward(nvo_now, gloval);
    if l_trow > 0 then
      for l_crow in 1..l_trow
      loop
        s_removed_pn := pkg_nvo_nha_one_way.of_get_one_way_pn(nvo_now, gloval, l_crow);
        If s_removed_pn = s_install_pn Then Return 0; end if;
      end loop;
    end if;
    
    pkg_nvo_nha_one_way.of_set_pn_interchangeable(nvo_now, gloval, this.dw_eu(1).pn);
    l_trow := pkg_nvo_nha_one_way.of_get_one_way_forward(nvo_now, gloval);
    if l_trow > 0 then
      for l_crow in 1..l_trow
      loop
        s_removed_pn := pkg_nvo_nha_one_way.of_get_one_way_pn(nvo_now, gloval, l_crow);
        If s_removed_pn = s_install_pn Then Return 0; end if;
      end loop;
    end if;
    
    Return 1;
    
  end wf_installed_remove_edit;
  
  PROCEDURE UE_POSTOPEN(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                        trax_message_box in out nocopy pkg_type_structures.t_trax_message_box)
  AS
  begin
    
    this.is_ACPNDTBK := pkg_application_gf.gf_get_sys_tran_config_flag('ACPNDTBK');
    
    --Load Data 
    IF GLOVAL.GS_MESSAGE_CHECK = 'YES' THEN
      
      THIS.DW_SEL(THIS.DW_SEL.FIRST).WO := THIS.MS_DEFECT_AC_TRANSACTION.WO;
      this.dw_sel(this.dw_sel.first).task_card := this.ms_defect_ac_transaction.task_card;
      THIS.DW_SEL(THIS.DW_SEL.FIRST).AC := THIS.MS_DEFECT_AC_TRANSACTION.AC;
      
      IF THIS.IS_ACPNDTBK = 'N' THEN
        
        THIS.DW_SEL(THIS.DW_SEL.FIRST)."date" := THIS.MS_DEFECT_AC_TRANSACTION.TRANSACTION_DATE;
        
        if THIS.MS_DEFECT_AC_TRANSACTION.TRANSACTION_DATE is null then 
          wf_time(this, gloval, 'INITIAL');
        ELSE
          if this.ms_defect_ac_transaction.transaction_hour is not null  then	this.dw_sel(this.dw_sel.first)."hour" := this.ms_defect_ac_transaction.transaction_hour; end if;
          IF THIS.MS_DEFECT_AC_TRANSACTION.TRANSACTION_MINUTE IS NOT NULL THEN THIS.DW_SEL(THIS.DW_SEL.FIRST)."minute" := THIS.MS_DEFECT_AC_TRANSACTION.TRANSACTION_MINUTE; END IF;
        END IF;
        
      END IF;
      
      this.dw_sel(this.dw_sel.first).defect_type := this.ms_defect_ac_transaction.defect_type;
      THIS.DW_SEL(THIS.DW_SEL.FIRST).DEFECT := THIS.MS_DEFECT_AC_TRANSACTION.DEFECT;
      this.dw_sel(this.dw_sel.first).defect_item := this.ms_defect_ac_transaction.defect_item;
      THIS.DW_SEL(THIS.DW_SEL.FIRST)."station" := THIS.MS_DEFECT_AC_TRANSACTION.STATION;
      
      If trim(this.ms_defect_ac_transaction.transaction_type) is not null Then
        this.dw_sel(this.dw_sel.first).transaction_type := this.ms_defect_ac_transaction.transaction_type;
      end if;
      
      this.dw_sel(this.dw_sel.first).task_card_pn := this.ms_defect_ac_transaction.task_card_pn;
      this.dw_sel(this.dw_sel.first).task_card_sn := this.ms_defect_ac_transaction.task_card_sn;
    
      gloval.gs_message_check := '';
    
      --Auto Removal Installed
      if this.ms_defect_ac_transaction.auto_remove_intalled = 'YES' then
        this.dw_sel(this.dw_sel.FIRST).transaction_type := this.ms_defect_ac_transaction."FUNCTION";
        return;
      End If;
      
      --Update Item On Hold
      IF this.ms_defect_ac_transaction."AUDIT" = 'YES' THEN  
        this.is_audit := 'YES';
        UE_NEW(this, gloval, trax_message_box);
      End If;
    
    ELSE
      
      IF this.IS_ACPNDTBK = 'N' THEN
        wf_time(this, gloval, 'INITIAL');
      END IF;
      
    END IF;
    
  end ue_postopen;
  
  procedure ue_open(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                    trax_message_box IN out nocopy pkg_type_structures.t_trax_message_box,
                    message AC_PN_TRNS_HIST_TRNS_STRUCT%ROWTYPE)
  AS
  BEGIN
    ue_setup_control(this, gloval);
    pkg_w_standard_eu.ue_open(this.iparent, gloval);
    this.ib_pn_check := FALSE;
    this.ms_defect_ac_transaction := Message;
    ue_postopen(this, gloval, trax_message_box);
  end ue_open;
  
  PROCEDURE ue_setup_control(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables)
  AS
  begin
    
    this.is_tech_only := pkg_application_gf.gf_get_sys_tran_config_flag('TECHONLY');
    this.is_acpneditrot := pkg_application_gf.gf_get_sys_tran_config_flag('ACPNEDITROT');
    this.is_acpnedit := pkg_application_gf.gf_get_sys_tran_config_flag('ACPNEDIT');
    this.is_print_us_tag := pkg_application_gf.gf_get_sys_tran_config_flag('REVUNS');
    this.is_asblychk := pkg_application_gf.gf_get_sys_tran_config_flag('ASBLYCHK');
    this.is_perfect := pkg_application_gf.gf_get_sys_tran_config_flag('ACPERFCT');
    this.is_nla_perfect := pkg_application_gf.gf_get_sys_tran_config_flag('NLAPERF');
    this.is_rmvrtsauto := pkg_application_gf.gf_get_sys_tran_config_flag('RMVRTSNT');
    this.is_station_mandatory := pkg_application_gf.gf_get_sys_tran_config_flag('ACPNSTA');
    this.is_ACPINSRMV := pkg_application_gf.gf_get_sys_tran_config_flag('ACPINSRMV');
    this.is_pn_eo_removal := pkg_application_gf.gf_get_sys_tran_config_flag('WOPNECDEL');
    this.is_remservchk := pkg_application_gf.gf_get_sys_tran_config_flag('REMSERVCHK');
    this.is_ACPNTRANSPKG := pkg_application_gf.gf_get_sys_tran_config_flag('ACPNTRANSPKG');
    IF (this.is_rmvrtsauto = 'Y') THEN this.is_remservchk := 'N'; END IF;
    this.is_ACCKNLAEFF := pkg_application_gf.gf_get_sys_tran_config_flag('ACCKNLAEFF');
    this.is_ACPNTRSNDD := pkg_application_gf.gf_get_sys_tran_config_flag('ACPNTRSNDD');
    this.is_DFSCPREMVL := pkg_application_gf.gf_get_sys_tran_config_flag('DFSCPREMVL');
    
  end ue_setup_control;
  
  
  function WF_NHA_PN_SN_VALIDATION(THIS in OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, GLOVAL in OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES, S_NHA_PN_ENT varchar2, S_NHA_SN_ENT varchar2) return number
  as
    s_return varchar2(100);
  begin
  
    SELECT "PN_INVENTORY_DETAIL"."PN"  
    INTO s_return  
    FROM "PN_INVENTORY_DETAIL"  
    where ("PN_INVENTORY_DETAIL"."PN" = S_NHA_PN_ENT) and  
      ("PN_INVENTORY_DETAIL"."SN" = S_NHA_SN_ENT) and  
      ("PN_INVENTORY_DETAIL"."INSTALLED_AC" = this.ims_pn.s_installed_ac);
        
    if S_RETURN is null then 
      return 1;
    end if;
    
    Return 0;
  end WF_NHA_PN_SN_VALIDATION;
  
  function WF_CHECK_ETOPS_CONSIST_ASSEMBL(THIS in OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, 
                                          GLOVAL in OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES, 
                                          TRAX_MESSAGE_BOX in OUT NOCOPY PKG_TYPE_STRUCTURES.T_TRAX_MESSAGE_BOX, 
                                          S_NHA_PN varchar2, S_NHA_SN varchar2) return number
  as
    S_ETOPS varchar2(200);
    S_ETOPS_DOWNGRADE varchar2(200);
    S_AC varchar2(200);
    L_CROW number;
    L_TROW number;
    D_DATA PKG_DW_ALL_INV_ASSEMBL_TMP_TBL.TT_DW_ALL_INV_ASSEMBL_TMP_TBL;
    S_PN varchar2(200);
    s_etops_flag varchar2(200);
  begin
    
    s_ac := this.dw_sel(this.dw_sel.first).ac;

    SELECT "AC_MASTER"."ETOPS",
                 NVL("AC_MASTER"."ETOPS_DOWNGRADE",'NO') 
    into S_ETOPS, S_ETOPS_DOWNGRADE
    from "AC_MASTER"  
    where "AC_MASTER"."AC" = S_AC;
    
    if S_ETOPS is null then 
      return 0;
    end if;
    
    pkg_function_inventory.load_assemply_information(s_nha_pn,s_nha_sn,1);
    
    --// get assembly
    d_data := pkg_DW_ALL_INV_ASSEMBL_TMP_TBL.retrieve;
    
    if d_data is null and d_data.count > 0 then
      for L_CROW in D_DATA.first..D_DATA.last
        loop
          
          s_pn := d_data(l_crow).pn;
          
          SELECT NVL("PN_INTERCHANGEABLE"."ETOPS_FLAG",'ALL')
          INTO s_etops_flag
          from "PN_MASTER",   
                 "PN_INTERCHANGEABLE"  
          WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_MASTER"."PN" ) and  
                   ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn)); 
         
          if s_etops_flag = 'NO' then
            if S_ETOPS_DOWNGRADE = 'NO' then
              TRAX_MESSAGE_BOX.S_ERR_HDR := 'A/C Etops';
              TRAX_MESSAGE_BOX.S_ERR_MSG := 'This Assembly Contains None ETOPS Authorized P/N';
              return 1;		
            else 
              TRAX_MESSAGE_BOX.S_INFO_HDR := 'A/C Etops';
              TRAX_MESSAGE_BOX.S_INFO_MSG := 'This Assembly Contains None ETOPS Authorized P/N';
              return 0;
            end if;
          end if;	 
      end LOOP;
    end if;

  return 0;
  end WF_CHECK_ETOPS_CONSIST_ASSEMBL;
  
  
  function WF_SWAP_EDIT(THIS in OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, GLOVAL in OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES) return number
  as
    S_PN1 varchar2(200); 
    S_SN1 varchar2(200); 
    S_PN2 varchar2(200);
    S_SN2 varchar2(200);
    S_POS1 varchar2(200);
    S_POS2 varchar2(200);
    S_PN_MAIN1 varchar2(200);
    S_PN_MAIN2 varchar2(200);
    S_PN_TEMP varchar2(200);
    NVO_NOW PKG_NVO_NHA_ONE_WAY.NVO_NHA_ONE_WAY;
    L_CROW number;
    L_TROW number;
    DW_EDIT PKG_DW_AC_PN_TRAN_HISTORY_EU.TT_DW_AC_PN_TRAN_HISTORY_EU;
    B_INTERCHANGEABLE BOOLEAN;
    S_ALL_PN PKG_TYPE_STRUCTURES.TT_STRING;
    s_null pkg_type_structures.tt_string;
  begin 
  
    DW_EDIT := THIS.DW_EU;
    
    if DW_EDIT.COUNT = 2 then
      S_PN1 := DW_EDIT(1).PN;
      S_SN1 := DW_EDIT(1).SN;
      S_POS1 := DW_EDIT(1).POSITION;
      S_PN2 := DW_EDIT(2).PN;
      S_SN2 := DW_EDIT(2).SN;
      s_pos2 := dw_edit(2).position;
    
      if S_SN1 is null or S_SN2 is null or S_SN1 <= '0' or S_SN2 <= '0' then 
        return 0;
      end if;
      
      SELECT PI."PN"
      INTO   s_pn_main1
      from   "PN_INTERCHANGEABLE" PI
      WHERE  PI."PN_INTERCHANGEABLE"  = s_pn1;
      
      SELECT PI."PN"
      INTO   s_pn_main2
      FROM   "PN_INTERCHANGEABLE" PI
      WHERE  PI."PN_INTERCHANGEABLE"  = s_pn2;
      
      if s_pn_main1 = s_pn_main2 then return 0; end if;
      
      B_INTERCHANGEABLE := false;

      pkg_nvo_nha_one_way.of_get_pn_found_all_coma_delim(nvo_now, gloval, s_pn_main1, 'FOWARD', s_all_pn);
      
      if S_ALL_PN is not null and S_ALL_PN.COUNT > 0 then
        for L_CROW in S_ALL_PN.first..S_ALL_PN.last
          LOOP
            s_pn_temp := s_all_pn(l_crow);
            if S_PN_TEMP = S_PN_MAIN2 then
              B_INTERCHANGEABLE := true;
              EXIT;
            end if;
         end loop;
      end if;
      
      s_all_pn := s_null;
      
      if not B_INTERCHANGEABLE then
        pkg_nvo_nha_one_way.OF_GET_PN_FOUND_ALL_COMA_DELIM(NVO_NOW, gloval, S_PN_MAIN1, 'BACK', S_ALL_PN);
        
        if S_ALL_PN is not null and S_ALL_PN.COUNT > 0 then
          for L_CROW in S_ALL_PN.first..S_ALL_PN.last
            loop
              s_pn_temp := s_all_pn(l_crow);
              if S_PN_TEMP = S_PN_MAIN2 then
                B_INTERCHANGEABLE := true;
                EXIT;
              end if;
           end loop;	
        end if;
      end if;
      
      if (not B_INTERCHANGEABLE) and NVL(S_PN1,'') <> NVL(S_PN_MAIN1,'') then
        s_all_pn := s_null;
        
        pkg_nvo_nha_one_way.OF_GET_PN_FOUND_ALL_COMA_DELIM(NVO_NOW, gloval, S_PN_MAIN2, 'FOWARD', S_ALL_PN);
        
        if S_ALL_PN is not null and S_ALL_PN.COUNT > 0 then 
          for L_CROW in S_ALL_PN.first..S_ALL_PN.last
          LOOP
            s_pn_temp := s_all_pn(l_crow);
            if S_PN_TEMP = S_PN_MAIN1 then
              b_interchangeable := true;
              EXIT;
            end if;
          end loop;
        end if;
          
        if not B_INTERCHANGEABLE then
          S_ALL_PN := S_NULL;	
          pkg_nvo_nha_one_way.of_get_pn_found_all_coma_delim(nvo_now, gloval, s_pn_main2,'BACK',s_all_pn);
          
          if S_ALL_PN is not null and S_ALL_PN.COUNT > 0 then 
            for L_CROW in S_ALL_PN.first..S_ALL_PN.last
            LOOP
              s_pn_temp := s_all_pn(l_crow);
              if S_PN_TEMP = S_PN_MAIN1 then
                B_INTERCHANGEABLE := true;
                EXIT;
              end if;
            end loop;
          end if;
        end if;
      End If;
      
      if B_INTERCHANGEABLE then return 0; end if;
      return 1;
  end if;

  return 0;
    
  end WF_SWAP_EDIT;
  
  
  ------------------------FUNCTION wf_is_nla -----------------------------
  FUNCTION wf_is_nla(this IN OUT NOCOPY T_W_AC_PN_TRAN_HISTORY_EU, 
                    gloval IN OUT NOCOPY PKG_GLOBAL_VARIABLES.T_GLOBAL_VARIABLES, 
                    TRAX_MESSAGE_BOX in OUT NOCOPY PKG_TYPE_STRUCTURES.T_TRAX_MESSAGE_BOX,
                    s_pn IN OUT NOCOPY VARCHAR2) 
                    RETURN BOOLEAN
                    
  AS
  s_return VARCHAR2(20);
  s_main_pn "PN_INVENTORY_DETAIL"."PN"%TYPE;
  s_pn_temp "PN_INVENTORY_DETAIL"."PN"%TYPE;
  s_temp_nha "PN_INVENTORY_DETAIL"."PN"%TYPE;
  s_temp_sn "PN_INVENTORY_DETAIL"."SN"%TYPE;
  s_ac VARCHAR2(20);
  b_from_nha BOOLEAN := FALSE;
  l_return NUMBER := 0;
  l_trow NUMBER;
  l_crow NUMBER;
  l_ac_pos_count NUMBER;
  NVO_NOW PKG_NVO_NHA_ONE_WAY.NVO_NHA_ONE_WAY;
  
  
  BEGIN 
  SELECT COUNT(*)
  INTO l_return
  FROM "PN_INTERCHANGEABLE",   
      "PN_NEXT_LOWER_ASSEMBLY"  
  WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_NEXT_LOWER_ASSEMBLY"."NLA_PN" )   
        AND( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn ) ) 
        AND
        --Sergio Log#74914 12/03/2007
        "PN_NEXT_LOWER_ASSEMBLY"."RECORDS_TYPE" <> 'KIT';
        --End Sergio
  
  
  IF l_return > 0 THEN
    b_from_nha := TRUE;
  END IF;
  

  l_trow := pkg_nvo_nha_one_way.of_get_one_way_back(nvo_now, gloval);
  
  FOR l_crow IN 1..l_trow
  LOOP
    
    s_pn_temp := pkg_nvo_nha_one_way.of_get_next(nvo_now, gloval);
    
    SELECT count(*)  
    INTO l_return  
    FROM "PN_INTERCHANGEABLE",   
         "PN_NEXT_LOWER_ASSEMBLY"  
    WHERE ( "PN_INTERCHANGEABLE"."PN" = "PN_NEXT_LOWER_ASSEMBLY"."NLA_PN" )   
        	AND ( ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn_temp ) ) 
          --Sergio Log#74914 12/03/2007
          AND "PN_NEXT_LOWER_ASSEMBLY"."RECORDS_TYPE" <> 'KIT';
          --End Sergio
    
    IF l_return > 0 THEN
      b_from_nha := TRUE;
      EXIT;
    END IF;
  END LOOP;
  
  
  IF b_from_nha = TRUE THEN
    s_ac := this.dw_sel(1).ac;

	  SELECT count(*)  
    INTO l_ac_pos_count  
    FROM "PN_POSITION_DISTRIBUTION",
		          "PN_INTERCHANGEABLE"
		WHERE  ( "PN_INTERCHANGEABLE"."PN" = "PN_POSITION_DISTRIBUTION"."PN" )  
           AND ( "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn )
				   AND ( "PN_POSITION_DISTRIBUTION"."AC" = s_ac );    
           
    l_ac_pos_count := nvl(l_ac_pos_count, 0);
    
    IF l_ac_pos_count > 0 AND nvl(this.is_audit, '') <> 'YES' THEN
      IF this.is_pn_prev <> s_pn THEN
        IF trax_message_box.S_QUESTION_MSG = 'P/N Install, This part can be installed directly on the A/C or as part of an assembly. ' || '~n~r' || 'Is this part going to be installed as part of an assembly?' THEN  
          b_from_nha := FALSE;
          this.ib_make_it_and_nla_part := FALSE;
        ELSE
          this.ib_make_it_and_nla_part := TRUE;
        END IF;
      ELSE
        IF NOT this.ib_make_it_and_nla_part THEN
          b_from_nha := FALSE;
        END IF;
      END IF;
      this.is_pn_prev := s_pn;
    END IF;
  END IF;
  
  --JPSANCHEZ  LOG91579  03-31-2009
  if nvl(this.is_audit, ' ' ) = 'YES' then
    IF nvl(this.dw_eu(1).nha_pn, ' ') <> ' ' THEN 
      b_from_nha := TRUE;
    END IF;
  END IF;
  --END  LOG91579
  
  this.is_pn_prev := s_pn;
  
  RETURN b_from_nha;
  END wf_is_nla;
  
  function wf_edit_main (this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables, trax_message_box in out nocopy pkg_type_structures.t_trax_message_box, ss_ac in out nocopy varchar2, S_CAT in out nocopy varchar2) return number                 
  as
    dt_sysdate date;
    s_defect_type varchar2(32000);
    s_defect varchar2(32000);
    s_task_card  varchar2(32000);
    s_return varchar2(32000);
    s_trn varchar2(32000);
    l_wo number;
    l_trn number := 0;
    l_defect_item number;
    i_irow number;
    i_optional number; 
    s_errfld varchar2(32000) := ' ';
    dt_flight date;
    d_date date; 
    dt_flight_next_day date;
    l_off_hr number;
    l_off_min number; 
    l_ldg_hour number; 
    l_ldg_min number;
    --datetime dt_fl_start, dt_fl_end
    dt_fl_start date;
    dt_fl_end date;
    n_sqlcode number := 0;
    s_ac varchar(32000);
    dt_z_date date;
    s_type varchar2(32000);
    s_field varchar2(32000);
    s_station varchar(32000);
    s_category varchar(32000);
    s_fld varchar2(32000);
    s_fldnam varchar2(32000);
   
     
    type rt_ac_actual_flights is record(flight_date "AC_ACTUAL_FLIGHTS"."FLIGHT_DATE"%type,   
             flight_next_day "AC_ACTUAL_FLIGHTS"."FLIGHT_DATE"%type,
             off_hour "AC_ACTUAL_FLIGHTS"."OFF_HOUR"%type,   
             off_minute "AC_ACTUAL_FLIGHTS"."OFF_MINUTE"%type,   
             on_hour "AC_ACTUAL_FLIGHTS"."ON_HOUR"%type, 
             ON_MINUTE "AC_ACTUAL_FLIGHTS"."ON_MINUTE" %type);
      
    type tt_AC_ACTUAL_FLIGHTS is table of rt_AC_ACTUAL_FLIGHTS;
    t_AC_ACTUAL_FLIGHTS tt_AC_ACTUAL_FLIGHTS;
    
    cursor dcl_cur is 
    select "AC_ACTUAL_FLIGHTS"."FLIGHT_DATE",   
             ("AC_ACTUAL_FLIGHTS"."FLIGHT_DATE" + 1),
             "AC_ACTUAL_FLIGHTS"."OFF_HOUR",   
             "AC_ACTUAL_FLIGHTS"."OFF_MINUTE",   
             "AC_ACTUAL_FLIGHTS"."ON_HOUR", 
             "AC_ACTUAL_FLIGHTS"."ON_MINUTE" 
    from     "AC_ACTUAL_FLIGHTS"  
    where    "AC_ACTUAL_FLIGHTS"."AC" = this.is_ac   and
             ("AC_ACTUAL_FLIGHTS"."FLIGHT_DATE" = d_date or
             "AC_ACTUAL_FLIGHTS"."FLIGHT_DATE" = d_date - 1);
    
  begin
    i_optional := 1;
    if wf_ac_edit(this, gloval, trax_message_box, i_optional, ss_ac) = 1 then
      s_errfld := 'ac'; 
      return 1;   	
    end if; 
    
    s_errfld := ' ';
    this.il_hour := this.dw_sel(this.dw_sel.first)."hour";
    this.il_minute := this.dw_sel(this.dw_sel.first)."minute";
    this.idt_date := pkg_application_function.getcombineddate(this.dw_sel(this.dw_sel.first)."date", this.il_hour, this.il_minute); 
    dt_sysdate := pkg_application_gf.gf_get_sysdate;

    if this.idt_date is null or (this.idt_date > dt_sysdate) then
      if this.idt_date is null then
        trax_message_box.s_err_hdr := 'Invalid  Date/Time';
        trax_message_box.s_err_msg := 'DateTime is null';
        --MessageBox("Invalid  Date/Time", "DateTime is null", Stopsign!)		
      elsif this.idt_date > dt_sysdate then
        trax_message_box.s_err_hdr := 'Invalid Date/Time';
        trax_message_box.s_err_msg := TO_CHAR(this.idt_date) || ' can not be greater than current system time.';
        --MessageBox("Invalid Date/Time", string(idt_date) + " can not be greater than current system time.", Stomine froze right nowpsign!)		
      end if;
      --dw_sel.SetColumn('date')
      s_errfld := 'date';
      --dw_sel.SetFocus()
      Return 1;
    end if;
    this.is_ac := this.dw_sel(this.dw_sel.first).ac;
    if pkg_application_gf.gf_get_sys_tran_config_flag('INFLTTRA') <> 'N' then
      d_date := this.idt_date;
        
      open dcl_cur;
      fetch dcl_cur bulk collect into t_AC_ACTUAL_FLIGHTS;
      close dcl_cur;  
      
      if t_AC_ACTUAL_FLIGHTS is not null and t_AC_ACTUAL_FLIGHTS.count >0 then
        for i in t_AC_ACTUAL_FLIGHTS.first..t_AC_ACTUAL_FLIGHTS.last
        loop
         
          dt_fl_start := pkg_application_function.getCombinedDate(t_AC_ACTUAL_FLIGHTS(i).flight_date, t_ac_actual_flights(i).off_hour, t_AC_ACTUAL_FLIGHTS(i).off_minute);
          if (t_AC_ACTUAL_FLIGHTS(i).on_hour < t_ac_actual_flights(i).off_hour) or (t_AC_ACTUAL_FLIGHTS(i).on_hour = t_ac_actual_flights(i).off_hour and t_AC_ACTUAL_FLIGHTS(i).ON_MINUTE < t_AC_ACTUAL_FLIGHTS(i).off_minute) then
            dt_fl_end := pkg_application_function.getCombinedDate(t_AC_ACTUAL_FLIGHTS(i).flight_next_day, t_AC_ACTUAL_FLIGHTS(i).on_hour, t_AC_ACTUAL_FLIGHTS(i).ON_MINUTE);
          else
            dt_fl_end := pkg_application_function.getCombinedDate(t_AC_ACTUAL_FLIGHTS(i).flight_date, t_AC_ACTUAL_FLIGHTS(i).on_hour, t_AC_ACTUAL_FLIGHTS(i).ON_MINUTE);
          end if;
          
          if this.idt_date < dt_fl_end and this.idt_date > dt_fl_start then
            trax_message_box.s_err_hdr := 'Invalid Date and Time';
            trax_message_box.s_err_msg := 'Cannot schedule a transaction for that AC at that time';     
            --MessageBox('Invalid Date and Time' ,'Cannot schedule a transaction for that AC at that time',StopSign!)         
            return 1;
          end if;
           
        end loop;
      end if;       
    end if;
 
    s_ac := this.dw_sel(this.dw_sel.first).ac;
    begin
      select "AC_ACTUAL_FLIGHTS"."FLIGHT_DATE"  
      into   dt_z_date  
      from   "AC_ACTUAL_FLIGHTS"  
      where  ("AC_ACTUAL_FLIGHTS"."AC" = s_ac) 
      and    ("AC_ACTUAL_FLIGHTS"."FLIGHT_LOG" = 'z');
      n_sqlcode := sqlcode;
    exception
    when others then
    n_sqlcode := sqlcode;
    end;

    if (this.idt_date < dt_z_date) then
      trax_message_box.s_err_hdr := 'Transaction Date';
      trax_message_box.s_err_msg := 'Is Less than "Z" records date.';   
      --MessageBox('Transaction Date', 'Is Less than "Z" records date.', STOPSIGN!)
      --dw_sel.SetColumn('date')
      --dw_sel.SetFocus()
      s_errfld := 'date'; 
      return 1;    
    end if; 		

    --// Edit Time
    if (this.dw_sel(this.dw_sel.first)."hour")is null
        or this.dw_sel(this.dw_sel.first)."minute" is null 
        or this.dw_sel(this.dw_sel.first)."hour" > 24 
        or this.dw_sel(this.dw_sel.first)."minute" > 59
        or this.dw_sel(this.dw_sel.first)."hour" < 0 
        or this.dw_sel(this.dw_sel.first)."minute" < 0 then
      
      trax_message_box.s_err_hdr := 'Time';
      trax_message_box.s_err_msg := 'Not Valid.';     
      --messagebox('Time', 'Not Valid.', stopsign!)
      --dw_sel.SetColumn('hour')
      --dw_sel.SetFocus()
      s_errfld := 'hour'; 
      return 1;  
    End If; 
		
    --Edit Station
    s_errfld := ' ';
    i_optional := 0;
    if this.is_station_mandatory = 'Y' or this.is_rmvrtsauto = 'Y' then
      i_optional := 1;
    else
      i_optional := 0;
    end if;
 
    s_type := 'STATION/MAINTENANCE';
    s_field := 'station';
   
    if pkg_application_gf.gf_location_edit(this.dw_sel(this.dw_sel.first)."station",i_optional,s_type, trax_message_box.s_question_hdr, trax_message_box.s_question_msg,
                                           trax_message_box.S_ERR_HDR, trax_message_box.S_ERR_MSG) = 1 then
      s_errfld := 'station'; 
      return 1;   
    end if;
    
    if this.is_rmvrtsauto = 'Y' and instr((this.dw_sel(this.dw_sel.first).transaction_type),'REMOVE') >0 then
      s_station := this.dw_sel(this.dw_sel.first)."station";
      begin
        SELECT "LOCATION_MASTER"."AUTOMATED_REMOVAL_LOCATION",   
               "LOCATION_MASTER"."QUARANTINE_RELATED_BIN",
               "LOCATION_MASTER"."QUARANTINE_US_CODE"
        into   this.is_auto_quarantine_location,
               this.is_auto_quarantine_bin,
               this.is_auto_quarantine_us_code 
        from "LOCATION_MASTER"  
        where "LOCATION_MASTER"."LOCATION" = s_station;
        n_sqlcode := sqlcode;
      exception
      when others then
      n_sqlcode := sqlcode;
      end;
    
      if (this.is_auto_quarantine_location is null) or this.is_auto_quarantine_location <= '0' then
        trax_message_box.s_question_hdr := 'Auto Return To Stock switch (RMVRTSNT) is set to YES';
        trax_message_box.s_question_msg := 'No Automatic Removal Quarantine location information. No Quarantine Related Location is set up for Station: ' ||s_station || ', do you want to select a Quarantine Location?';
      end if;
  
      if (this.is_auto_quarantine_bin is null) or this.is_auto_quarantine_bin <= '0' then
        trax_message_box.s_question_hdr := 'Auto Return To Stock switch (RMVRTSNT) is set to YES';
        trax_message_box.s_question_msg := 'No Quarantine Default Bin is set up for Station: ' || s_station || ', do you want to select a Quarantine Bin for Location:'|| this.is_auto_quarantine_location ||' ?' ;
      end if;
  
      if (this.is_auto_quarantine_us_code is null) or this.is_auto_quarantine_us_code <= '0' then
        trax_message_box.s_question_hdr := 'Auto Return To Stock switch (RMVRTSNT) is set to YES';
        trax_message_box.s_question_msg := ' No Default Unserviceable code is set up for Station: ' ||s_station || ', do you want to select a Default Unserviceable code ?';
      end if;
    end if; 
    --// Defect Type
    s_errfld := ' ';
    i_optional := 0;
    s_category := 'DEFECTTYPE';
    s_fldnam := 'defect_type';
    
    if pkg_application_gf.gf_category_edit(S_CAT,i_optional,s_category,s_fldnam,trax_message_box.s_err_hdr,trax_message_box.s_err_msg) = 1 then
      s_errfld := 'defect_type'; 
      return 1;    	
    End If;
    --// Defect 
    s_errfld := ' ';
    i_optional := 100;  
    if pkg_application_gf.gf_defect_reports_edit( 'Dw_Ac_Pn_Tran_History_Sel', null, this.dw_sel(this.dw_sel.first).ac, null, this.dw_sel(this.dw_sel.first).defect_type, this.dw_sel(this.dw_sel.first).defect, this.dw_sel(this.dw_sel.first).defect_item, i_optional,gloval, trax_message_box) = 1 then
      s_errfld := 'defect'; 
      return 1;    	
    End If; 
    
    --// W/O
    s_errfld := ' ';
    
    if this.is_ac_ownership_control = 'TPO' then
      i_optional := 1;
    else
      i_optional := 0;
    End if;
   
    if pkg_application_gf.gf_wo_edit(this.dw_sel(this.dw_sel.first).wo, gloval,trax_message_box, i_optional) = 1 then
      s_errfld := 'wo'; 
      return 1;    	
    End If;
    
    l_wo := this.dw_sel(this.dw_sel.first).wo;
    begin
      select "WO"."AC"  
      into   s_ac  
      from   "WO"  
      where  "WO"."WO" = l_wo;
      n_sqlcode := sqlcode;
    exception
    when others then
    n_sqlcode := sqlcode;
    end;

    if (s_ac is not null) and s_ac > '0' then
      if nvl(s_ac,' ') <> nvl(this.is_ac,' ') then
        trax_message_box.s_err_hdr := 'W/O A/C';
        trax_message_box.s_err_msg := 'Not the same as A/C selected.';     
        --MessageBox('W/O A/C', 'Not the same as A/C selected.', STOPSIGN!)
        --dw_sel.SetColumn('ac')
        --dw_sel.SetFocus()
        s_errfld := 'ac'; 
        return 1;    
      end if;
    End If;
    
    --// Task Card
    s_errfld := ' ';
    s_fld :='task_card';
    i_optional := 0;
    
    if pkg_application_gf.gf_wo_task_card_edit(this.dw_sel(this.dw_sel.first).task_card, l_wo, gloval,trax_message_box,i_optional) = 1 then
      s_errfld := 'task_card'; 
      return 1;    	
    end if;
    
    if this.is_defectorwo <> 'N' then
      s_defect_type := nvl(this.dw_sel(this.dw_sel.first).defect_type,' ');
      s_defect := nvl(this.dw_sel(this.dw_sel.first).defect,' ');
      l_defect_item := nvl(this.dw_sel(this.dw_sel.first).defect_item,0);
      s_task_card := nvl(this.dw_sel(this.dw_sel.first).task_card,' ');
      l_wo := nvl(l_wo,0);
    
      if (l_wo = 0 or s_task_card = ' ') and (s_defect_type=' ' or s_defect=' ' or l_defect_item = 0) then
        trax_message_box.s_err_hdr := 'Defect and W/O';
        trax_message_box.s_err_msg := 'One must be selected.';   
        --MessageBox('Defect and W/O', 'One must be selected.',STOPSIGN!)
        --dw_sel.SetColumn('defect_type')
        --dw_sel.SetFocus()
        s_errfld := 'defect_type'; 
        return 1;    
      end if;	
    end if;	
  return 0;
  end wf_edit_main;
  
  function wf_ac_edit(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables, trax_message_box in out nocopy pkg_type_structures.t_trax_message_box, optional in out nocopy number, ss_ac in out nocopy varchar2) return number
  as
    s_status varchar2(100);
    s_ac varchar2(100);
    s_ac_tear_down varchar2(100);
    s_customer varchar2(100);
    n_sqlcode number :=0;
  begin
    --passed in as a parameter.
    --s_ac = dw.GetItemString(dw.GetRow(), 'ac')
    s_ac := ss_ac;
    if optional = 0  and (s_ac < '0' or s_ac is null) then  
      Return 0;      
    end if;
    begin
      SELECT "AC_MASTER"."STATUS",   
      "AC_MASTER"."AC_TEAR_DOWN",   
      "AC_MASTER"."AC_OWNERSHIP_CONTROL",
      "AC_MASTER"."CUSTOMER"
      INTO s_status,   
      s_ac_tear_down,   
      this.is_ac_ownership_control,
      s_customer
      from "AC_MASTER"  
      where "AC_MASTER"."AC" =s_ac;   
      
      If s_ac_tear_down is null then  
        s_ac_tear_down := 'NO';
      end if;
      n_sqlcode := sqlcode;
    exception
    when others then
      n_sqlcode := sqlcode;
    end; 
    if  optional = 100 then
      if n_sqlcode <> 100 then
        trax_message_box.s_err_hdr := 'A/C';
        trax_message_box.s_err_msg := 'Already exists.';   
        -- messagebox('A/C', 'Already exists.',stopsign!)
        -- dw.setcolumn('ac')
        -- dw.setfocus()
        return  1;  
      end if; 	
    else	
      if n_sqlcode = 100 then
        trax_message_box.s_err_hdr := 'A/C';
        trax_message_box.S_Err_Msg := 'Not found.';  
        --  MessageBox('A/C','Not found.',STOPSIGN!)
        --  dw.SetColumn('ac')
        --  dw.SetFocus()
        return  1;  
      end if; 
      
      if nvl(s_status,' ') <> 'ACTIVE' then 
        if s_ac_tear_down = 'NO' then
          trax_message_box.s_err_hdr := 'A/C';
          trax_message_box.s_err_msg := 'Not active.'; 
          --MessageBox('A/C','Not active.',STOPSIGN!)
          --dw.SetColumn('ac')
          --dw.SetFocus()
          return  1;  
        else
          trax_message_box.S_INFO_HDR := 'A/C';
          trax_message_box.S_INFO_MSG := 'Not active but tear down flag is on. Removal Only Transaction allowed.';         
          --MessageBox('A/C','Not active but tear down flag is on. Removal Only Transaction allowed.')
          this.is_transaction_type := 'REMOVE';
          --dw.SetItem(1,'transaction_type','REMOVE')
          
        end if;
      end if;
    end if;  
    if this.is_ac_ownership_control = 'TPO' then   
      --dw_sel.object.wo_t.font.weight = 800
      begin
        select "RELATION_MASTER"."EMPLOYEE_CONTRACTOR"  
        INTO this.is_tpo_owner  
        from "RELATION_MASTER"  
        where ( "RELATION_MASTER"."RELATION_TRANSACTION" = 'CUSTOMER' ) 
        and ( "RELATION_MASTER"."RELATION_CODE" = s_customer );
        n_sqlcode := sqlcode;
      exception
      when others then
        n_sqlcode := sqlcode;
      end;
    else
    /*  if this.is_defectorwo = 'N' then
        dw_sel.object.wo_t.font.weight = 400
      end if;	*/
      this.is_tpo_owner := null;
    end if;
    return 0;
    
  end wf_ac_edit;
  function wf_edit_tpo(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables, trax_message_box in out nocopy pkg_type_structures.t_trax_message_box) return number
  as
    s_pn varchar2(100);
    s_sn varchar2(100);
    s_return varchar2(100);
    s_transaction_type varchar2(100);
    s_position varchar2(100);
    s_nla_pos varchar2(100);
    s_ac_installed varchar2(100);
    s_etops varchar2(100);
    s_etops_flag varchar2(100);
    s_sch_cat varchar2(100);
    s_main_pn varchar2(100);
    s_sni varchar2(100);
    dt_installed_date date;
    l_installed_hour number;
    l_installed_minute number; 
    d_qty_available number;
    d_qty_reserved number;
    d_qty_in_transfer number;
    d_qty_pending_ri number;
    d_qty_in_repair number;
    d_qty_in_rental number;
    d_us number;
    s_owner varchar2(100);
    s_position_nla varchar2(100); 
    i_optional number;
    i_trow number;
    i_crow number;
    l_crow number;
    l_trow number;
    i_idx number;
    n_sqlcode number :=0;
    dt_removal_date date;
    l_removal_hour number;
    l_removal_minute number;
    dt_inst date;
    dt_remv date;
    nvo_now pkg_nvo_nha_one_way.nvo_nha_one_way;
    s_category varchar2(100);
    s_type varchar(100);
    s_ac_issued varchar(100);
    dw_ac_pn_transaction_check pkg_dw_ac_pn_tran_check.tt_dw_ac_pn_tran_check;
    s_cat varchar2(100);
  begin
    --// Grey out 'position' field for 'INSTALL' if PN is a NLA
    if this.is_transaction_type = 'INSTALL' and this.is_perfect = 'Y' then
      s_pn := this.dw_eu(this.dw_eu.first).pn;
      if wf_is_nla(this,gloval,trax_message_box, s_pn) then
        null;	
      else
        null;
      end if;	
    end if;   
    --// Edit Only At Save button
    if this.is_acpnedit  = 'Y'and  gloval.gs_status <> 'SAVE' then 
      return 0;
    end if;
    
    if this.dw_eu is null or this.dw_eu.count = 0 then
      return 1;
    end if;
    
    i_trow := this.dw_eu.count;
    i_crow := 1;
    
    while (true)
    loop
      
      s_transaction_type := this.dw_eu(i_crow).transaction_type;
      --// Edit P/N	
      if this.iparent.is_fldnam = 'pn' or gloval.gs_status = 'SAVE' then
        this.iparent.is_errfld := ' ';
        i_optional := 1000;
        if pkg_application_gf.gf_pn_edit(s_pn,i_optional,'ALL',trax_message_box.s_question_hdr,trax_message_box.s_question_msg,trax_message_box.s_err_hdr,trax_message_box.s_err_msg) = 1 then
          this.iparent.is_errfld := 'pn';
          --tab_hd.SelectTab(1)
          return  1;  	
        end if;
        
        begin
        s_pn := this.dw_eu(i_crow).pn; 
        s_sn := this.dw_eu(i_crow).sn; 
      
          SELECT "PN_MASTER"."ETOPS",   
          "PN_MASTER"."ETOPS_FLAG"  
          INTO s_etops,   
          s_etops_flag  
          FROM "PN_INTERCHANGEABLE",   
          "PN_MASTER"  
          where ("PN_MASTER"."PN" = "PN_INTERCHANGEABLE"."PN") and  
          (("PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn));
          n_sqlcode := sqlcode;
        exception
        when others then
          n_sqlcode := sqlcode;
        end;
  
        if s_etops_flag = 'YES' and  s_transaction_type = 'INSTALL' then
          trax_message_box.s_question_hdr := 'Warning P/N ' || s_pn || ' S/N ' || s_sn  || ' is ETOPs Controlled';
          trax_message_box.s_question_msg := 'Do you want to continue? ';
        end if;
      end if;
      --// Edit S/N	
      if this.iparent.is_fldnam = 'sn' or gloval.gs_status = 'SAVE' then	
        this.iparent.is_errfld := ' ';
        s_pn := this.dw_eu(i_crow).pn; 
        s_sn := this.dw_eu(i_crow).sn; 
        if(s_sn is null) or s_sn < '0' then
          trax_message_box.s_err_hdr := 'S/N';
          trax_message_box.s_err_msg := 'Not Valid.';
          --messagebox('S/N', 'Not Valid.', stopsign!)
          --tab_hd.tabpage_gen.dw_eu.SetColumn('sn')
          --tab_hd.tabpage_gen.dw_eu.SetFocus()
          --tab_hd.tabpage_gen.dw_eu.ScrollToRow(i_crow)
          this.iparent.is_errfld := 'sn';
          --tab_hd.SelectTab(1)
          return  1;  
        elsif ((s_pn is null) or s_pn < '0' )and  ((s_sn is not null) or s_sn > '0') then
          trax_message_box.s_err_hdr := 'P/N';
          trax_message_box.s_err_msg := 'Must enter P/N first.';
          --messagebox('P/N', 'Must enter P/N first.', stopsign!)
          --tab_hd.tabpage_gen.dw_eu.SetColumn('pn')
          --tab_hd.tabpage_gen.dw_eu.SetFocus()
          --tab_hd.tabpage_gen.dw_eu.scrolltorow(i_crow)
          this.iparent.is_errfld := 'pn'; 
          --tab_hd.SelectTab(1)
          this.dw_eu(i_crow).sn := ' ';
          --tab_hd.tabpage_gen.dw_eu.setitem(i_crow, 'sn', ' ')
          return  1;  
        end if;
           
        begin  
          SELECT "PN_INVENTORY_DETAIL"."INSTALLED_AC",   
          "PN_INVENTORY_DETAIL"."INSTALLED_POSITION",   
          "PN_INVENTORY_DETAIL"."INSTALLED_DATE",   
          "PN_INVENTORY_DETAIL"."INSTALLED_HOUR",   
          "PN_INVENTORY_DETAIL"."INSTALLED_MINUTE",   
          "PN_INVENTORY_DETAIL"."QTY_AVAILABLE",   
          "PN_INVENTORY_DETAIL"."QTY_RESERVED",   
          "PN_INVENTORY_DETAIL"."QTY_IN_TRANSFER",   
          "PN_INVENTORY_DETAIL"."QTY_PENDING_RI",
          "PN_INVENTORY_DETAIL"."QTY_IN_REPAIR",
          "PN_INVENTORY_DETAIL"."QTY_IN_RENTAL",
          "PN_INVENTORY_DETAIL"."QTY_US",
          "PN_INVENTORY_DETAIL"."OWNER",
          "PN_INVENTORY_DETAIL"."NLA_POSITION"
          INTO s_ac_installed,   
          s_position,   
          dt_installed_date,   
          l_installed_hour,   
          l_installed_minute,   
          d_qty_available,   
          d_qty_reserved,   
          d_qty_in_transfer,   
          d_qty_pending_ri,
          d_qty_in_repair,
          d_qty_in_rental,
          d_us,
          s_owner,
          s_position_nla
          FROM "PN_INVENTORY_DETAIL"  
          where ( "PN_INVENTORY_DETAIL"."PN" = s_pn ) and  
          ( "PN_INVENTORY_DETAIL"."SN" = s_sn );   
          n_sqlcode := sqlcode;
        exception
        when others then
        n_sqlcode := sqlcode;
        end;
    
        If this.is_ac_ownership_control = 'TPO' and n_sqlcode = 100 Then
          if  s_transaction_type = 'INSTALL' then
            s_ac_installed := null; 
            dt_installed_date := null;
            l_installed_hour := null;
            l_installed_minute := null;
          else
            s_ac_installed := this.is_ac; 
            s_position := 'ONLY';
            dt_installed_date := this.idt_date;
            l_installed_hour := 00;
            l_installed_minute :=  00; 
          End If;
          
          d_qty_available := 0;   
          d_qty_reserved := 0;   
          d_qty_in_transfer := 0;   
          d_qty_pending_ri := 0;
          d_qty_in_repair := 0;
          d_qty_in_rental := 0;
          d_us := 0; 
          s_owner := this.is_tpo_owner;
          s_position_nla := null;
          n_sqlcode := sqlcode; 
        end if;
  
        dt_installed_date := pkg_application_function.getcombineddate(dt_installed_date, l_installed_hour,l_installed_minute);
        this.idt_date := pkg_application_function.getcombineddate(this.idt_date,this.il_hour,this.il_minute);
  
        if (d_qty_in_rental is null) then
            d_qty_in_rental := 0;
        end if;
        
        if n_sqlcode = 100 and ((nvl(this.is_transaction_type,' ') <> 'EXCHANGE') and s_transaction_type = 'INSTALL')  then
          if gloval.gs_status = 'SAVE' then
            trax_message_box.s_err_hdr := 'P/N and  S/N';
            trax_message_box.s_err_msg := 'Not Found.';
            --Messagebox('P/N and  S/N', 'Not Found.', STOPSIGN! )
          else
            trax_message_box.s_question_hdr := 'P/N and  S/N';
            trax_message_box.s_question_msg := 'Not Found. Do you want to continue.';
          End If;
          this.iparent.is_errfld := 'sn';
          return 1;  
        end if;
    
        if n_sqlcode <> 100 and this.is_transaction_type = 'EXCHANGE' and s_transaction_type = 'INSTALL' then
          if gloval.gs_status = 'SAVE' then
            trax_message_box.s_err_hdr := 'P/N and  S/N';
            trax_message_box.s_err_msg := 'Already Exists.';
          else
            trax_message_box.s_question_hdr := 'P/N and  S/N';
            trax_message_box.s_question_msg := 'Already Exists. Do you want to continue.';
          End If;		
          this.iparent.is_errfld := 'sn';
          return  1;  
        End If; 
  
        if s_transaction_type = 'INSTALL'and nvl(this.is_transaction_type,' ') <> 'EXCHANGE' and nvl(this.is_transaction_type,' ') <> 'SWAP' then
        --// Check For Tech Only
          if nvl(this.is_tech_only,'N') <> 'Y' then
            if (d_qty_available + d_qty_reserved + d_qty_in_transfer + d_qty_pending_ri + d_qty_in_repair + d_qty_in_rental + d_us) > 0 then
              If gloval.gs_status = 'SAVE' Then
                trax_message_box.s_err_hdr := 'P/N and  S/N';
                trax_message_box.s_err_msg := 'Has not been issued.';
                --Messagebox('P/N and  S/N', 'Has not been issued.', STOPSIGN!)
              else
                trax_message_box.s_question_hdr := 'P/N and  S/N';
                trax_message_box.s_question_msg := 'Has not been issued. Do you want to continue.';
              End If;		
              this.iparent.is_errfld := 'sn';
              return  1;  
            end if;
          End If;
  
          --// Check For Tech Only                 ojo
          If nvl(this.is_tech_only,'N') <> 'Y' Then
            if trim(s_ac_installed) is not null then
              if gloval.gs_status = 'SAVE' then
                trax_message_box.s_err_hdr := 'P/N and  S/N';
                trax_message_box.s_err_msg := 'Is Already Installed On A/C: ' || s_ac_installed;
              else
                trax_message_box.s_question_hdr := 'P/N and  S/N';
                trax_message_box.s_question_msg := 'Is Already Installed On A/C: ' || s_ac_installed || ' Do you want to continue.';
              end if;
              this.iparent.is_errfld := 'sn';
              return  1;  
            end if;
          End If;
          --// Check For Last Installed Date
          if s_transaction_type = 'INSTALL' then 
            wf_removal_check_date(this, gloval, trax_message_box, s_pn, s_position);
          end if;
          --//Check if the part will be available at the given date
          dt_removal_date := null;	
          l_removal_hour := null;
          l_removal_minute := null;
          
          begin
            SELECT "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_DATE",   
            "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_HOUR",   
            "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_MINUTE"  
            INTO dt_removal_date,   
            l_removal_hour,   
            l_removal_minute  
            FROM "AC_PN_TRANSACTION_HISTORY"  
            WHERE ( "AC_PN_TRANSACTION_HISTORY"."PN" = s_pn ) AND  
            ( "AC_PN_TRANSACTION_HISTORY"."SN" = s_sn ) AND  
            ( "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_TYPE" like 'REMOVE' )         
            ORDER BY "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_DATE" DESC,   
            "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_HOUR" desc,   
            "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_MINUTE" desc;
            n_sqlcode := sqlcode;
          exception
          when others then
            n_sqlcode := sqlcode;
          end;
  
          if (dt_removal_date is not null) then
            dt_remv := pkg_application_function.getcombineddate(dt_removal_date, l_removal_hour, l_removal_minute );
            dt_inst := pkg_application_function.getcombineddate(this.idt_date , this.il_hour, this.il_minute);
            if ( dt_inst < dt_remv ) then						
              if gloval.gs_status = 'SAVE' then
                trax_message_box.s_err_hdr := 'P/N and  S/N';
                trax_message_box.s_err_msg := 'Install date is prior to last removal date.';
                --Messagebox('P/N and S/N', 'Install date is prior to last removal date.' ,STOPSIGN!)
              else
                trax_message_box.s_err_hdr := 'P/N and  S/N';
                trax_message_box.s_err_msg := 'Install date is prior to last removal date.';
                --messagebox('P/N and S/N', 'Install date is prior to last removal date.', stopsign!) 
                return 0;
              End If;					
              --tab_hd.tabpage_gen.dw_eu.setcolumn('sn')
              --tab_hd.tabpage_gen.dw_eu.setfocus()
              --tab_hd.tabpage_gen.dw_eu.ScrollToRow(i_crow)
              this.iparent.is_errfld := 'sn';
              --tab_hd.selecttab(1)
              return  1;  	
            end if;-- // idt_date < dt_removal_date
          end if;-- //not isnull( dt_removal_date )			
        end if;
      
        if s_transaction_type = 'REMOVE' or this.is_transaction_type = 'SWAP' then
        --// Check For Tech Only
          if nvl(this.is_tech_only,'N') <> 'Y' then
            if nvl(this.is_ac,' ') <> nvl(s_ac_installed,' ') or (s_ac_installed is null) then
              if gloval.gs_status = 'SAVE' then
                trax_message_box.s_err_hdr := 'P/N and S/N';
                trax_message_box.s_err_msg := 'Not installed on A/C.';
                --Messagebox('P/N and S/N', 'Not installed on A/C.', STOPSIGN!)
              else
                trax_message_box.s_question_hdr := 'P/N and S/N';
                trax_message_box.s_question_msg := 'Not installed on A/C. Do you want to continue.';
              end if;
              this.iparent.is_errfld := 'sn';
              return  1;  	
            End If; 
  
            if this.idt_date < dt_installed_date then
              if gloval.gs_status = 'SAVE' then
                trax_message_box.s_err_hdr := 'P/N and  S/N';
                trax_message_box.s_err_msg := 'Removal date is prior to installed date.';
              else
                trax_message_box.s_question_hdr := 'P/N and S/N';
                trax_message_box.s_question_msg := 'Removal date is prior to installed date. Do you want to continue.';
              End If;
              this.iparent.is_errfld := 'sn';
              return  1;  	
            end if;
          end if; 
          this.dw_eu(1).position := s_position;
          if this.is_transaction_type = 'REMOVE/INSTALL' or  this.is_transaction_type = 'EXCHANGE'then
            this.dw_eu(2).position := s_position;
          end if;
        end if;
      end if;
    
      --// Load position
      If this.is_transaction_type = 'SWAP' Then
        if s_transaction_type = 'REMOVE'  then
          this.dw_eu(2).position := s_position;
        else
          this.dw_eu(1).position := s_position;
        end if;
      end if;
      --// Assembly Control--TODO
--      if this.is_asblychk = 'Y' and gloval.gs_status = 'SAVE' and  s_transaction_type = 'INSTALL'  then
--        if (this.dw_eu(i_crow).sn is not null) then
--          s_pn := this.dw_eu(i_crow).pn;
--          s_sn := this.dw_eu(i_crow).sn;
--          pkg_nvo_nha_one_way.of_set_pn(nvo_now, gloval, s_pn);
--          if pkg_nvo_nha_one_way.of_check_incomplete(nvo_now, gloval, s_pn, s_sn) then
--            trax_message_box.s_err_hdr := 'P/N and S/N';
--            trax_message_box.s_err_msg := 'Not a perfect assembly.';
--            this.iparent.is_errfld := 'sn';
--            return 1;  	
--          end if;
--        end if;
--      end if;
      --// Check Reason Category
      if this.iparent.is_fldnam = 'reason_category' or gloval.gs_status = 'SAVE' then
        this.iparent.is_errfld := ' ';
        i_optional := 0;		
        if pkg_application_gf.gf_get_sys_tran_config_flag('IN/RVMAD') = 'Y' then 
          i_optional := 1;
        end if;
        s_category := 'REASONCATEGORY';
        this.iparent.is_fldnam := 'reason_category';
        if pkg_application_gf.gf_category_edit(this.dw_eu(i_crow).reason_category,i_optional,s_category,this.iparent.is_fldnam, trax_message_box.s_err_hdr, trax_message_box.s_err_msg) = 1 then
          this.iparent.is_errfld := 'reason_category';
          return 1;  	
        End If;
        s_cat := this.dw_eu(i_crow).reason_category;
        begin
          SELECT NVL("SYSTEM_TRAN_CODE"."REMOVAL_TYPE",' ')  
          INTO s_type  
          FROM "SYSTEM_TRAN_CODE"  
          where ( "SYSTEM_TRAN_CODE"."SYSTEM_TRANSACTION" = 'REASONCATEGORY' ) and  
          ( "SYSTEM_TRAN_CODE"."SYSTEM_CODE" = s_cat );
          n_sqlcode := sqlcode;
        exception
        when others then
          n_sqlcode := sqlcode;
        end;
  
        if s_type > '0' then
          this.dw_eu(i_crow).schedule_category := s_type;
        end if;
        
        if this.is_transaction_type = 'SWAP'  then 
          this.dw_eu(i_crow).schedule_category := 'SWAP';
        end if;
        --// Edit A/C Perfect Mask
        if gloval.gs_status = 'SAVE' and this.is_transaction_type = 'INSTALL' and this.is_perfect = 'Y' then
          this.iparent.is_errfld := ' ';
          i_optional := 1;
          if not wf_is_nla( this, gloval, trax_message_box, this.dw_eu(i_crow).pn ) then
            if pkg_application_gf.gf_ac_perfect_mask_edit(gloval, trax_message_box, this.is_ac,this.dw_eu(i_crow).pn,this.dw_eu(i_crow).position) = 1 then
              this.iparent.is_errfld := 'pn';
              return 1;  	
            end if;
          end if;
        end if;
        --// Edit Transaction Category
        if gloval.gs_status = 'SAVE'  then
          this.iparent.is_errfld := ' ';
          i_optional := 1;
          if (this.dw_eu(i_crow).schedule_category is null) or this.dw_eu(i_crow).schedule_category < '0' then
            trax_message_box.s_err_hdr := 'Schedule';
            trax_message_box.s_err_msg := 'Not valid.';
            this.iparent.is_errfld := 'schedule_category';
            return 1;  	
          end if;
        end if;
        --// Edit Issue To A/C
        if gloval.gs_status = 'SAVE' and s_transaction_type = 'INSTALL'  then
          this.iparent.is_errfld := ' ';
          
          if (pkg_dw_ac_pn_tran_check.retrieve((this.dw_eu(i_crow).pn),(this.dw_eu(i_crow).sn)) is not null) 
          and (pkg_dw_ac_pn_tran_check.retrieve((this.dw_eu(i_crow).pn),(this.dw_eu(i_crow).sn)).count > 0) 
          then
            dw_ac_pn_transaction_check := pkg_dw_ac_pn_tran_check.retrieve((this.dw_eu(i_crow).pn),(this.dw_eu(i_crow).sn));
            s_ac_issued := dw_ac_pn_transaction_check(dw_ac_pn_transaction_check.first).ac;
          end if;
          if s_ac_issued is null then
            s_ac_issued := ' ';
          end if;
          if nvl(s_ac_issued,' ') <> nvl(this.is_ac,' ') then
            if pkg_application_gf.gf_get_sys_tran_config_flag('PNISSUEACMAND') = 'Y' then
              trax_message_box.s_err_hdr := 'Warning A/C Issued ' || s_ac_issued;
              trax_message_box.s_err_msg := 'Not the same as installed A/C.';
              return 1;
            else
              trax_message_box.s_warn_hdr := 'Warning A/C Issued ' || s_ac_issued;
              trax_message_box.s_warn_msg := 'Not the same as installed A/C.';
            end if;
          end if;
        end if;
      end if;
   
      if ((gloval.gs_status = 'SAVE') and (i_trow > i_crow)) then
        i_crow := i_crow + 1;
      else
        exit;
      end if;
    end loop;
    
    this.is_select_nha_pn := null;
    this.is_select_nha_sn := null; 
    this.is_select_nha_pos := null;
    If gloval.gs_status = 'SAVE'  and nvl(this.is_audit,' ') <> 'YES' then 
      if this.dw_eu is not null and (this.dw_eu.count > 0) then
        for l_crow in this.dw_eu.first..this.dw_eu.last
        loop
          s_pn := this.dw_eu(l_crow).pn;  	
          s_sn := this.dw_eu(l_crow).sn;  	
          begin
            SELECT "AC_PN_TRANSACTION_HISTORY"."AC"  
            INTO s_return  
            from "AC_PN_TRANSACTION_HISTORY"  
            WHERE ( "AC_PN_TRANSACTION_HISTORY"."PN" = s_pn ) AND  
            ( "AC_PN_TRANSACTION_HISTORY"."SN" = s_sn ) and  
            ( "AC_PN_TRANSACTION_HISTORY"."STATUS" = 'HOLD');
            n_sqlcode := sqlcode;
          exception
          when others then
            n_sqlcode := sqlcode;
          end;
          if n_sqlcode <> 100 then
            trax_message_box.s_question_hdr := 'Warning P/N: ' || s_pn ||' and S/N: ' || s_sn;
            trax_message_box.s_question_msg := 'Has a current transaction in hold.  Do you want to continue?';
          end if;
        end loop;
      end if;
    end if;
    gloval.gi_err := 0;
    return 0;
  end wf_edit_tpo;
 
  procedure wf_removal_check_date(this in out nocopy t_w_ac_pn_tran_history_eu, gloval in out nocopy pkg_global_variables.t_global_variables, trax_message_box in out nocopy pkg_type_structures.t_trax_message_box, s_pn varchar2, s_position varchar2)
  as
    l_transaction_hour number;
    l_transaction_minute number;
    dt_transaction_date date;
    s_pn_main varchar2(100);
    n_sqlcode number := 0;
    
    type rt_ac_pn_transaction_history is record(TRANSACTION_DATE "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_DATE"%type,
      TRANSACTION_HOUR "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_HOUR"%type,   
      TRANSACTION_MINUTE "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_MINUTE"%type);
      
    type tt_ac_pn_transaction_history is table of RT_ac_pn_transaction_history;
    t_ac_pn_transaction_history tt_ac_pn_transaction_history;
    
    CURSOR dcl_control is 
    SELECT "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_DATE",   
    "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_HOUR",   
    "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_MINUTE"  
    FROM "AC_PN_TRANSACTION_HISTORY",   
    "PN_INTERCHANGEABLE"  
    where ( "AC_PN_TRANSACTION_HISTORY"."PN" = "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" ) 
    and (( "PN_INTERCHANGEABLE"."PN" = s_pn_main ) 
    and ( "AC_PN_TRANSACTION_HISTORY"."AC" = this.is_ac ) 
    and ( "AC_PN_TRANSACTION_HISTORY"."POSITION" = s_position ))
    ORDER BY "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_DATE" ASC,   
    "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_HOUR" asc,   
    "AC_PN_TRANSACTION_HISTORY"."TRANSACTION_MINUTE" asc;  
  
  begin
    if(s_position is null) then 
      return;
    end if;
    
    begin
      SELECT "PN_INTERCHANGEABLE"."PN"  
      INTO s_pn_main  
      from "PN_INTERCHANGEABLE"  
      where "PN_INTERCHANGEABLE"."PN_INTERCHANGEABLE" = s_pn; 
    exception
    when others then
    n_sqlcode := sqlcode;
    end;

    open dcl_control;
    fetch dcl_control bulk collect into t_AC_PN_TRANSACTION_HISTORY;
    close dcl_control;
    
    if t_ac_pn_transaction_history is not null and t_ac_pn_transaction_history.count >0 then
      for i in t_ac_pn_transaction_history.first..t_ac_pn_transaction_history.last
      loop
         dt_transaction_date := t_ac_pn_transaction_history(i).transaction_date;
         l_transaction_hour  := t_ac_pn_transaction_history(i).transaction_hour;
         l_transaction_minute := t_ac_pn_transaction_history(i).TRANSACTION_MINUTE;
      end loop;
    end if;
    
    if this.idt_date < dt_transaction_date then
      trax_message_box.s_warn_hdr := 'Warning';
      trax_message_box.s_warn_msg := 'The last removal date is less than the current install date for this P/N and Position.';   
      --messagebox('Warning','The last removal date is less than the current install date for this P/N and Position.')
    elsif (this.idt_date = dt_transaction_date) and ((this.il_hour * 100) + this.il_minute) < ((l_transaction_hour * 100) + l_transaction_minute) then
      trax_message_box.s_warn_hdr := 'Warning';
      trax_message_box.s_warn_msg := 'The last removal time is less than the current install time for this P/N and Position.';   
      --messagebox('Warning','The last removal time is less than the current install time for this P/N and Position.')
    end if;
    
  end wf_removal_check_date;
  
  
    PROCEDURE ue_hold(this IN out nocopy t_w_ac_pn_tran_history_eu, gloval IN out nocopy pkg_global_variables.t_global_variables,
                    trax_message_box in out nocopy pkg_type_structures.t_trax_message_box)
    as
    b_dont_hold boolean := false ; 
    begin
      if this.dw_eu is not null and this.dw_eu.count > 0 then
      
        for i_crow in this.dw_eu.first..this.dw_eu.last
        loop
          THIS.DW_EU(i_crow).STATUS := 'HOLD'; 
          THIS.DW_EU(i_crow).CREATED_BY := GLOVAL.GS_USER;
          THIS.DW_EU(i_crow).CREATED_DATE := THIS.IDT_DATE;
          THIS.DW_EU(i_crow).MODIFIED_BY := GLOVAL.GS_USER;
          THIS.DW_EU(i_crow).MODIFIED_DATE := PKG_APPLICATION_GF.GF_GET_SYSDATE;
          
            --if switch is ON then 
        
          declare
          s_transaction ac_pn_transaction_history.transaction%type; 
          l_transaction_item  ac_pn_transaction_history.transaction_item%type; 
          s_flag varchar2(10 char); 
          begin
          
            s_flag := PKG_APPLICATION_FUNCTION.CONFIG_FLAG('MROREMVP') ; 
            
          --  s_flag := 'Y' ; 
          
            if  nvl(s_flag , 'N') = 'Y' then 
           
            select transaction , transaction_item
            into s_transaction , l_transaction_item
            from ac_pn_transaction_history
            where status = 'PENDING' and
            TASK_CARD = THIS.DW_EU(i_crow).TASK_CARD and
            TASK_CARD_PN = THIS.DW_EU(i_crow).TASK_CARD_PN and
            TASK_CARD_SN = THIS.DW_EU(i_crow).TASK_CARD_SN and
            WO = THIS.DW_EU(i_crow).WO  and
            "POSITION" = THIS.DW_EU(i_crow).POSITION ; 
            
            THIS.DW_EU(i_crow).STATUS := 'CLOSED'; 
            THIS.DW_EU(i_crow).transaction :=   s_transaction ; 
            THIS.DW_EU(i_crow).transaction_item := l_transaction_item    ;  
          
            
            end if; 
            
          exception when NO_DATA_FOUND then 
           null; 
          end ;    
          
          end loop ;
     
        
         pkg_dw_ac_pn_tran_history_eu.gf_save(this.dw_eu);    
         
       
      end if;   
    end ue_hold; 
  
end pkg_w_ac_pn_tran_history_eu;

/


create or replace 
package pkg_window_printing_jobs as
  
  function get_next_job return number;

  procedure add_job(l_job number);
  
  function get_next_ios_job return number;
  
  procedure add_ios_job(l_job number);

end pkg_window_printing_jobs;

/

create or replace 
package body pkg_window_printing_jobs as

  function get_next_job return number
  as
    l_job number := 0;
    message_id      raw(16);
    message sys.aq$_jms_text_message;
    message_text varchar2(100);
    dequeue_options     dbms_aq.dequeue_options_t;
		message_properties  dbms_aq.message_properties_t;
    ex_timeout        exception;
    pragma exception_init(ex_timeout, -25228);
  begin
    begin
      dequeue_options.wait := 0;
      dequeue_options.dequeue_mode := dbms_aq.remove;
      dbms_aq.dequeue(
        queue_name          => 'WINDOW_PRINTING_JOBS_Q',
        dequeue_options     => dequeue_options,
        message_properties  => message_properties,
        payload             => message,
        msgid               => message_id);
  
        message.get_text(message_text);
        l_job := to_number(trim(message_text));
    exception
        when ex_timeout then
          l_job := 0;
        when others then
          raise_application_error(-20111, sqlerrm, true);
    end;
    return l_job;
  end get_next_job;

  procedure add_job(l_job number)
  as
    enqueue_options     dbms_aq.enqueue_options_t;
		message_properties  dbms_aq.message_properties_t;
		message_handle      raw(16);
    message sys.aq$_jms_text_message;
  begin
    message := sys.aq$_jms_text_message.construct;
    message_properties.delay := dbms_aq.no_delay;
    message.set_text(l_job);

		dbms_aq.enqueue(
		    queue_name          => 'WINDOW_PRINTING_JOBS_Q',
		    enqueue_options     => enqueue_options,
		    message_properties  => message_properties,
		    payload             => message,
		    msgid               => message_handle);
  exception
    when others then
      raise_application_error(-20111, sqlerrm, true);
  end add_job;
  
  
  function get_next_ios_job return number
  as
    l_job number := 0;
    message_id      raw(16);
    message sys.aq$_jms_text_message;
    message_text varchar2(100);
    dequeue_options     dbms_aq.dequeue_options_t;
		message_properties  dbms_aq.message_properties_t;
    ex_timeout        exception;
    pragma exception_init(ex_timeout, -25228);
  begin
    begin
      dequeue_options.wait := 0;
      dequeue_options.dequeue_mode := dbms_aq.remove;
      dbms_aq.dequeue(
        queue_name          => 'IOS_PRINTING_JOBS_Q',
        dequeue_options     => dequeue_options,
        message_properties  => message_properties,
        payload             => message,
        msgid               => message_id);
  
        message.get_text(message_text);
        l_job := to_number(trim(message_text));
    exception
        when ex_timeout then
          l_job := 0;
        when others then
          raise_application_error(-20111, sqlerrm, true);
    end;
    return l_job;
  end get_next_ios_job;
  
  
  procedure add_ios_job(l_job number)
  as
    enqueue_options     dbms_aq.enqueue_options_t;
		message_properties  dbms_aq.message_properties_t;
		message_handle      raw(16);
    message sys.aq$_jms_text_message;
  begin
    message := sys.aq$_jms_text_message.construct;
    message_properties.delay := dbms_aq.no_delay;
    message.set_text(l_job);

		dbms_aq.enqueue(
		    queue_name          => 'IOS_PRINTING_JOBS_Q',
		    enqueue_options     => enqueue_options,
		    message_properties  => message_properties,
		    payload             => message,
		    msgid               => message_handle);
  exception
    when others then
      raise_application_error(-20111, sqlerrm, true);
  end add_ios_job;

end pkg_window_printing_jobs;
/



/

  CREATE OR REPLACE PACKAGE "PKG_WEB_REST" AS
  s_web_server VARCHAR2(150) := null;
  s_ros_web_server VARCHAR2(150) := null;
  s_lht_web_server VARCHAR2(150) := null;
  s_iconnector_web_server VARCHAR2(150) := null;
  i_port PLS_INTEGER := 80;

  PROCEDURE getWebInfo;
  PROCEDURE getLhtWebInfo;
  PROCEDURE getLhtWebServer;

  procedure sendMessage(
    s_parameter IN VARCHAR2,
    s_return OUT NOCOPY VARCHAR2);

  procedure sendRosMessage(
    s_parameter IN VARCHAR2,
    s_return OUT NOCOPY VARCHAR2);
  
  procedure sendEosMessage(
    s_parameter IN VARCHAR2,
    S_RETURN OUT NOCOPY varchar2);

  procedure sendOsMessage(
    s_parameter IN VARCHAR2,
    S_RETURN OUT NOCOPY varchar2,
    p_transaction_type in varchar2);


  function sendLHTMessage(
    s_parameter IN VARCHAR2) return VARCHAR2;

  procedure sendAC_TAT;

  procedure sendAddCounter2JobCall;

  Function getCaseBank_RestService return varchar2;

  -- send case bank message via rest service
  Procedure CaseBank_Send(
    s_operation In varchar2,
    l_transaction In Number,
    s_return Out varchar2);

  Function CaseBank_Spotlight(s_operation In varchar2, l_transaction In Number) Return VARCHAR2;

  procedure test_casebank;

  FUNCTION sendLHTMessage_BLOB
  (
    s_parameter IN VARCHAR2,
    s_content_type OUT VARCHAR2
  ) RETURN BLOB;

  function sendLHTMessage_TEXT(S_PARAMETER in varchar2) return varchar2;
    
  Procedure SendMcmMessage(s_Transaction varchar2);
  Procedure SendMcmSTAR;
  
  --Jing Huang 198869 10/28/2015
  function sendIconnectorMessage(
    s_parameter IN VARCHAR2 ,  s_path IN varchar2) return VARCHAR2;
    
  function call_wpl_api(
    s_parameter IN VARCHAR2 , s_path IN varchar2) return VARCHAR2;
    
  procedure syncEmobilityQueue( contentData VARCHAR2, messageType IN varchar2) ;

END PKG_WEB_REST;


/

create or replace PACKAGE BODY "PKG_WEB_REST" AS

  -- Jing Huang 136626 02/08/2012
  PROCEDURE getWebInfoMultiCompany(p_parameter in varchar2);
  -- 136626
  
  FUNCTION getWebServerAddress(config_xml in xmltype, server_name in varchar2)
  RETURN VARCHAR2
  AS
    s_web_server varchar2(200);
    l_len number;
    s_char varchar2(1);

  BEGIN
    IF (config_xml is not null and length(config_xml.getStringVal()) > 0) THEN
      s_web_server := "PKG_BLOB_FUNCTION".getElementValueFromXml(config_xml, server_name);
      l_len := length(s_web_server);
      s_char := substr(s_web_server, l_len, 1);

      if s_char = '/' then
        s_web_server := substr(s_web_server, 1, l_len - 1);
      end if;
    END IF;
    return s_web_server;
  END getWebServerAddress;

  -- get server, authentication information from profile masterSet_Header
  PROCEDURE getWebInfo AS
    s_char VARCHAR2(10);
    l_len INTEGER;
  BEGIN
    SELECT P."SPEC2000_WEB_SERVER_ADDRESS"
    INTO s_web_server
    FROM "PROFILE_MASTER" P
    WHERE 1=1
    AND (PKG_TRAX_SESSION.f_getprofile = P."PROFILE" OR (SELECT P2."PROFILE"
                                                       FROM "PROFILE_MASTER" P2
                                                       WHERE P2."PROFILE" = PKG_TRAX_SESSION.f_getprofile) IS NULL)
      AND nvl(length(P."SPEC2000_WEB_SERVER_ADDRESS"), 0) > 0
      AND ROWNUM = 1;

    s_web_server := trim(s_web_server);
    l_len := length(s_web_server);
    s_char := substr(s_web_server, l_len, 1);

    if s_char = '/' then
      s_web_server := substr(s_web_server, 1, l_len - 1);
    end if;
  EXCEPTION
    WHEN no_data_found THEN
      s_web_server := null;
      i_port := 80;
    NULL;
  END getWebInfo;

  -- get server, authentication information from profile master
  -- Jing Huang 151389 12-11-2012
  PROCEDURE getOsWebInfo (p_transaction_type in varchar2) AS
    s_char VARCHAR2(10);
    L_LEN integer;
    CONFIG_XML xmltype;
    s_profile "PROFILE_MASTER"."PROFILE"%TYPE;
  begin
    if instr(p_transaction_type, 'ROS') > 0 then
      s_profile := PKG_ROS_COMMON.GET_PROFILE_DEFAULT;
      SELECT P."ROS_CONFIG"
        INTO CONFIG_XML
        FROM "PROFILE_MASTER" P
       WHERE "PROFILE" = s_profile;
       
      S_ROS_WEB_SERVER := GETWEBSERVERADDRESS(CONFIG_XML, 'ros_WebServer_Address');
    elsif instr(p_transaction_type, 'EOS') > 0 then
      s_profile := PKG_EOS_COMMON.GET_PROFILE_DEFAULT;
      SELECT P."EOS_CONFIG"
        INTO CONFIG_XML
        FROM "PROFILE_MASTER" P
       WHERE "PROFILE" = s_profile;
       
      S_ROS_WEB_SERVER := GETWEBSERVERADDRESS(CONFIG_XML, 'eos_WebServer_Address');
    elsif instr(p_transaction_type, 'XOS') > 0 then
      s_profile := PKG_EOS_COMMON.GET_PROFILE_DEFAULT;
      SELECT P."SUPPLIER_EOS_CONFIG"
        INTO CONFIG_XML
        FROM "PROFILE_MASTER" P
       WHERE "PROFILE" = s_profile;
       
      S_ROS_WEB_SERVER := GETWEBSERVERADDRESS(CONFIG_XML, 'eos_WebServer_Address');
    end if;
  EXCEPTION
    WHEN others THEN
      s_ros_web_server := null;
      i_port := 80;
    null;
  end GETOSWEBINFO;
  

  -- get server, authentication information from profile master
  PROCEDURE getLhtWebInfo AS
    s_char VARCHAR2(10);
    l_len INTEGER;
    lht_config_xml PROFILE_MASTER."ROS_CONFIG"%TYPE;
  BEGIN
    SELECT P."MATERIAL_REQUEST_CONFIG"
    INTO lht_config_xml
    FROM "PROFILE_MASTER" P
    WHERE 1=1
    AND (PKG_TRAX_SESSION.f_getprofile = P."PROFILE" OR (SELECT P2."PROFILE"
                                                       FROM "PROFILE_MASTER" P2
                                                       WHERE P2."PROFILE" = PKG_TRAX_SESSION.f_getprofile) IS NULL)
    AND ROWNUM = 1;

    s_lht_web_server := getWebServerAddress(lht_config_xml, 'trax_WebServer_Address');
  EXCEPTION
    WHEN no_data_found THEN
      s_lht_web_server := null;
      i_port := 80;
    NULL;
  END getLhtWebInfo;

    -- get server, authentication information from TRAX_GLOBAL_FILES
  PROCEDURE getLhtWebServer AS
    s_char VARCHAR2(10);
    l_len INTEGER;
    lht_config_xml xmltype;
  Begin
    lht_config_xml := pkg_iface_lht_function.get_lht_configuration(1);
    s_lht_web_server := getWebServerAddress(lht_config_xml, 'trax_WebServer_Address');
  EXCEPTION
    WHEN others THEN
      s_lht_web_server := null;
      i_port := 80;
    NULL;
  END getLhtWebServer;

  -- send message via rest service
  procedure sendMessage(
    s_parameter IN VARCHAR2,
    s_return OUT NOCOPY VARCHAR2) AS

    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(32767);
    v_msg varchar2(32767);
    v_reason varchar2(2000);
    i_reason number;
    err_code number;
    s_param varchar2(3000);

  BEGIN
    -- initialize return string
    s_return := '';
    s_param := s_parameter;
    -- get web server address
    getWebInfoMultiCompany(s_parameter); -- 136626

    v_url := s_web_server;

    if (s_parameter is not null and length(trim(s_parameter)) > 0) then

      --check if it contains 'reason=' string, this is for invoice exception message
      i_reason := INSTR(s_parameter, 'reason=') + 7; -- 7 is the length of reason=
      if (i_reason > 7) then
        v_reason := SUBSTR(s_parameter, i_reason);
        if (v_reason is not null and length(trim(v_reason))>0) then
          v_reason := utl_url.escape(v_reason, true);
          s_param := SUBSTR(s_parameter, 1, i_reason - 1) || v_reason;
        end if;
      end if;
      v_url := v_url || '?' || s_param;
    end if;

    -- set timeout to 180 seconds
    UTL_HTTP.set_transfer_timeout (180);

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );

    -- set header
    Utl_Http.Set_Header (req, 'User-Agent', 'Mozilla/4.0' );

    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );
    begin
      loop
        Utl_Http.Read_Text (resp, v_msg );
        s_return := s_return || v_msg ;
      end loop;
      exception
        when Utl_Http.End_Of_Body
        then null;
    end;

    -- end response
    Utl_Http.End_Response (resp );
  exception
    when Utl_Http.Request_Failed then
      s_return := s_return || 'Request_Failed: ' || Utl_Http.Get_Detailed_Sqlerrm ;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    -- raised by URL http://xxx.oracle.com/
    when Utl_Http.Http_Server_Error then
      s_return := s_return || 'Http_Server_Error: ' || Utl_Http.Get_Detailed_Sqlerrm ;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    -- raised by URL /xxx
    when Utl_Http.Http_Client_Error then
      s_return := s_return || 'Http_Client_Error: ' || Utl_Http.Get_Detailed_Sqlerrm;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    when Utl_Http.Unknown_Scheme then
      s_return := 'The requested URL "' || v_url || '" is unknown, ' || Utl_Http.Get_Detailed_Sqlerrm;
      RAISE_APPLICATION_ERROR(-20010, s_return, TRUE);

    -- code for all the other defined exceptions you can recover from
    when others then
      err_code := sqlcode;
      if (err_code = -12545) then
        if (s_web_server is null or length(trim(s_web_server)) = 0) then
          s_return := 'The Spec2000 Web Server Address is not setup, please set it up in Company Profile\Spec2000 Configuration.';
        else
          s_return := 'The address "' || v_url || '" is not valid, or the program being connected to does not exist. ';
        end if;
      end if;
      RAISE_APPLICATION_ERROR(-20010,s_return,TRUE);
  end;

  -- send message via rest service
  procedure sendRosMessage(
    s_parameter IN VARCHAR2,
    s_return OUT NOCOPY VARCHAR2) AS
  begin
    sendOsMessage(s_parameter, s_return, 'ROS');
  end;

  function sendLHTMessage(
    s_parameter IN VARCHAR2) return VARCHAR2 AS

    s_return varchar2(32000);
    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(32767);
    v_msg varchar2(32767);
    v_reason varchar2(2000);
    i_reason number;
    err_code number;
    s_param varchar2(3000);
    exp exception;

  BEGIN
    -- initialize return string
    s_return := '';
    s_param := s_parameter;
    -- get web server address
    getLhtWebInfo();

    v_url := s_lht_web_server;

    s_param := UTL_URL.ESCAPE(s_param);
    if (s_parameter is not null and length(trim(s_parameter)) > 0) then
      v_url := v_url || '?' || s_param;
    end if;

    -- set timeout to 180 seconds
    UTL_HTTP.set_transfer_timeout (180);

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );

    -- set header
    Utl_Http.Set_Header (req, 'User-Agent', 'Mozilla/4.0' );

    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );
    begin
      loop
        Utl_Http.Read_Text (resp, v_msg );
        s_return := s_return || v_msg ;
      end loop;
    exception
       when Utl_Http.End_Of_Body
         then null;
       when others then
         raise_application_error(-20111, sqlcode || ': ' || sqlerrm, true);
    end;
     -- end response
     Utl_Http.End_Response (resp);

    return s_return;
--    exception
--      when others then
--        return dbms_utility.format_call_stack;
  end sendLHTMessage;

  function sendLHTMessage_TEXT(
    s_parameter IN VARCHAR2) return VARCHAR2 AS

    s_return varchar2(32000);
    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(32767);
    v_msg varchar2(32767);
    v_reason varchar2(2000);
    i_reason number;
    err_code number;
    s_param varchar2(3000);
    exp exception;

  BEGIN
    -- initialize return string
    s_return := '';
    s_param := s_parameter;
    -- get web server address
    getLhtWebServer();

    v_url := s_lht_web_server;

    s_param := UTL_URL.ESCAPE(s_param);
    if (s_parameter is not null and length(trim(s_parameter)) > 0) then
      v_url := v_url || '?' || s_param;
    end if;

    -- set timeout to 180 seconds
    UTL_HTTP.set_transfer_timeout (180);

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );

    -- set header
    Utl_Http.Set_Header (req, 'User-Agent', 'Mozilla/4.0' );

    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );
    begin
      loop
        Utl_Http.Read_Text (resp, v_msg );
        s_return := s_return || v_msg ;
      end loop;
    exception
       when Utl_Http.End_Of_Body
         then null;
       when others then
         raise_application_error(-20111, sqlcode || ': ' || sqlerrm, true);
    end;
     -- end response
     Utl_Http.End_Response (resp);

    return s_return;
--    exception
--      when others then
--        return dbms_utility.format_call_stack;
  end sendLHTMessage_TEXT;

 procedure sendAC_TAT
 AS
  s_return VARCHAR2(2000);
 BEGIN
  s_return := sendLHTMessage('operation=SENDAC_TAT');
 END;

  procedure sendAddCounter2JobCall
  as
    s_return varchar2(2000);
  begin
    s_return := sendLHTMessage_TEXT('operation=SEND_ADD_COUNTER2_JOB_CALL');
  end;

    -- get server, authentication information from profile master
  Function getCaseBank_RestService return varchar2 IS
    drts_system_config_blob BLOB;
    s_rest_service_url varchar2(2000);
    s_char VARCHAR2(10);
    l_len INTEGER;
  BEGIN

    SELECT TGF."DRTS_SYSTEM_CONFIG"
    INTO drts_system_config_blob
    FROM "TRAX_GLOBAL_FILES" TGF,
         "PROFILE_MASTER" P
    WHERE 1=1
    AND (PKG_TRAX_SESSION.f_getprofile = P."PROFILE" OR (SELECT P2."PROFILE"
                                                       FROM "PROFILE_MASTER" P2
                                                       WHERE P2."PROFILE" = PKG_TRAX_SESSION.f_getprofile) IS NULL)
    AND ROWNUM = 1;

    IF LENGTH(drts_system_config_blob) > 0 THEN
      s_rest_service_url := "PKG_BLOB_FUNCTION".getElementValue(drts_system_config_blob, '//REST_URL');
      l_len := length(s_rest_service_url);
      s_char := substr(s_rest_service_url, l_len, 1);

      if s_char = '/' then
        s_rest_service_url := substr(s_rest_service_url, 1, l_len - 1);
      end if;
    END IF;
    return s_rest_service_url;
  EXCEPTION
    WHEN no_data_found THEN
      return null;
  END getCaseBank_RestService;

  Procedure CaseBank_Send(
    s_operation In varchar2,
    l_transaction In Number,
    s_return Out varchar2)
  as
    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(2000);
    v_msg varchar2(32767);

    err_code number;
  BEGIN
    -- initialize return string
    s_return := '';

    -- get web server address
    v_url := getCaseBank_RestService();

    if (l_transaction is not null and l_transaction > 0) then
      -- Changed ampersand to Chr(38) below because problems when run in sql plus.
      v_url := v_url || '?operation='||s_operation || chr(38) || 'transaction=' || to_char(l_transaction);
    end if;

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );

    -- set header
    Utl_Http.Set_Header (req, 'User-Agent', 'Mozilla/4.0' );

    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );
    begin
      loop
        Utl_Http.Read_Text (resp, v_msg );
        s_return := s_return || v_msg ;
      end loop;
      exception
        when Utl_Http.End_Of_Body
        then null;
    end;

    -- end response
    Utl_Http.End_Response (resp );
  exception
    when Utl_Http.Request_Failed then
      s_return := s_return || 'Request_Failed: ' || Utl_Http.Get_Detailed_Sqlerrm ;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    -- raised by URL http://xxx.oracle.com/
    when Utl_Http.Http_Server_Error then
      s_return := s_return || 'Http_Server_Error: ' || Utl_Http.Get_Detailed_Sqlerrm ;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    -- raised by URL /xxx
    when Utl_Http.Http_Client_Error then
      s_return := s_return || 'Http_Client_Error: ' || Utl_Http.Get_Detailed_Sqlerrm;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    when Utl_Http.Unknown_Scheme then
      s_return := 'The requested URL "' || v_url || '" is unknown, ' || Utl_Http.Get_Detailed_Sqlerrm;
      RAISE_APPLICATION_ERROR(-20010, s_return, TRUE);

    -- code for all the other defined exceptions you can recover from
    when others then
      err_code := sqlcode;
      if (err_code = -12545) then
        if (s_web_server is null or length(trim(s_web_server)) = 0) then
          s_return := 'The DRTS Web Server Address is not setup, please set it up in Company Profile.';
        else
          s_return := 'The address "' || v_url || '" is not valid, or the program being connected to does not exist. ';
        end if;
      end if;
      RAISE_APPLICATION_ERROR(-20010,s_return,TRUE);
  end;

  procedure test_casebank as
    xmlInput xmlType;
    clob_data clob;
    tempClob clob;
    s_output varchar2(32767);
  begin
    CaseBank_Send('CaseBank_SpotLight', 39694605, s_output);
    DBMS_OUTPUT.PUT_LINE('S_OUTPUT = ' || S_OUTPUT);
  end;

  Function CaseBank_Spotlight(s_operation In varchar2, l_transaction In Number) Return VARCHAR2 Is
    s_output varchar2(32767);
    s_return varchar2(32767);
  Begin
    CaseBank_Send(s_operation, l_transaction, s_output);
    s_return := s_output;
    Return s_return;
  End;


  FUNCTION sendLHTMessage_BLOB
  (
    s_parameter IN VARCHAR2,
    s_content_type OUT VARCHAR2
  ) RETURN BLOB AS
    returnBLOB BLOB;
    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(32767);
    err_code number;
    s_param varchar2(3000);
    raw_data raw(32767);
    s_return varchar2(32767);
  BEGIN
     -- initialize
    s_param := s_parameter;
    returnBlob:= empty_BLOB();
    dbms_lob.createtemporary(
      returnBlob ,
      false);
    -- get web server address
    getLhtWebServer();

    v_url := s_lht_web_server;

    if (s_parameter is not null and length(trim(s_parameter)) > 0) then
      v_url := v_url || '?' || s_param;
    end if;

    -- set timeout to 180 seconds
    UTL_HTTP.set_transfer_timeout (180);

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );

    -- set header
    Utl_Http.Set_Header (req, 'User-Agent', 'Mozilla/4.0' );

    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );

    begin
      loop
        Utl_Http.Read_RAW (resp, raw_data, 32767);
        DBMS_LOB.WRITEAPPEND(returnBlob, UTL_RAW.length(raw_data), raw_data);
      end loop;
    exception
      when Utl_Http.End_Of_Body
      then null;
    end;

    -- Get Content Type of response
    BEGIN
      UTL_HTTP.GET_HEADER_BY_NAME(resp, 'Content-Type', s_content_type);
    EXCEPTION
      WHEN OTHERS THEN
        NULL;
    END;

    -- end response
    Utl_Http.End_Response (resp);

    return returnBlob;
  END ;

  -- Jing Huang 136626 02/08/2012
  PROCEDURE getWebInfoMultiCompany(p_parameter in varchar2)
  as
    s_profile "PROFILE_MASTER"."PROFILE"%TYPE;
    s_char VARCHAR2(10);
    l_len INTEGER;
  begin
    s_profile := pkg_spec2000_common.get_profile(p_parameter);
  
    SELECT P."SPEC2000_WEB_SERVER_ADDRESS"
      INTO s_web_server
      FROM "PROFILE_MASTER" P
      WHERE "PROFILE" = s_profile;
    
    s_web_server := trim(s_web_server);
    l_len := length(s_web_server);
    s_char := substr(s_web_server, l_len, 1);

    if s_char = '/' then
      s_web_server := substr(s_web_server, 1, l_len - 1);
    end if;
  EXCEPTION
    WHEN no_data_found THEN
      s_web_server := null;
      i_port := 80;
  end getWebInfoMultiCompany;
  -- 136626

  -- Murata Manager REST Procedures - Mijail O. T. 02/08/12
  FUNCTION sendMcmMessage_txt(s_parameter IN VARCHAR2, s_Transaction IN VARCHAR2 := NULL) return VARCHAR2 AS
    s_return varchar2(32000);
    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(32767);
    v_msg varchar2(32767);    
    err_code number;
    s_param varchar2(3000);
    exp exception;
    S_Char Varchar2(10);
    l_len INTEGER;

  BEGIN
    -- initialize return string
    S_Return := '';   
    s_param := s_parameter;
   
    -- Getting web server address
    BEGIN
    
      select extractvalue(murata_config, '/*/Rest_Server_Address')
        Into S_Web_Server
        from PROFILE_MASTER;
      
      s_web_server := trim(s_web_server);
      l_len := length(s_web_server);
      s_char := substr(s_web_server, l_len, 1);
  
      if s_char = '/' then
        s_web_server := substr(s_web_server, 1, l_len - 1);
      end if;
    EXCEPTION
      WHEN no_data_found THEN
        s_web_server := null;
        i_port := 80;
      Null;
    END;
  -- End -- Get WebServer address

  -- Setting Rest Call String  
    v_url := s_web_server;
  
  -- Setting Parameter
    if (s_parameter is not null and length(trim(s_parameter)) > 0) then
      v_url := v_url || '?' || s_param;
    end if;
    
    -- Setting Picking Station
     if (s_Transaction is not null) then
      -- Changed ampersand to Chr(38) below because problems when run in sql plus.
      v_url := v_url || Chr(38) || 'Transaction=' || s_Transaction;
    end if;
    
    -- set timeout to 180 seconds
    UTL_HTTP.set_transfer_timeout (180);

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );

    -- set header
    Utl_Http.Set_Header (req, 'User-Agent', 'Mozilla/4.0' );

    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );
    begin
      loop
        Utl_Http.Read_Text (resp, v_msg );
        s_return := s_return || v_msg ;
      end loop;
      exception
        when Utl_Http.End_Of_Body
        then null;
    end;

    -- end response
    Utl_Http.End_Response (Resp );
    Return S_Return;
    
  EXCEPTION
    when Utl_Http.Request_Failed then
      s_return := s_return || 'Request_Failed: ' || Utl_Http.Get_Detailed_Sqlerrm ;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    -- raised by URL http://xxx.oracle.com/
    when Utl_Http.Http_Server_Error then
      s_return := s_return || 'Http_Server_Error: ' || Utl_Http.Get_Detailed_Sqlerrm ;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    -- raised by URL /xxx
    when Utl_Http.Http_Client_Error then
      s_return := s_return || 'Http_Client_Error: ' || Utl_Http.Get_Detailed_Sqlerrm;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    when Utl_Http.Unknown_Scheme then
      s_return := 'The requested URL "' || v_url || '" is unknown, ' || Utl_Http.Get_Detailed_Sqlerrm;
      RAISE_APPLICATION_ERROR(-20010, s_return, TRUE);

    -- code for all the other defined exceptions you can recover from
    when others then
      err_code := sqlcode;
      if (err_code = -12545) then
        if (s_web_server is null or length(trim(s_web_server)) = 0) then
          s_return := 'The MCM Web Server Address is not setup.';
        else
          s_return := 'The address "' || v_url || '" is not valid, or the program being connected to is offline. ';
        end if;
      end if;
      Raise_Application_Error(-20010,S_Return,True);      
   
  end sendMcmMessage_txt;
  
  procedure SendMcmMessage(s_Transaction varchar2) as
    s_return varchar2(2000);
  BEGIN
    s_return := sendMcmMessage_txt('operation=SEND_MCM_COMMAND', s_Transaction);
  end SENDMCMMESSAGE;
  
  procedure sendMcmSTAR as
    s_return varchar2(2000);
  BEGIN
    S_Return := Sendmcmmessage_Txt('operation=SEND_MCM_STAR', null);
  End Sendmcmstar;

-- End Murata Manager REST Procedures
   
  -- Jing Huang 151389 12-11-2012
  procedure sendEosMessage(
    s_parameter IN VARCHAR2,
    S_RETURN OUT NOCOPY varchar2)
  as
  begin
    sendOsMessage(s_parameter, s_return, 'EOS');
  end;
  
  -- Jing Huang 151389 12-11-2012
  procedure sendOsMessage(
    s_parameter IN VARCHAR2,
    S_RETURN OUT NOCOPY varchar2,
    P_TRANSACTION_TYPE in varchar2)
  as
    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(32767);
    v_msg varchar2(32767);
    v_reason varchar2(2000);
    i_reason number;
    err_code number;
    s_param varchar2(3000);
    s_transaction_type varchar2(20);
  BEGIN
    -- initialize return string
    s_return := '';
    s_param := s_parameter;

    s_transaction_type := 
      case 
        when instr(p_transaction_type, 'ROS') > 0 then 'ROS' 
        when instr(p_transaction_type, 'EOS') > 0 then 'EOS'
        when instr(p_transaction_type, 'XOS') > 0 then 'Supplier EOS'
        else null
      end;
      
    -- get web server address
    getOsWebInfo(p_transaction_type);
    
    v_url := s_ros_web_server;

    if (s_parameter is not null and length(trim(s_parameter)) > 0) then

      --check if it contains 'reason=' string, this is for invoice exception message
      i_reason := INSTR(s_parameter, 'reason=') + 7; -- 7 is the length of reason=
      if (i_reason > 7) then
        v_reason := SUBSTR(s_parameter, i_reason);
        if (v_reason is not null and length(trim(v_reason))>0) then
          v_reason := utl_url.escape(v_reason, true);
          s_param := SUBSTR(s_parameter, 1, i_reason - 1) || v_reason;
        end if;
      end if;
      v_url := v_url || '?' || s_param;
    end if;

    -- set timeout to 180 seconds
    UTL_HTTP.set_transfer_timeout (180);

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );

    -- set header
    Utl_Http.Set_Header (req, 'User-Agent', 'Mozilla/4.0' );

    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );
    begin
      loop
        Utl_Http.Read_Text (resp, v_msg );
        s_return := s_return || v_msg ;
      end loop;
      exception
        when Utl_Http.End_Of_Body
        then null;
    end;

    -- end response
    Utl_Http.End_Response (resp );
  exception
    when Utl_Http.Request_Failed then
      s_return := s_return || 'Request_Failed: ' || Utl_Http.Get_Detailed_Sqlerrm ;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    -- raised by URL http://xxx.oracle.com/
    when Utl_Http.Http_Server_Error then
      s_return := s_return || 'Http_Server_Error: ' || Utl_Http.Get_Detailed_Sqlerrm ;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    -- raised by URL /xxx
    when Utl_Http.Http_Client_Error then
      s_return := s_return || 'Http_Client_Error: ' || Utl_Http.Get_Detailed_Sqlerrm;
      RAISE_APPLICATION_ERROR(-20010,SQLERRM,TRUE);

    when Utl_Http.Unknown_Scheme then
      s_return := 'The requested URL "' || v_url || '" is unknown, ' || Utl_Http.Get_Detailed_Sqlerrm;
      RAISE_APPLICATION_ERROR(-20010, s_return, TRUE);

    -- code for all the other defined exceptions you can recover from
    when others then
      err_code := sqlcode;
      if (err_code = -12545) then
        if (s_web_server is null or length(trim(s_web_server)) = 0) then
          s_return := 'The OS Web Server Address is not setup, please set it up in Company Profile\' || s_transaction_type ||' Configuration.';
        else
          s_return := 'The address "' || v_url || '" is not valid, or the program being connected to does not exist. ';
        end if;
      end if;
      RAISE_APPLICATION_ERROR(-20010,S_RETURN,true);
  end;
  
   --Jing Huang 198869 10/28/2015
  PROCEDURE getIconnectorWebServer AS
    s_char VARCHAR2(10);
    l_len INTEGER;
    s_os_config varchar2(1000);
  Begin
   null;
  EXCEPTION
    WHEN others THEN
      s_iconnector_web_server := null;
      i_port := 80;
    NULL;
  END getIconnectorWebServer;
  
  -- ---------------------------------
  -- Jing Huang 198869
  -- ---------------------------------
  function sendIconnectorMessage(
    s_parameter IN VARCHAR2 , s_path IN varchar2) return VARCHAR2 AS

    s_return varchar2(32000);
    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(32767);
    v_msg varchar2(32767);
    v_reason varchar2(2000);
    i_reason number;
    err_code number;
    s_param varchar2(3000);
    exp exception;
    -- Post Parameters
     v_param VARCHAR2(32767) := s_parameter;
     v_param_length NUMBER := length(v_param);

  BEGIN
    -- initialize return string
    s_return := '';
    s_param := s_parameter;
    
    -- get web server address
    getIconnectorWebServer();

    v_url := s_iconnector_web_server || s_path;

    s_param := UTL_URL.ESCAPE(s_param);

    -- set timeout to 180 seconds
    UTL_HTTP.set_transfer_timeout (180);

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );


    -- set header
    UTL_HTTP.SET_HEADER (r      =>  req,
                       name   =>  'Content-Type',
                       value  =>  'text/plain;charset=UTF-8');
                       
    UTL_HTTP.SET_HEADER ( r      =>   req,
                          name   =>   'Content-Length',
                          value  =>   v_param_length);
                          
    UTL_HTTP.WRITE_TEXT ( r      =>   req,
                          data   =>   v_param);

--    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );
    begin
      loop
        Utl_Http.Read_Text (resp, v_msg );
        s_return := s_return || v_msg ;
      end loop;
    exception
       when Utl_Http.End_Of_Body then
          -- end response
          Utl_Http.End_Response (resp);
       when Utl_Http.Request_Failed then
         s_return := s_return || 'Request_Failed: ' || Utl_Http.Get_Detailed_Sqlerrm ;
         -- end response
         Utl_Http.End_Response (resp);
         RAISE_APPLICATION_ERROR(-20010,s_return,TRUE);

        -- raised by URL http://xxx.oracle.com/
        when Utl_Http.Http_Server_Error then
          s_return := s_return || 'Http_Server_Error: ' || Utl_Http.Get_Detailed_Sqlerrm ;
          -- end response
          Utl_Http.End_Response (resp);
          RAISE_APPLICATION_ERROR(-20010,s_return,TRUE);

        -- raised by URL /xxx
        when Utl_Http.Http_Client_Error then
          s_return := s_return || 'Http_Client_Error: ' || Utl_Http.Get_Detailed_Sqlerrm;
          -- end response
          Utl_Http.End_Response (resp);
          RAISE_APPLICATION_ERROR(-20010,s_return,TRUE);

        when others then
          s_return := s_return || sqlcode || ': ' || sqlerrm;
          -- end response
          Utl_Http.End_Response (resp);
          raise_application_error(-20111, s_return, true);
    end;

    return s_return;
  end sendIconnectorMessage;
  
    -- ---------------------------------
  -- Jing Huang 198869
  -- ---------------------------------
  function call_wpl_api(
    s_parameter IN VARCHAR2 , s_path IN varchar2) return VARCHAR2 AS

    s_return varchar2(32000);
    req Utl_Http.Req;
    resp Utl_Http.Resp;
    v_url varchar2(32767);
    v_msg varchar2(32767);
    v_reason varchar2(2000);
    i_reason number;
    err_code number;
    s_param varchar2(3000);
    exp exception;
    -- Post Parameters
     v_param VARCHAR2(32767) := s_parameter;
     v_param_length NUMBER := length(v_param);

  BEGIN
    -- initialize return string
    s_return := '';
    s_param := s_parameter;
    
    -- get web server address
    getIconnectorWebServer();

    v_url := s_iconnector_web_server || s_path;

    s_param := UTL_URL.ESCAPE(s_param);
    if (s_parameter is not null and length(trim(s_parameter)) > 0) then
      v_url := v_url || '?' || s_param;
    end if;

    -- set timeout to 180 seconds
    UTL_HTTP.set_transfer_timeout (180);

    -- request that exceptions are raised for error Status Codes
    Utl_Http.Set_Response_Error_Check (true);

    -- allow testing for exceptions like Utl_Http.Http_Server_Error
    Utl_Http.Set_Detailed_Excp_Support (true);

    -- begin POST request
    req := Utl_Http.Begin_Request (v_url, 'POST' );


    -- set header
    UTL_HTTP.SET_HEADER (r      =>  req,
                       name   =>  'Content-Type',
                       value  =>  'text/plain;charset=UTF-8');

--    -- get response and write it into the return string
    resp := Utl_Http.Get_Response ( req );
    begin
      loop
        Utl_Http.Read_Text (resp, v_msg );
        if length(nvl(s_return || v_msg, ' ')) < 4000 then
          s_return := s_return || v_msg ;
        end if;
      end loop;
    exception
       when Utl_Http.End_Of_Body then
         Utl_Http.End_Response (resp);
         
       when Utl_Http.Request_Failed then
         s_return := s_return || 'Request_Failed: ' || Utl_Http.Get_Detailed_Sqlerrm ;
         Utl_Http.End_Response (resp);
         RAISE_APPLICATION_ERROR(-20010,s_return,TRUE);

        -- raised by URL http://xxx.oracle.com/
        when Utl_Http.Http_Server_Error then
          s_return := s_return || 'Http_Server_Error: ' || Utl_Http.Get_Detailed_Sqlerrm ;
          Utl_Http.End_Response (resp);
          RAISE_APPLICATION_ERROR(-20010,s_return,TRUE);

        -- raised by URL /xxx
        when Utl_Http.Http_Client_Error then
          s_return := s_return || 'Http_Client_Error: ' || Utl_Http.Get_Detailed_Sqlerrm;
          Utl_Http.End_Response (resp);
          RAISE_APPLICATION_ERROR(-20010,s_return,TRUE);

        when others then
          s_return := s_return || sqlcode || ': ' || sqlerrm;
          Utl_Http.End_Response (resp);
          raise_application_error(-20111, s_return, true);
    end;

    return s_return;
  end call_wpl_api;
  

 procedure syncEmobilityQueue( contentData VARCHAR2, messageType IN varchar2) 
  AS
   
    BEGIN   
    
    insert into IOS_NOTIFICATION_QUEUE
    (
    ID ,
    MESSAGE_TYPE , 
    CONTENT_DATA , 
    CREATE_DATE 
    )
    values
    (
     SEQ_IOS_NOT_QUEUE.NEXTVAL , 
     messageType , 
     contentData , 
     sysdate
    );
    
    commit ; 

  EXCEPTION    
    WHEN OTHERS THEN
    plog.debug('ERROR in IOS SYNC: ' || messageType ||' contect: ' || contentData );
  END syncEmobilityQueue;
  
 
END PKG_WEB_REST;

/ 








